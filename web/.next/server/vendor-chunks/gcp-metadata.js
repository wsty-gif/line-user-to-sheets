"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gcp-metadata";
exports.ids = ["vendor-chunks/gcp-metadata"];
exports.modules = {

/***/ "(api)/../node_modules/gcp-metadata/build/src/gcp-residency.js":
/*!***************************************************************!*\
  !*** ../node_modules/gcp-metadata/build/src/gcp-residency.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.detectGCPResidency = exports.isGoogleComputeEngine = exports.isGoogleComputeEngineMACAddress = exports.isGoogleComputeEngineLinux = exports.isGoogleCloudServerless = exports.GCE_LINUX_BIOS_PATHS = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst os_1 = __webpack_require__(/*! os */ \"os\");\n/**\n * Known paths unique to Google Compute Engine Linux instances\n */\nexports.GCE_LINUX_BIOS_PATHS = {\n    BIOS_DATE: '/sys/class/dmi/id/bios_date',\n    BIOS_VENDOR: '/sys/class/dmi/id/bios_vendor',\n};\nconst GCE_MAC_ADDRESS_REGEX = /^42:01/;\n/**\n * Determines if the process is running on a Google Cloud Serverless environment (Cloud Run or Cloud Functions instance).\n *\n * Uses the:\n * - {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n * - {@link https://cloud.google.com/functions/docs/env-var Cloud Functions environment variables}.\n *\n * @returns {boolean} `true` if the process is running on GCP serverless, `false` otherwise.\n */\nfunction isGoogleCloudServerless() {\n    /**\n     * `CLOUD_RUN_JOB` is used for Cloud Run Jobs\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     *\n     * `FUNCTION_NAME` is used in older Cloud Functions environments:\n     * - See {@link https://cloud.google.com/functions/docs/env-var Python 3.7 and Go 1.11}.\n     *\n     * `K_SERVICE` is used in Cloud Run and newer Cloud Functions environments:\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     * - See {@link https://cloud.google.com/functions/docs/env-var Cloud Functions newer runtimes}.\n     */\n    const isGFEnvironment = process.env.CLOUD_RUN_JOB ||\n        process.env.FUNCTION_NAME ||\n        process.env.K_SERVICE;\n    return !!isGFEnvironment;\n}\nexports.isGoogleCloudServerless = isGoogleCloudServerless;\n/**\n * Determines if the process is running on a Linux Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on Linux GCE, `false` otherwise.\n */\nfunction isGoogleComputeEngineLinux() {\n    if ((0, os_1.platform)() !== 'linux')\n        return false;\n    try {\n        // ensure this file exist\n        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);\n        // ensure this file exist and matches\n        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, 'utf8');\n        return /Google/.test(biosVendor);\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;\n/**\n * Determines if the process is running on a Google Compute Engine instance with a known\n * MAC address.\n *\n * @returns {boolean} `true` if the process is running on GCE (as determined by MAC address), `false` otherwise.\n */\nfunction isGoogleComputeEngineMACAddress() {\n    const interfaces = (0, os_1.networkInterfaces)();\n    for (const item of Object.values(interfaces)) {\n        if (!item)\n            continue;\n        for (const { mac } of item) {\n            if (GCE_MAC_ADDRESS_REGEX.test(mac)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;\n/**\n * Determines if the process is running on a Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on GCE, `false` otherwise.\n */\nfunction isGoogleComputeEngine() {\n    return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();\n}\nexports.isGoogleComputeEngine = isGoogleComputeEngine;\n/**\n * Determines if the process is running on Google Cloud Platform.\n *\n * @returns {boolean} `true` if the process is running on GCP, `false` otherwise.\n */\nfunction detectGCPResidency() {\n    return isGoogleCloudServerless() || isGoogleComputeEngine();\n}\nexports.detectGCPResidency = detectGCPResidency;\n//# sourceMappingURL=gcp-residency.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvZ2NwLXJlc2lkZW5jeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyw2QkFBNkIsR0FBRyx1Q0FBdUMsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyw0QkFBNEI7QUFDMU0sYUFBYSxtQkFBTyxDQUFDLGNBQUk7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGNBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9HQUFvRztBQUMxRyxNQUFNLDRGQUE0RjtBQUNsRztBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0dBQW9HO0FBQ2xIO0FBQ0E7QUFDQSxjQUFjLDZFQUE2RTtBQUMzRjtBQUNBO0FBQ0EsY0FBYyxvR0FBb0c7QUFDbEgsY0FBYyxxRkFBcUY7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvZ2NwLXJlc2lkZW5jeS5qcz9kZjRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXRlY3RHQ1BSZXNpZGVuY3kgPSBleHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZSA9IGV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lTUFDQWRkcmVzcyA9IGV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lTGludXggPSBleHBvcnRzLmlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzID0gZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUyA9IHZvaWQgMDtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBvc18xID0gcmVxdWlyZShcIm9zXCIpO1xuLyoqXG4gKiBLbm93biBwYXRocyB1bmlxdWUgdG8gR29vZ2xlIENvbXB1dGUgRW5naW5lIExpbnV4IGluc3RhbmNlc1xuICovXG5leHBvcnRzLkdDRV9MSU5VWF9CSU9TX1BBVEhTID0ge1xuICAgIEJJT1NfREFURTogJy9zeXMvY2xhc3MvZG1pL2lkL2Jpb3NfZGF0ZScsXG4gICAgQklPU19WRU5ET1I6ICcvc3lzL2NsYXNzL2RtaS9pZC9iaW9zX3ZlbmRvcicsXG59O1xuY29uc3QgR0NFX01BQ19BRERSRVNTX1JFR0VYID0gL140MjowMS87XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBhIEdvb2dsZSBDbG91ZCBTZXJ2ZXJsZXNzIGVudmlyb25tZW50IChDbG91ZCBSdW4gb3IgQ2xvdWQgRnVuY3Rpb25zIGluc3RhbmNlKS5cbiAqXG4gKiBVc2VzIHRoZTpcbiAqIC0ge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9ydW4vZG9jcy9jb250YWluZXItY29udHJhY3QjZW52LXZhcnMgQ2xvdWQgUnVuIGVudmlyb25tZW50IHZhcmlhYmxlc30uXG4gKiAtIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZnVuY3Rpb25zL2RvY3MvZW52LXZhciBDbG91ZCBGdW5jdGlvbnMgZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NQIHNlcnZlcmxlc3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNsb3VkU2VydmVybGVzcygpIHtcbiAgICAvKipcbiAgICAgKiBgQ0xPVURfUlVOX0pPQmAgaXMgdXNlZCBmb3IgQ2xvdWQgUnVuIEpvYnNcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAgICAgKlxuICAgICAqIGBGVU5DVElPTl9OQU1FYCBpcyB1c2VkIGluIG9sZGVyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudHM6XG4gICAgICogLSBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9mdW5jdGlvbnMvZG9jcy9lbnYtdmFyIFB5dGhvbiAzLjcgYW5kIEdvIDEuMTF9LlxuICAgICAqXG4gICAgICogYEtfU0VSVklDRWAgaXMgdXNlZCBpbiBDbG91ZCBSdW4gYW5kIG5ld2VyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudHM6XG4gICAgICogLSBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9ydW4vZG9jcy9jb250YWluZXItY29udHJhY3QjZW52LXZhcnMgQ2xvdWQgUnVuIGVudmlyb25tZW50IHZhcmlhYmxlc30uXG4gICAgICogLSBTZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9mdW5jdGlvbnMvZG9jcy9lbnYtdmFyIENsb3VkIEZ1bmN0aW9ucyBuZXdlciBydW50aW1lc30uXG4gICAgICovXG4gICAgY29uc3QgaXNHRkVudmlyb25tZW50ID0gcHJvY2Vzcy5lbnYuQ0xPVURfUlVOX0pPQiB8fFxuICAgICAgICBwcm9jZXNzLmVudi5GVU5DVElPTl9OQU1FIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LktfU0VSVklDRTtcbiAgICByZXR1cm4gISFpc0dGRW52aXJvbm1lbnQ7XG59XG5leHBvcnRzLmlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzID0gaXNHb29nbGVDbG91ZFNlcnZlcmxlc3M7XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBhIExpbnV4IEdvb2dsZSBDb21wdXRlIEVuZ2luZSBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gTGludXggR0NFLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNHb29nbGVDb21wdXRlRW5naW5lTGludXgoKSB7XG4gICAgaWYgKCgwLCBvc18xLnBsYXRmb3JtKSgpICE9PSAnbGludXgnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZW5zdXJlIHRoaXMgZmlsZSBleGlzdFxuICAgICAgICAoMCwgZnNfMS5zdGF0U3luYykoZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUy5CSU9TX0RBVEUpO1xuICAgICAgICAvLyBlbnN1cmUgdGhpcyBmaWxlIGV4aXN0IGFuZCBtYXRjaGVzXG4gICAgICAgIGNvbnN0IGJpb3NWZW5kb3IgPSAoMCwgZnNfMS5yZWFkRmlsZVN5bmMpKGV4cG9ydHMuR0NFX0xJTlVYX0JJT1NfUEFUSFMuQklPU19WRU5ET1IsICd1dGY4Jyk7XG4gICAgICAgIHJldHVybiAvR29vZ2xlLy50ZXN0KGJpb3NWZW5kb3IpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lTGludXggPSBpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eDtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlIHdpdGggYSBrbm93blxuICogTUFDIGFkZHJlc3MuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdDRSAoYXMgZGV0ZXJtaW5lZCBieSBNQUMgYWRkcmVzcyksIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzKCkge1xuICAgIGNvbnN0IGludGVyZmFjZXMgPSAoMCwgb3NfMS5uZXR3b3JrSW50ZXJmYWNlcykoKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgT2JqZWN0LnZhbHVlcyhpbnRlcmZhY2VzKSkge1xuICAgICAgICBpZiAoIWl0ZW0pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChjb25zdCB7IG1hYyB9IG9mIGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChHQ0VfTUFDX0FERFJFU1NfUkVHRVgudGVzdChtYWMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzID0gaXNHb29nbGVDb21wdXRlRW5naW5lTUFDQWRkcmVzcztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBHQ0UsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNvbXB1dGVFbmdpbmUoKSB7XG4gICAgcmV0dXJuIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZUxpbnV4KCkgfHwgaXNHb29nbGVDb21wdXRlRW5naW5lTUFDQWRkcmVzcygpO1xufVxuZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmUgPSBpc0dvb2dsZUNvbXB1dGVFbmdpbmU7XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBHb29nbGUgQ2xvdWQgUGxhdGZvcm0uXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdDUCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEdDUFJlc2lkZW5jeSgpIHtcbiAgICByZXR1cm4gaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MoKSB8fCBpc0dvb2dsZUNvbXB1dGVFbmdpbmUoKTtcbn1cbmV4cG9ydHMuZGV0ZWN0R0NQUmVzaWRlbmN5ID0gZGV0ZWN0R0NQUmVzaWRlbmN5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2NwLXJlc2lkZW5jeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/gcp-metadata/build/src/gcp-residency.js\n");

/***/ }),

/***/ "(api)/../node_modules/gcp-metadata/build/src/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/gcp-metadata/build/src/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.requestTimeout = exports.setGCPResidency = exports.getGCPResidency = exports.gcpResidencyCache = exports.resetIsAvailableCache = exports.isAvailable = exports.project = exports.instance = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(api)/../node_modules/gaxios/build/src/index.js\");\nconst jsonBigint = __webpack_require__(/*! json-bigint */ \"(api)/../node_modules/json-bigint/index.js\");\nconst gcp_residency_1 = __webpack_require__(/*! ./gcp-residency */ \"(api)/../node_modules/gcp-metadata/build/src/gcp-residency.js\");\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.HOST_ADDRESS = 'http://169.254.169.254';\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });\n/**\n * Metadata server detection override options.\n *\n * Available via `process.env.METADATA_SERVER_DETECTION`.\n */\nexports.METADATA_SERVER_DETECTION = Object.freeze({\n    'assume-present': \"don't try to ping the metadata server, but assume it's present\",\n    none: \"don't try to ping the metadata server, but don't try to use it either\",\n    'bios-only': \"treat the result of a BIOS probe as canonical (don't fall back to pinging)\",\n    'ping-only': 'skip the BIOS probe, and go straight to pinging',\n});\n/**\n * Returns the base URL while taking into account the GCE_METADATA_HOST\n * environment variable if it exists.\n *\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\n */\nfunction getBaseUrl(baseUrl) {\n    if (!baseUrl) {\n        baseUrl =\n            process.env.GCE_METADATA_IP ||\n                process.env.GCE_METADATA_HOST ||\n                exports.HOST_ADDRESS;\n    }\n    // If no scheme is provided default to HTTP:\n    if (!/^https?:\\/\\//.test(baseUrl)) {\n        baseUrl = `http://${baseUrl}`;\n    }\n    return new URL(exports.BASE_PATH, baseUrl).href;\n}\n// Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\nfunction validate(options) {\n    Object.keys(options).forEach(key => {\n        switch (key) {\n            case 'params':\n            case 'property':\n            case 'headers':\n                break;\n            case 'qs':\n                throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n            default:\n                throw new Error(`'${key}' is not a valid configuration option.`);\n        }\n    });\n}\nasync function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { property: options };\n    }\n    let property = '';\n    if (typeof options === 'object' && options.property) {\n        property = '/' + options.property;\n    }\n    validate(options);\n    try {\n        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n        const res = await requestMethod({\n            url: `${getBaseUrl()}/${type}${property}`,\n            headers: Object.assign({}, exports.HEADERS, options.headers),\n            retryConfig: { noResponseRetries },\n            params: options.params,\n            responseType: 'text',\n            timeout: requestTimeout(),\n        });\n        // NOTE: node.js converts all incoming headers to lower case.\n        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n            throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\n        }\n        else if (!res.data) {\n            throw new Error('Invalid response from the metadata service');\n        }\n        if (typeof res.data === 'string') {\n            try {\n                return jsonBigint.parse(res.data);\n            }\n            catch (_a) {\n                /* ignore */\n            }\n        }\n        return res.data;\n    }\n    catch (e) {\n        const err = e;\n        if (err.response && err.response.status !== 200) {\n            err.message = `Unsuccessful response status code. ${err.message}`;\n        }\n        throw e;\n    }\n}\nasync function fastFailMetadataRequest(options) {\n    const secondaryOptions = {\n        ...options,\n        url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS)),\n    };\n    // We race a connection between DNS/IP to metadata server. There are a couple\n    // reasons for this:\n    //\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\n    //    detect the runtime environment signficantly faster.\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\n    //    on a user's local machine.\n    //\n    // Additional logic has been added to make sure that we don't create an\n    // unhandled rejection in scenarios where a failure happens sometime\n    // after a success.\n    //\n    // Note, however, if a failure happens prior to a success, a rejection should\n    // occur, this is for folks running locally.\n    //\n    let responded = false;\n    const r1 = (0, gaxios_1.request)(options)\n        .then(res => {\n        responded = true;\n        return res;\n    })\n        .catch(err => {\n        if (responded) {\n            return r2;\n        }\n        else {\n            responded = true;\n            throw err;\n        }\n    });\n    const r2 = (0, gaxios_1.request)(secondaryOptions)\n        .then(res => {\n        responded = true;\n        return res;\n    })\n        .catch(err => {\n        if (responded) {\n            return r1;\n        }\n        else {\n            responded = true;\n            throw err;\n        }\n    });\n    return Promise.race([r1, r2]);\n}\n/**\n * Obtain metadata for the current GCE instance\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction instance(options) {\n    return metadataAccessor('instance', options);\n}\nexports.instance = instance;\n/**\n * Obtain metadata for the current GCP Project.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction project(options) {\n    return metadataAccessor('project', options);\n}\nexports.project = project;\n/*\n * How many times should we retry detecting GCP environment.\n */\nfunction detectGCPAvailableRetries() {\n    return process.env.DETECT_GCP_RETRIES\n        ? Number(process.env.DETECT_GCP_RETRIES)\n        : 0;\n}\nlet cachedIsAvailableResponse;\n/**\n * Determine if the metadata server is currently available.\n */\nasync function isAvailable() {\n    if (process.env.METADATA_SERVER_DETECTION) {\n        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();\n        if (!(value in exports.METADATA_SERVER_DETECTION)) {\n            throw new RangeError(`Unknown \\`METADATA_SERVER_DETECTION\\` env variable. Got \\`${value}\\`, but it should be \\`${Object.keys(exports.METADATA_SERVER_DETECTION).join('`, `')}\\`, or unset`);\n        }\n        switch (value) {\n            case 'assume-present':\n                return true;\n            case 'none':\n                return false;\n            case 'bios-only':\n                return getGCPResidency();\n            case 'ping-only':\n            // continue, we want to ping the server\n        }\n    }\n    try {\n        // If a user is instantiating several GCP libraries at the same time,\n        // this may result in multiple calls to isAvailable(), to detect the\n        // runtime environment. We use the same promise for each of these calls\n        // to reduce the network load.\n        if (cachedIsAvailableResponse === undefined) {\n            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), \n            // If the default HOST_ADDRESS has been overridden, we should not\n            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\n            // a non-GCP environment):\n            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\n        }\n        await cachedIsAvailableResponse;\n        return true;\n    }\n    catch (e) {\n        const err = e;\n        if (process.env.DEBUG_AUTH) {\n            console.info(err);\n        }\n        if (err.type === 'request-timeout') {\n            // If running in a GCP environment, metadata endpoint should return\n            // within ms.\n            return false;\n        }\n        if (err.response && err.response.status === 404) {\n            return false;\n        }\n        else {\n            if (!(err.response && err.response.status === 404) &&\n                // A warning is emitted if we see an unexpected err.code, or err.code\n                // is not populated:\n                (!err.code ||\n                    ![\n                        'EHOSTDOWN',\n                        'EHOSTUNREACH',\n                        'ENETUNREACH',\n                        'ENOENT',\n                        'ENOTFOUND',\n                        'ECONNREFUSED',\n                    ].includes(err.code))) {\n                let code = 'UNKNOWN';\n                if (err.code)\n                    code = err.code;\n                process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, 'MetadataLookupWarning');\n            }\n            // Failure to resolve the metadata service means that it is not available.\n            return false;\n        }\n    }\n}\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */\nfunction resetIsAvailableCache() {\n    cachedIsAvailableResponse = undefined;\n}\nexports.resetIsAvailableCache = resetIsAvailableCache;\n/**\n * A cache for the detected GCP Residency.\n */\nexports.gcpResidencyCache = null;\n/**\n * Detects GCP Residency.\n * Caches results to reduce costs for subsequent calls.\n *\n * @see setGCPResidency for setting\n */\nfunction getGCPResidency() {\n    if (exports.gcpResidencyCache === null) {\n        setGCPResidency();\n    }\n    return exports.gcpResidencyCache;\n}\nexports.getGCPResidency = getGCPResidency;\n/**\n * Sets the detected GCP Residency.\n * Useful for forcing metadata server detection behavior.\n *\n * Set `null` to autodetect the environment (default behavior).\n * @see getGCPResidency for getting\n */\nfunction setGCPResidency(value = null) {\n    exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();\n}\nexports.setGCPResidency = setGCPResidency;\n/**\n * Obtain the timeout for requests to the metadata server.\n *\n * In certain environments and conditions requests can take longer than\n * the default timeout to complete. This function will determine the\n * appropriate timeout based on the environment.\n *\n * @returns {number} a request timeout duration in milliseconds.\n */\nfunction requestTimeout() {\n    return getGCPResidency() ? 0 : 3000;\n}\nexports.requestTimeout = requestTimeout;\n__exportStar(__webpack_require__(/*! ./gcp-residency */ \"(api)/../node_modules/gcp-metadata/build/src/gcp-residency.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsNkJBQTZCLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGlDQUFpQyxHQUFHLGVBQWUsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyw4QkFBOEIsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUI7QUFDaFgsaUJBQWlCLG1CQUFPLENBQUMsK0RBQVE7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWE7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsZUFBZSxtQkFBbUIsNkNBQTZDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWEsR0FBRyxLQUFLLEVBQUUsU0FBUztBQUNwRCxxQ0FBcUM7QUFDckMsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlGQUFpRixxQkFBcUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLE1BQU0seUJBQXlCLDREQUE0RDtBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWEsU0FBUyxLQUFLO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsYUFBYSxtQkFBTyxDQUFDLHNGQUFpQjtBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvaW5kZXguanM/OTVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogU2VlIGZpbGUgTElDRU5TRSBmb3IgZGV0YWlsIG9yIGNvcHkgYXQgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcXVlc3RUaW1lb3V0ID0gZXhwb3J0cy5zZXRHQ1BSZXNpZGVuY3kgPSBleHBvcnRzLmdldEdDUFJlc2lkZW5jeSA9IGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGUgPSBleHBvcnRzLnJlc2V0SXNBdmFpbGFibGVDYWNoZSA9IGV4cG9ydHMuaXNBdmFpbGFibGUgPSBleHBvcnRzLnByb2plY3QgPSBleHBvcnRzLmluc3RhbmNlID0gZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OID0gZXhwb3J0cy5IRUFERVJTID0gZXhwb3J0cy5IRUFERVJfVkFMVUUgPSBleHBvcnRzLkhFQURFUl9OQU1FID0gZXhwb3J0cy5TRUNPTkRBUllfSE9TVF9BRERSRVNTID0gZXhwb3J0cy5IT1NUX0FERFJFU1MgPSBleHBvcnRzLkJBU0VfUEFUSCA9IHZvaWQgMDtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IGpzb25CaWdpbnQgPSByZXF1aXJlKFwianNvbi1iaWdpbnRcIik7XG5jb25zdCBnY3BfcmVzaWRlbmN5XzEgPSByZXF1aXJlKFwiLi9nY3AtcmVzaWRlbmN5XCIpO1xuZXhwb3J0cy5CQVNFX1BBVEggPSAnL2NvbXB1dGVNZXRhZGF0YS92MSc7XG5leHBvcnRzLkhPU1RfQUREUkVTUyA9ICdodHRwOi8vMTY5LjI1NC4xNjkuMjU0JztcbmV4cG9ydHMuU0VDT05EQVJZX0hPU1RfQUREUkVTUyA9ICdodHRwOi8vbWV0YWRhdGEuZ29vZ2xlLmludGVybmFsLic7XG5leHBvcnRzLkhFQURFUl9OQU1FID0gJ01ldGFkYXRhLUZsYXZvcic7XG5leHBvcnRzLkhFQURFUl9WQUxVRSA9ICdHb29nbGUnO1xuZXhwb3J0cy5IRUFERVJTID0gT2JqZWN0LmZyZWV6ZSh7IFtleHBvcnRzLkhFQURFUl9OQU1FXTogZXhwb3J0cy5IRUFERVJfVkFMVUUgfSk7XG4vKipcbiAqIE1ldGFkYXRhIHNlcnZlciBkZXRlY3Rpb24gb3ZlcnJpZGUgb3B0aW9ucy5cbiAqXG4gKiBBdmFpbGFibGUgdmlhIGBwcm9jZXNzLmVudi5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OYC5cbiAqL1xuZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgJ2Fzc3VtZS1wcmVzZW50JzogXCJkb24ndCB0cnkgdG8gcGluZyB0aGUgbWV0YWRhdGEgc2VydmVyLCBidXQgYXNzdW1lIGl0J3MgcHJlc2VudFwiLFxuICAgIG5vbmU6IFwiZG9uJ3QgdHJ5IHRvIHBpbmcgdGhlIG1ldGFkYXRhIHNlcnZlciwgYnV0IGRvbid0IHRyeSB0byB1c2UgaXQgZWl0aGVyXCIsXG4gICAgJ2Jpb3Mtb25seSc6IFwidHJlYXQgdGhlIHJlc3VsdCBvZiBhIEJJT1MgcHJvYmUgYXMgY2Fub25pY2FsIChkb24ndCBmYWxsIGJhY2sgdG8gcGluZ2luZylcIixcbiAgICAncGluZy1vbmx5JzogJ3NraXAgdGhlIEJJT1MgcHJvYmUsIGFuZCBnbyBzdHJhaWdodCB0byBwaW5naW5nJyxcbn0pO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIFVSTCB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBHQ0VfTUVUQURBVEFfSE9TVFxuICogZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEByZXR1cm5zIFRoZSBiYXNlIFVSTCwgZS5nLiwgaHR0cDovLzE2OS4yNTQuMTY5LjI1NC9jb21wdXRlTWV0YWRhdGEvdjEuXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICAgIGlmICghYmFzZVVybCkge1xuICAgICAgICBiYXNlVXJsID1cbiAgICAgICAgICAgIHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9JUCB8fFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9IT1NUIHx8XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5IT1NUX0FERFJFU1M7XG4gICAgfVxuICAgIC8vIElmIG5vIHNjaGVtZSBpcyBwcm92aWRlZCBkZWZhdWx0IHRvIEhUVFA6XG4gICAgaWYgKCEvXmh0dHBzPzpcXC9cXC8vLnRlc3QoYmFzZVVybCkpIHtcbiAgICAgICAgYmFzZVVybCA9IGBodHRwOi8vJHtiYXNlVXJsfWA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVVJMKGV4cG9ydHMuQkFTRV9QQVRILCBiYXNlVXJsKS5ocmVmO1xufVxuLy8gQWNjZXB0cyBhbiBvcHRpb25zIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgdXNlciB0byB0aGUgQVBJLiBJbiBwcmV2aW91c1xuLy8gdmVyc2lvbnMgb2YgdGhlIEFQSSwgaXQgcmVmZXJyZWQgdG8gYSBgUmVxdWVzdGAgb3IgYW4gYEF4aW9zYCByZXF1ZXN0XG4vLyBvcHRpb25zIG9iamVjdC4gIE5vdyBpdCByZWZlcnMgdG8gYW4gb2JqZWN0IHdpdGggdmVyeSBsaW1pdGVkIHByb3BlcnR5XG4vLyBuYW1lcy4gVGhpcyBpcyBoZXJlIHRvIGhlbHAgZW5zdXJlIHVzZXJzIGRvbid0IHBhc3MgaW52YWxpZCBvcHRpb25zIHdoZW5cbi8vIHRoZXkgIHVwZ3JhZGUgZnJvbSAwLjQgdG8gMC41IHRvIDAuOC5cbmZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdwYXJhbXMnOlxuICAgICAgICAgICAgY2FzZSAncHJvcGVydHknOlxuICAgICAgICAgICAgY2FzZSAnaGVhZGVycyc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxcyc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3FzJyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uIG9wdGlvbi4gUGxlYXNlIHVzZSAncGFyYW1zJyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtrZXl9JyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uIG9wdGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbWV0YWRhdGFBY2Nlc3Nvcih0eXBlLCBvcHRpb25zLCBub1Jlc3BvbnNlUmV0cmllcyA9IDMsIGZhc3RGYWlsID0gZmFsc2UpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHByb3BlcnR5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIGxldCBwcm9wZXJ0eSA9ICcnO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucy5wcm9wZXJ0eSkge1xuICAgICAgICBwcm9wZXJ0eSA9ICcvJyArIG9wdGlvbnMucHJvcGVydHk7XG4gICAgfVxuICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RNZXRob2QgPSBmYXN0RmFpbCA/IGZhc3RGYWlsTWV0YWRhdGFSZXF1ZXN0IDogZ2F4aW9zXzEucmVxdWVzdDtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdE1ldGhvZCh7XG4gICAgICAgICAgICB1cmw6IGAke2dldEJhc2VVcmwoKX0vJHt0eXBlfSR7cHJvcGVydHl9YCxcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGV4cG9ydHMuSEVBREVSUywgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgICAgICAgIHJldHJ5Q29uZmlnOiB7IG5vUmVzcG9uc2VSZXRyaWVzIH0sXG4gICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICAgICAgICB0aW1lb3V0OiByZXF1ZXN0VGltZW91dCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogbm9kZS5qcyBjb252ZXJ0cyBhbGwgaW5jb21pbmcgaGVhZGVycyB0byBsb3dlciBjYXNlLlxuICAgICAgICBpZiAocmVzLmhlYWRlcnNbZXhwb3J0cy5IRUFERVJfTkFNRS50b0xvd2VyQ2FzZSgpXSAhPT0gZXhwb3J0cy5IRUFERVJfVkFMVUUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZSBmcm9tIG1ldGFkYXRhIHNlcnZpY2U6IGluY29ycmVjdCAke2V4cG9ydHMuSEVBREVSX05BTUV9IGhlYWRlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcmVzLmRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2aWNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25CaWdpbnQucGFyc2UocmVzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgLyogaWdub3JlICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgVW5zdWNjZXNzZnVsIHJlc3BvbnNlIHN0YXR1cyBjb2RlLiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBmYXN0RmFpbE1ldGFkYXRhUmVxdWVzdChvcHRpb25zKSB7XG4gICAgY29uc3Qgc2Vjb25kYXJ5T3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdXJsOiBvcHRpb25zLnVybC5yZXBsYWNlKGdldEJhc2VVcmwoKSwgZ2V0QmFzZVVybChleHBvcnRzLlNFQ09OREFSWV9IT1NUX0FERFJFU1MpKSxcbiAgICB9O1xuICAgIC8vIFdlIHJhY2UgYSBjb25uZWN0aW9uIGJldHdlZW4gRE5TL0lQIHRvIG1ldGFkYXRhIHNlcnZlci4gVGhlcmUgYXJlIGEgY291cGxlXG4gICAgLy8gcmVhc29ucyBmb3IgdGhpczpcbiAgICAvL1xuICAgIC8vIDEuIHRoZSBETlMgaXMgc2xvdyBpbiBzb21lIEdDUCBlbnZpcm9ubWVudHM7IGJ5IGNoZWNraW5nIGJvdGgsIHdlIG1pZ2h0XG4gICAgLy8gICAgZGV0ZWN0IHRoZSBydW50aW1lIGVudmlyb25tZW50IHNpZ25maWNhbnRseSBmYXN0ZXIuXG4gICAgLy8gMi4gd2UgY2FuJ3QganVzdCBjaGVjayB0aGUgSVAsIHdoaWNoIGlzIHRhcnBpdHRlZCBhbmQgc2xvdyB0byByZXNwb25kXG4gICAgLy8gICAgb24gYSB1c2VyJ3MgbG9jYWwgbWFjaGluZS5cbiAgICAvL1xuICAgIC8vIEFkZGl0aW9uYWwgbG9naWMgaGFzIGJlZW4gYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgY3JlYXRlIGFuXG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbiBpbiBzY2VuYXJpb3Mgd2hlcmUgYSBmYWlsdXJlIGhhcHBlbnMgc29tZXRpbWVcbiAgICAvLyBhZnRlciBhIHN1Y2Nlc3MuXG4gICAgLy9cbiAgICAvLyBOb3RlLCBob3dldmVyLCBpZiBhIGZhaWx1cmUgaGFwcGVucyBwcmlvciB0byBhIHN1Y2Nlc3MsIGEgcmVqZWN0aW9uIHNob3VsZFxuICAgIC8vIG9jY3VyLCB0aGlzIGlzIGZvciBmb2xrcyBydW5uaW5nIGxvY2FsbHkuXG4gICAgLy9cbiAgICBsZXQgcmVzcG9uZGVkID0gZmFsc2U7XG4gICAgY29uc3QgcjEgPSAoMCwgZ2F4aW9zXzEucmVxdWVzdCkob3B0aW9ucylcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHIyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHIyID0gKDAsIGdheGlvc18xLnJlcXVlc3QpKHNlY29uZGFyeU9wdGlvbnMpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChyZXNwb25kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtyMSwgcjJdKTtcbn1cbi8qKlxuICogT2J0YWluIG1ldGFkYXRhIGZvciB0aGUgY3VycmVudCBHQ0UgaW5zdGFuY2VcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGluc3RhbmNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFBY2Nlc3NvcignaW5zdGFuY2UnLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbi8qKlxuICogT2J0YWluIG1ldGFkYXRhIGZvciB0aGUgY3VycmVudCBHQ1AgUHJvamVjdC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHByb2plY3Qob3B0aW9ucykge1xuICAgIHJldHVybiBtZXRhZGF0YUFjY2Vzc29yKCdwcm9qZWN0Jywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnByb2plY3QgPSBwcm9qZWN0O1xuLypcbiAqIEhvdyBtYW55IHRpbWVzIHNob3VsZCB3ZSByZXRyeSBkZXRlY3RpbmcgR0NQIGVudmlyb25tZW50LlxuICovXG5mdW5jdGlvbiBkZXRlY3RHQ1BBdmFpbGFibGVSZXRyaWVzKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ERVRFQ1RfR0NQX1JFVFJJRVNcbiAgICAgICAgPyBOdW1iZXIocHJvY2Vzcy5lbnYuREVURUNUX0dDUF9SRVRSSUVTKVxuICAgICAgICA6IDA7XG59XG5sZXQgY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBtZXRhZGF0YSBzZXJ2ZXIgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNBdmFpbGFibGUoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9jZXNzLmVudi5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OLnRyaW0oKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoISh2YWx1ZSBpbiBleHBvcnRzLk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5rbm93biBcXGBNRVRBREFUQV9TRVJWRVJfREVURUNUSU9OXFxgIGVudiB2YXJpYWJsZS4gR290IFxcYCR7dmFsdWV9XFxgLCBidXQgaXQgc2hvdWxkIGJlIFxcYCR7T2JqZWN0LmtleXMoZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OKS5qb2luKCdgLCBgJyl9XFxgLCBvciB1bnNldGApO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Fzc3VtZS1wcmVzZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2Jpb3Mtb25seSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEdDUFJlc2lkZW5jeSgpO1xuICAgICAgICAgICAgY2FzZSAncGluZy1vbmx5JzpcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlLCB3ZSB3YW50IHRvIHBpbmcgdGhlIHNlcnZlclxuICAgICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIElmIGEgdXNlciBpcyBpbnN0YW50aWF0aW5nIHNldmVyYWwgR0NQIGxpYnJhcmllcyBhdCB0aGUgc2FtZSB0aW1lLFxuICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbXVsdGlwbGUgY2FsbHMgdG8gaXNBdmFpbGFibGUoKSwgdG8gZGV0ZWN0IHRoZVxuICAgICAgICAvLyBydW50aW1lIGVudmlyb25tZW50LiBXZSB1c2UgdGhlIHNhbWUgcHJvbWlzZSBmb3IgZWFjaCBvZiB0aGVzZSBjYWxsc1xuICAgICAgICAvLyB0byByZWR1Y2UgdGhlIG5ldHdvcmsgbG9hZC5cbiAgICAgICAgaWYgKGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZSA9IG1ldGFkYXRhQWNjZXNzb3IoJ2luc3RhbmNlJywgdW5kZWZpbmVkLCBkZXRlY3RHQ1BBdmFpbGFibGVSZXRyaWVzKCksIFxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlZmF1bHQgSE9TVF9BRERSRVNTIGhhcyBiZWVuIG92ZXJyaWRkZW4sIHdlIHNob3VsZCBub3RcbiAgICAgICAgICAgIC8vIG1ha2UgYW4gZWZmb3J0IHRvIHRyeSBTRUNPTkRBUllfSE9TVF9BRERSRVNTIChhcyB3ZSBhcmUgbGlrZWx5IGluXG4gICAgICAgICAgICAvLyBhIG5vbi1HQ1AgZW52aXJvbm1lbnQpOlxuICAgICAgICAgICAgIShwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSVAgfHwgcHJvY2Vzcy5lbnYuR0NFX01FVEFEQVRBX0hPU1QpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHX0FVVEgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIudHlwZSA9PT0gJ3JlcXVlc3QtdGltZW91dCcpIHtcbiAgICAgICAgICAgIC8vIElmIHJ1bm5pbmcgaW4gYSBHQ1AgZW52aXJvbm1lbnQsIG1ldGFkYXRhIGVuZHBvaW50IHNob3VsZCByZXR1cm5cbiAgICAgICAgICAgIC8vIHdpdGhpbiBtcy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkgJiZcbiAgICAgICAgICAgICAgICAvLyBBIHdhcm5pbmcgaXMgZW1pdHRlZCBpZiB3ZSBzZWUgYW4gdW5leHBlY3RlZCBlcnIuY29kZSwgb3IgZXJyLmNvZGVcbiAgICAgICAgICAgICAgICAvLyBpcyBub3QgcG9wdWxhdGVkOlxuICAgICAgICAgICAgICAgICghZXJyLmNvZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgIVtcbiAgICAgICAgICAgICAgICAgICAgICAgICdFSE9TVERPV04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VIT1NUVU5SRUFDSCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5FVFVOUkVBQ0gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VOT0VOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQ09OTlJFRlVTRUQnLFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKGVyci5jb2RlKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9ICdVTktOT1dOJztcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBlcnIuY29kZTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGByZWNlaXZlZCB1bmV4cGVjdGVkIGVycm9yID0gJHtlcnIubWVzc2FnZX0gY29kZSA9ICR7Y29kZX1gLCAnTWV0YWRhdGFMb29rdXBXYXJuaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWlsdXJlIHRvIHJlc29sdmUgdGhlIG1ldGFkYXRhIHNlcnZpY2UgbWVhbnMgdGhhdCBpdCBpcyBub3QgYXZhaWxhYmxlLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5pc0F2YWlsYWJsZSA9IGlzQXZhaWxhYmxlO1xuLyoqXG4gKiByZXNldCB0aGUgbWVtb2l6ZWQgaXNBdmFpbGFibGUoKSBsb29rdXAuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0SXNBdmFpbGFibGVDYWNoZSgpIHtcbiAgICBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlID0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5yZXNldElzQXZhaWxhYmxlQ2FjaGUgPSByZXNldElzQXZhaWxhYmxlQ2FjaGU7XG4vKipcbiAqIEEgY2FjaGUgZm9yIHRoZSBkZXRlY3RlZCBHQ1AgUmVzaWRlbmN5LlxuICovXG5leHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID0gbnVsbDtcbi8qKlxuICogRGV0ZWN0cyBHQ1AgUmVzaWRlbmN5LlxuICogQ2FjaGVzIHJlc3VsdHMgdG8gcmVkdWNlIGNvc3RzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuICpcbiAqIEBzZWUgc2V0R0NQUmVzaWRlbmN5IGZvciBzZXR0aW5nXG4gKi9cbmZ1bmN0aW9uIGdldEdDUFJlc2lkZW5jeSgpIHtcbiAgICBpZiAoZXhwb3J0cy5nY3BSZXNpZGVuY3lDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICBzZXRHQ1BSZXNpZGVuY3koKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGU7XG59XG5leHBvcnRzLmdldEdDUFJlc2lkZW5jeSA9IGdldEdDUFJlc2lkZW5jeTtcbi8qKlxuICogU2V0cyB0aGUgZGV0ZWN0ZWQgR0NQIFJlc2lkZW5jeS5cbiAqIFVzZWZ1bCBmb3IgZm9yY2luZyBtZXRhZGF0YSBzZXJ2ZXIgZGV0ZWN0aW9uIGJlaGF2aW9yLlxuICpcbiAqIFNldCBgbnVsbGAgdG8gYXV0b2RldGVjdCB0aGUgZW52aXJvbm1lbnQgKGRlZmF1bHQgYmVoYXZpb3IpLlxuICogQHNlZSBnZXRHQ1BSZXNpZGVuY3kgZm9yIGdldHRpbmdcbiAqL1xuZnVuY3Rpb24gc2V0R0NQUmVzaWRlbmN5KHZhbHVlID0gbnVsbCkge1xuICAgIGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGUgPSB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlIDogKDAsIGdjcF9yZXNpZGVuY3lfMS5kZXRlY3RHQ1BSZXNpZGVuY3kpKCk7XG59XG5leHBvcnRzLnNldEdDUFJlc2lkZW5jeSA9IHNldEdDUFJlc2lkZW5jeTtcbi8qKlxuICogT2J0YWluIHRoZSB0aW1lb3V0IGZvciByZXF1ZXN0cyB0byB0aGUgbWV0YWRhdGEgc2VydmVyLlxuICpcbiAqIEluIGNlcnRhaW4gZW52aXJvbm1lbnRzIGFuZCBjb25kaXRpb25zIHJlcXVlc3RzIGNhbiB0YWtlIGxvbmdlciB0aGFuXG4gKiB0aGUgZGVmYXVsdCB0aW1lb3V0IHRvIGNvbXBsZXRlLiBUaGlzIGZ1bmN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZVxuICogYXBwcm9wcmlhdGUgdGltZW91dCBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gYSByZXF1ZXN0IHRpbWVvdXQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiByZXF1ZXN0VGltZW91dCgpIHtcbiAgICByZXR1cm4gZ2V0R0NQUmVzaWRlbmN5KCkgPyAwIDogMzAwMDtcbn1cbmV4cG9ydHMucmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nY3AtcmVzaWRlbmN5XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../node_modules/gcp-metadata/build/src/index.js\n");

/***/ })

};
;