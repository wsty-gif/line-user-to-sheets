"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/google-auth-library";
exports.ids = ["vendor-chunks/google-auth-library"];
exports.modules = {

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/authclient.js":
/*!************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/authclient.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2012 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AuthClient = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(api)/../node_modules/google-auth-library/build/src/transporters.js\");\nclass AuthClient extends events_1.EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.transporter = new transporters_1.DefaultTransporter();\n        this.credentials = {};\n        this.eagerRefreshThresholdMillis = 5 * 60 * 1000;\n        this.forceRefreshOnFailure = false;\n    }\n    /**\n     * Sets the auth credentials.\n     */\n    setCredentials(credentials) {\n        this.credentials = credentials;\n    }\n    /**\n     * Append additional headers, e.g., x-goog-user-project, shared across the\n     * classes inheriting AuthClient. This method should be used by any method\n     * that overrides getRequestMetadataAsync(), which is a shared helper for\n     * setting request information in both gRPC and HTTP API calls.\n     *\n     * @param headers object to append additional headers to.\n     */\n    addSharedMetadataHeaders(headers) {\n        // quota_project_id, stored in application_default_credentials.json, is set in\n        // the x-goog-user-project header, to indicate an alternate account for\n        // billing and quota:\n        if (!headers['x-goog-user-project'] && // don't override a value the user sets.\n            this.quotaProjectId) {\n            headers['x-goog-user-project'] = this.quotaProjectId;\n        }\n        return headers;\n    }\n}\nexports.AuthClient = AuthClient;\n//# sourceMappingURL=authclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYXV0aGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyx1QkFBdUIsbUJBQU8sQ0FBQyw0RkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hdXRoY2xpZW50LmpzP2VmYTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxMiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXV0aENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHRyYW5zcG9ydGVyc18xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydGVyc1wiKTtcbmNsYXNzIEF1dGhDbGllbnQgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyID0gbmV3IHRyYW5zcG9ydGVyc18xLkRlZmF1bHRUcmFuc3BvcnRlcigpO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge307XG4gICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gNSAqIDYwICogMTAwMDtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYXV0aCBjcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhZGRpdGlvbmFsIGhlYWRlcnMsIGUuZy4sIHgtZ29vZy11c2VyLXByb2plY3QsIHNoYXJlZCBhY3Jvc3MgdGhlXG4gICAgICogY2xhc3NlcyBpbmhlcml0aW5nIEF1dGhDbGllbnQuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGJ5IGFueSBtZXRob2RcbiAgICAgKiB0aGF0IG92ZXJyaWRlcyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYygpLCB3aGljaCBpcyBhIHNoYXJlZCBoZWxwZXIgZm9yXG4gICAgICogc2V0dGluZyByZXF1ZXN0IGluZm9ybWF0aW9uIGluIGJvdGggZ1JQQyBhbmQgSFRUUCBBUEkgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGVhZGVycyBvYmplY3QgdG8gYXBwZW5kIGFkZGl0aW9uYWwgaGVhZGVycyB0by5cbiAgICAgKi9cbiAgICBhZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICAvLyBxdW90YV9wcm9qZWN0X2lkLCBzdG9yZWQgaW4gYXBwbGljYXRpb25fZGVmYXVsdF9jcmVkZW50aWFscy5qc29uLCBpcyBzZXQgaW5cbiAgICAgICAgLy8gdGhlIHgtZ29vZy11c2VyLXByb2plY3QgaGVhZGVyLCB0byBpbmRpY2F0ZSBhbiBhbHRlcm5hdGUgYWNjb3VudCBmb3JcbiAgICAgICAgLy8gYmlsbGluZyBhbmQgcXVvdGE6XG4gICAgICAgIGlmICghaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddICYmIC8vIGRvbid0IG92ZXJyaWRlIGEgdmFsdWUgdGhlIHVzZXIgc2V0cy5cbiAgICAgICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9IHRoaXMucXVvdGFQcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5BdXRoQ2xpZW50ID0gQXV0aENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/authclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/awsclient.js":
/*!***********************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/awsclient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwsClient = void 0;\nconst awsrequestsigner_1 = __webpack_require__(/*! ./awsrequestsigner */ \"(api)/../node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */\nclass AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates an AwsClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid AWS credential.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super(options, additionalOptions);\n        this.environmentId = options.credential_source.environment_id;\n        // This is only required if the AWS region is not available in the\n        // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n        this.regionUrl = options.credential_source.region_url;\n        // This is only required if AWS security credentials are not available in\n        // environment variables.\n        this.securityCredentialsUrl = options.credential_source.url;\n        this.regionalCredVerificationUrl =\n            options.credential_source.regional_cred_verification_url;\n        this.imdsV2SessionTokenUrl =\n            options.credential_source.imdsv2_session_token_url;\n        this.awsRequestSigner = null;\n        this.region = '';\n        // Data validators.\n        this.validateEnvironmentId();\n    }\n    validateEnvironmentId() {\n        var _a;\n        const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n        if (!match || !this.regionalCredVerificationUrl) {\n            throw new Error('No valid AWS \"credential_source\" provided');\n        }\n        else if (parseInt(match[2], 10) !== 1) {\n            throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\n        }\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this uses a serialized AWS signed request to the STS GetCallerIdentity\n     * endpoint.\n     * The logic is summarized as:\n     * 1. If imdsv2_session_token_url is provided in the credential source, then\n     *    fetch the aws session token and include it in the headers of the\n     *    metadata requests. This is a requirement for IDMSv2 but optional\n     *    for IDMSv1.\n     * 2. Retrieve AWS region from availability-zone.\n     * 3a. Check AWS credentials in environment variables. If not found, get\n     *     from security-credentials endpoint.\n     * 3b. Get AWS credentials from security-credentials endpoint. In order\n     *     to retrieve this, the AWS role needs to be determined by calling\n     *     security-credentials endpoint without any argument. Then the\n     *     credentials can be retrieved via: security-credentials/role_name\n     * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n     * 5. Inject x-goog-cloud-target-resource into header and serialize the\n     *    signed request. This will be the subject-token to pass to GCP STS.\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        // Initialize AWS request signer if not already initialized.\n        if (!this.awsRequestSigner) {\n            const metadataHeaders = {};\n            // Only retrieve the IMDSv2 session token if both the security credentials and region are\n            // not retrievable through the environment.\n            // The credential config contains all the URLs by default but clients may be running this\n            // where the metadata server is not available and returning the credentials through the environment.\n            // Removing this check may break them.\n            if (this.shouldUseMetadataServer() && this.imdsV2SessionTokenUrl) {\n                metadataHeaders['x-aws-ec2-metadata-token'] =\n                    await this.getImdsV2SessionToken();\n            }\n            this.region = await this.getAwsRegion(metadataHeaders);\n            this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {\n                // Check environment variables for permanent credentials first.\n                // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n                if (this.securityCredentialsFromEnv) {\n                    return this.securityCredentialsFromEnv;\n                }\n                // Since the role on a VM can change, we don't need to cache it.\n                const roleName = await this.getAwsRoleName(metadataHeaders);\n                // Temporary credentials typically last for several hours.\n                // Expiration is returned in response.\n                // Consider future optimization of this logic to cache AWS tokens\n                // until their natural expiration.\n                const awsCreds = await this.getAwsSecurityCredentials(roleName, metadataHeaders);\n                return {\n                    accessKeyId: awsCreds.AccessKeyId,\n                    secretAccessKey: awsCreds.SecretAccessKey,\n                    token: awsCreds.Token,\n                };\n            }, this.region);\n        }\n        // Generate signed request to AWS STS GetCallerIdentity API.\n        // Use the required regional endpoint. Otherwise, the request will fail.\n        const options = await this.awsRequestSigner.getRequestOptions({\n            url: this.regionalCredVerificationUrl.replace('{region}', this.region),\n            method: 'POST',\n        });\n        // The GCP STS endpoint expects the headers to be formatted as:\n        // [\n        //   {key: 'x-amz-date', value: '...'},\n        //   {key: 'Authorization', value: '...'},\n        //   ...\n        // ]\n        // And then serialized as:\n        // encodeURIComponent(JSON.stringify({\n        //   url: '...',\n        //   method: 'POST',\n        //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n        // }))\n        const reformattedHeader = [];\n        const extendedHeaders = Object.assign({\n            // The full, canonical resource name of the workload identity pool\n            // provider, with or without the HTTPS prefix.\n            // Including this header as part of the signature is recommended to\n            // ensure data integrity.\n            'x-goog-cloud-target-resource': this.audience,\n        }, options.headers);\n        // Reformat header to GCP STS expected format.\n        for (const key in extendedHeaders) {\n            reformattedHeader.push({\n                key,\n                value: extendedHeaders[key],\n            });\n        }\n        // Serialize the reformatted signed request.\n        return encodeURIComponent(JSON.stringify({\n            url: options.url,\n            method: options.method,\n            headers: reformattedHeader,\n        }));\n    }\n    /**\n     * @return A promise that resolves with the IMDSv2 Session Token.\n     */\n    async getImdsV2SessionToken() {\n        const opts = {\n            url: this.imdsV2SessionTokenUrl,\n            method: 'PUT',\n            responseType: 'text',\n            headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '300' },\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the current AWS region.\n     */\n    async getAwsRegion(headers) {\n        // Priority order for region determination:\n        // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n        if (this.regionFromEnv) {\n            return this.regionFromEnv;\n        }\n        if (!this.regionUrl) {\n            throw new Error('Unable to determine AWS region due to missing ' +\n                '\"options.credential_source.region_url\"');\n        }\n        const opts = {\n            url: this.regionUrl,\n            method: 'GET',\n            responseType: 'text',\n            headers: headers,\n        };\n        const response = await this.transporter.request(opts);\n        // Remove last character. For example, if us-east-2b is returned,\n        // the region would be us-east-2.\n        return response.data.substr(0, response.data.length - 1);\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the assigned role to the current\n     *   AWS VM. This is needed for calling the security-credentials endpoint.\n     */\n    async getAwsRoleName(headers) {\n        if (!this.securityCredentialsUrl) {\n            throw new Error('Unable to determine AWS role name due to missing ' +\n                '\"options.credential_source.url\"');\n        }\n        const opts = {\n            url: this.securityCredentialsUrl,\n            method: 'GET',\n            responseType: 'text',\n            headers: headers,\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * Retrieves the temporary AWS credentials by calling the security-credentials\n     * endpoint as specified in the `credential_source` object.\n     * @param roleName The role attached to the current VM.\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the temporary AWS credentials\n     *   needed for creating the GetCallerIdentity signed request.\n     */\n    async getAwsSecurityCredentials(roleName, headers) {\n        const response = await this.transporter.request({\n            url: `${this.securityCredentialsUrl}/${roleName}`,\n            responseType: 'json',\n            headers: headers,\n        });\n        return response.data;\n    }\n    shouldUseMetadataServer() {\n        // The metadata server must be used when either the AWS region or AWS security\n        // credentials cannot be retrieved through their defined environment variables.\n        return !this.regionFromEnv || !this.securityCredentialsFromEnv;\n    }\n    get regionFromEnv() {\n        // The AWS region can be provided through AWS_REGION or AWS_DEFAULT_REGION.\n        // Only one is required.\n        return (process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION'] || null);\n    }\n    get securityCredentialsFromEnv() {\n        // Both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required.\n        if (process.env['AWS_ACCESS_KEY_ID'] &&\n            process.env['AWS_SECRET_ACCESS_KEY']) {\n            return {\n                accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n                secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n                token: process.env['AWS_SESSION_TOKEN'],\n            };\n        }\n        return null;\n    }\n}\nexports.AwsClient = AwsClient;\nAwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = '169.254.169.254';\nAwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = 'fd00:ec2::254';\n//# sourceMappingURL=awsclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYXdzY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLDJCQUEyQixtQkFBTyxDQUFDLHdHQUFvQjtBQUN2RCw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE9BQU87QUFDbkU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCLEdBQUcsU0FBUztBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYXdzY2xpZW50LmpzPzU4YmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdzQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgYXdzcmVxdWVzdHNpZ25lcl8xID0gcmVxdWlyZShcIi4vYXdzcmVxdWVzdHNpZ25lclwiKTtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuLyoqXG4gKiBBV1MgZXh0ZXJuYWwgYWNjb3VudCBjbGllbnQuIFRoaXMgaXMgdXNlZCBmb3IgQVdTIHdvcmtsb2Fkcywgd2hlcmVcbiAqIEFXUyBTVFMgR2V0Q2FsbGVySWRlbnRpdHkgc2VyaWFsaXplZCBzaWduZWQgcmVxdWVzdHMgYXJlIGV4Y2hhbmdlZCBmb3JcbiAqIEdDUCBhY2Nlc3MgdG9rZW4uXG4gKi9cbmNsYXNzIEF3c0NsaWVudCBleHRlbmRzIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBBd3NDbGllbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIEpTT05cbiAgICAgKiBvYmplY3QgbG9hZGVkIGZyb20gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFscyBmaWxlLlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgY3JlZGVudGlhbCBpcyBub3QgYSB2YWxpZCBBV1MgY3JlZGVudGlhbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkXG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVudmlyb25tZW50SWQgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmVudmlyb25tZW50X2lkO1xuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgcmVxdWlyZWQgaWYgdGhlIEFXUyByZWdpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgICAgLy8gQVdTX1JFR0lPTiBvciBBV1NfREVGQVVMVF9SRUdJT04gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICB0aGlzLnJlZ2lvblVybCA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UucmVnaW9uX3VybDtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHJlcXVpcmVkIGlmIEFXUyBzZWN1cml0eSBjcmVkZW50aWFscyBhcmUgbm90IGF2YWlsYWJsZSBpblxuICAgICAgICAvLyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgIHRoaXMuc2VjdXJpdHlDcmVkZW50aWFsc1VybCA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UudXJsO1xuICAgICAgICB0aGlzLnJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybCA9XG4gICAgICAgICAgICBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnJlZ2lvbmFsX2NyZWRfdmVyaWZpY2F0aW9uX3VybDtcbiAgICAgICAgdGhpcy5pbWRzVjJTZXNzaW9uVG9rZW5VcmwgPVxuICAgICAgICAgICAgb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5pbWRzdjJfc2Vzc2lvbl90b2tlbl91cmw7XG4gICAgICAgIHRoaXMuYXdzUmVxdWVzdFNpZ25lciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVnaW9uID0gJyc7XG4gICAgICAgIC8vIERhdGEgdmFsaWRhdG9ycy5cbiAgICAgICAgdGhpcy52YWxpZGF0ZUVudmlyb25tZW50SWQoKTtcbiAgICB9XG4gICAgdmFsaWRhdGVFbnZpcm9ubWVudElkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gKF9hID0gdGhpcy5lbnZpcm9ubWVudElkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF0Y2goL14oYXdzKShcXGQrKSQvKTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCAhdGhpcy5yZWdpb25hbENyZWRWZXJpZmljYXRpb25VcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgQVdTIFwiY3JlZGVudGlhbF9zb3VyY2VcIiBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnNlSW50KG1hdGNoWzJdLCAxMCkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXdzIHZlcnNpb24gXCIke21hdGNoWzJdfVwiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgYnVpbGQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYW4gZXh0ZXJuYWwgc3ViamVjdCB0b2tlbiBpcyBuZWVkZWQgdG8gYmUgZXhjaGFuZ2VkIGZvciBhXG4gICAgICogR0NQIGFjY2VzcyB0b2tlbiB2aWEgR0NQIFNUUyBlbmRwb2ludC5cbiAgICAgKiBUaGlzIHVzZXMgdGhlIGBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlYCBvYmplY3QgdG8gZmlndXJlIG91dCBob3dcbiAgICAgKiB0byByZXRyaWV2ZSB0aGUgdG9rZW4gdXNpbmcgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEluIHRoaXMgY2FzZSxcbiAgICAgKiB0aGlzIHVzZXMgYSBzZXJpYWxpemVkIEFXUyBzaWduZWQgcmVxdWVzdCB0byB0aGUgU1RTIEdldENhbGxlcklkZW50aXR5XG4gICAgICogZW5kcG9pbnQuXG4gICAgICogVGhlIGxvZ2ljIGlzIHN1bW1hcml6ZWQgYXM6XG4gICAgICogMS4gSWYgaW1kc3YyX3Nlc3Npb25fdG9rZW5fdXJsIGlzIHByb3ZpZGVkIGluIHRoZSBjcmVkZW50aWFsIHNvdXJjZSwgdGhlblxuICAgICAqICAgIGZldGNoIHRoZSBhd3Mgc2Vzc2lvbiB0b2tlbiBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgaGVhZGVycyBvZiB0aGVcbiAgICAgKiAgICBtZXRhZGF0YSByZXF1ZXN0cy4gVGhpcyBpcyBhIHJlcXVpcmVtZW50IGZvciBJRE1TdjIgYnV0IG9wdGlvbmFsXG4gICAgICogICAgZm9yIElETVN2MS5cbiAgICAgKiAyLiBSZXRyaWV2ZSBBV1MgcmVnaW9uIGZyb20gYXZhaWxhYmlsaXR5LXpvbmUuXG4gICAgICogM2EuIENoZWNrIEFXUyBjcmVkZW50aWFscyBpbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuIElmIG5vdCBmb3VuZCwgZ2V0XG4gICAgICogICAgIGZyb20gc2VjdXJpdHktY3JlZGVudGlhbHMgZW5kcG9pbnQuXG4gICAgICogM2IuIEdldCBBV1MgY3JlZGVudGlhbHMgZnJvbSBzZWN1cml0eS1jcmVkZW50aWFscyBlbmRwb2ludC4gSW4gb3JkZXJcbiAgICAgKiAgICAgdG8gcmV0cmlldmUgdGhpcywgdGhlIEFXUyByb2xlIG5lZWRzIHRvIGJlIGRldGVybWluZWQgYnkgY2FsbGluZ1xuICAgICAqICAgICBzZWN1cml0eS1jcmVkZW50aWFscyBlbmRwb2ludCB3aXRob3V0IGFueSBhcmd1bWVudC4gVGhlbiB0aGVcbiAgICAgKiAgICAgY3JlZGVudGlhbHMgY2FuIGJlIHJldHJpZXZlZCB2aWE6IHNlY3VyaXR5LWNyZWRlbnRpYWxzL3JvbGVfbmFtZVxuICAgICAqIDQuIEdlbmVyYXRlIHRoZSBzaWduZWQgcmVxdWVzdCB0byBBV1MgU1RTIEdldENhbGxlcklkZW50aXR5IGFjdGlvbi5cbiAgICAgKiA1LiBJbmplY3QgeC1nb29nLWNsb3VkLXRhcmdldC1yZXNvdXJjZSBpbnRvIGhlYWRlciBhbmQgc2VyaWFsaXplIHRoZVxuICAgICAqICAgIHNpZ25lZCByZXF1ZXN0LiBUaGlzIHdpbGwgYmUgdGhlIHN1YmplY3QtdG9rZW4gdG8gcGFzcyB0byBHQ1AgU1RTLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZVN1YmplY3RUb2tlbigpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBBV1MgcmVxdWVzdCBzaWduZXIgaWYgbm90IGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICAgIGlmICghdGhpcy5hd3NSZXF1ZXN0U2lnbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YUhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIC8vIE9ubHkgcmV0cmlldmUgdGhlIElNRFN2MiBzZXNzaW9uIHRva2VuIGlmIGJvdGggdGhlIHNlY3VyaXR5IGNyZWRlbnRpYWxzIGFuZCByZWdpb24gYXJlXG4gICAgICAgICAgICAvLyBub3QgcmV0cmlldmFibGUgdGhyb3VnaCB0aGUgZW52aXJvbm1lbnQuXG4gICAgICAgICAgICAvLyBUaGUgY3JlZGVudGlhbCBjb25maWcgY29udGFpbnMgYWxsIHRoZSBVUkxzIGJ5IGRlZmF1bHQgYnV0IGNsaWVudHMgbWF5IGJlIHJ1bm5pbmcgdGhpc1xuICAgICAgICAgICAgLy8gd2hlcmUgdGhlIG1ldGFkYXRhIHNlcnZlciBpcyBub3QgYXZhaWxhYmxlIGFuZCByZXR1cm5pbmcgdGhlIGNyZWRlbnRpYWxzIHRocm91Z2ggdGhlIGVudmlyb25tZW50LlxuICAgICAgICAgICAgLy8gUmVtb3ZpbmcgdGhpcyBjaGVjayBtYXkgYnJlYWsgdGhlbS5cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFVzZU1ldGFkYXRhU2VydmVyKCkgJiYgdGhpcy5pbWRzVjJTZXNzaW9uVG9rZW5VcmwpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YUhlYWRlcnNbJ3gtYXdzLWVjMi1tZXRhZGF0YS10b2tlbiddID1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRJbWRzVjJTZXNzaW9uVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVnaW9uID0gYXdhaXQgdGhpcy5nZXRBd3NSZWdpb24obWV0YWRhdGFIZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMuYXdzUmVxdWVzdFNpZ25lciA9IG5ldyBhd3NyZXF1ZXN0c2lnbmVyXzEuQXdzUmVxdWVzdFNpZ25lcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZvciBwZXJtYW5lbnQgY3JlZGVudGlhbHMgZmlyc3QuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL2F3cy1zZWMtY3JlZC10eXBlcy5odG1sXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSByb2xlIG9uIGEgVk0gY2FuIGNoYW5nZSwgd2UgZG9uJ3QgbmVlZCB0byBjYWNoZSBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCByb2xlTmFtZSA9IGF3YWl0IHRoaXMuZ2V0QXdzUm9sZU5hbWUobWV0YWRhdGFIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgY3JlZGVudGlhbHMgdHlwaWNhbGx5IGxhc3QgZm9yIHNldmVyYWwgaG91cnMuXG4gICAgICAgICAgICAgICAgLy8gRXhwaXJhdGlvbiBpcyByZXR1cm5lZCBpbiByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBmdXR1cmUgb3B0aW1pemF0aW9uIG9mIHRoaXMgbG9naWMgdG8gY2FjaGUgQVdTIHRva2Vuc1xuICAgICAgICAgICAgICAgIC8vIHVudGlsIHRoZWlyIG5hdHVyYWwgZXhwaXJhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBhd3NDcmVkcyA9IGF3YWl0IHRoaXMuZ2V0QXdzU2VjdXJpdHlDcmVkZW50aWFscyhyb2xlTmFtZSwgbWV0YWRhdGFIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NLZXlJZDogYXdzQ3JlZHMuQWNjZXNzS2V5SWQsXG4gICAgICAgICAgICAgICAgICAgIHNlY3JldEFjY2Vzc0tleTogYXdzQ3JlZHMuU2VjcmV0QWNjZXNzS2V5LFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogYXdzQ3JlZHMuVG9rZW4sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHRoaXMucmVnaW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmF0ZSBzaWduZWQgcmVxdWVzdCB0byBBV1MgU1RTIEdldENhbGxlcklkZW50aXR5IEFQSS5cbiAgICAgICAgLy8gVXNlIHRoZSByZXF1aXJlZCByZWdpb25hbCBlbmRwb2ludC4gT3RoZXJ3aXNlLCB0aGUgcmVxdWVzdCB3aWxsIGZhaWwuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCB0aGlzLmF3c1JlcXVlc3RTaWduZXIuZ2V0UmVxdWVzdE9wdGlvbnMoe1xuICAgICAgICAgICAgdXJsOiB0aGlzLnJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybC5yZXBsYWNlKCd7cmVnaW9ufScsIHRoaXMucmVnaW9uKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIEdDUCBTVFMgZW5kcG9pbnQgZXhwZWN0cyB0aGUgaGVhZGVycyB0byBiZSBmb3JtYXR0ZWQgYXM6XG4gICAgICAgIC8vIFtcbiAgICAgICAgLy8gICB7a2V5OiAneC1hbXotZGF0ZScsIHZhbHVlOiAnLi4uJ30sXG4gICAgICAgIC8vICAge2tleTogJ0F1dGhvcml6YXRpb24nLCB2YWx1ZTogJy4uLid9LFxuICAgICAgICAvLyAgIC4uLlxuICAgICAgICAvLyBdXG4gICAgICAgIC8vIEFuZCB0aGVuIHNlcmlhbGl6ZWQgYXM6XG4gICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIC8vICAgdXJsOiAnLi4uJyxcbiAgICAgICAgLy8gICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgLy8gICBoZWFkZXJzOiBbe2tleTogJ3gtYW16LWRhdGUnLCB2YWx1ZTogJy4uLid9LCAuLi5dXG4gICAgICAgIC8vIH0pKVxuICAgICAgICBjb25zdCByZWZvcm1hdHRlZEhlYWRlciA9IFtdO1xuICAgICAgICBjb25zdCBleHRlbmRlZEhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIC8vIFRoZSBmdWxsLCBjYW5vbmljYWwgcmVzb3VyY2UgbmFtZSBvZiB0aGUgd29ya2xvYWQgaWRlbnRpdHkgcG9vbFxuICAgICAgICAgICAgLy8gcHJvdmlkZXIsIHdpdGggb3Igd2l0aG91dCB0aGUgSFRUUFMgcHJlZml4LlxuICAgICAgICAgICAgLy8gSW5jbHVkaW5nIHRoaXMgaGVhZGVyIGFzIHBhcnQgb2YgdGhlIHNpZ25hdHVyZSBpcyByZWNvbW1lbmRlZCB0b1xuICAgICAgICAgICAgLy8gZW5zdXJlIGRhdGEgaW50ZWdyaXR5LlxuICAgICAgICAgICAgJ3gtZ29vZy1jbG91ZC10YXJnZXQtcmVzb3VyY2UnOiB0aGlzLmF1ZGllbmNlLFxuICAgICAgICB9LCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAvLyBSZWZvcm1hdCBoZWFkZXIgdG8gR0NQIFNUUyBleHBlY3RlZCBmb3JtYXQuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGV4dGVuZGVkSGVhZGVycykge1xuICAgICAgICAgICAgcmVmb3JtYXR0ZWRIZWFkZXIucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRlbmRlZEhlYWRlcnNba2V5XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgcmVmb3JtYXR0ZWQgc2lnbmVkIHJlcXVlc3QuXG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiByZWZvcm1hdHRlZEhlYWRlcixcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIElNRFN2MiBTZXNzaW9uIFRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEltZHNWMlNlc3Npb25Ub2tlbigpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy5pbWRzVjJTZXNzaW9uVG9rZW5VcmwsXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICd4LWF3cy1lYzItbWV0YWRhdGEtdG9rZW4tdHRsLXNlY29uZHMnOiAnMzAwJyB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIFRoZSBoZWFkZXJzIHRvIGJlIHVzZWQgaW4gdGhlIG1ldGFkYXRhIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjdXJyZW50IEFXUyByZWdpb24uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXdzUmVnaW9uKGhlYWRlcnMpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgb3JkZXIgZm9yIHJlZ2lvbiBkZXRlcm1pbmF0aW9uOlxuICAgICAgICAvLyBBV1NfUkVHSU9OID4gQVdTX0RFRkFVTFRfUkVHSU9OID4gbWV0YWRhdGEgc2VydmVyLlxuICAgICAgICBpZiAodGhpcy5yZWdpb25Gcm9tRW52KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25Gcm9tRW52O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZWdpb25VcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRldGVybWluZSBBV1MgcmVnaW9uIGR1ZSB0byBtaXNzaW5nICcgK1xuICAgICAgICAgICAgICAgICdcIm9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UucmVnaW9uX3VybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy5yZWdpb25VcmwsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgLy8gUmVtb3ZlIGxhc3QgY2hhcmFjdGVyLiBGb3IgZXhhbXBsZSwgaWYgdXMtZWFzdC0yYiBpcyByZXR1cm5lZCxcbiAgICAgICAgLy8gdGhlIHJlZ2lvbiB3b3VsZCBiZSB1cy1lYXN0LTIuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnN1YnN0cigwLCByZXNwb25zZS5kYXRhLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaGVhZGVycyBUaGUgaGVhZGVycyB0byBiZSB1c2VkIGluIHRoZSBtZXRhZGF0YSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYXNzaWduZWQgcm9sZSB0byB0aGUgY3VycmVudFxuICAgICAqICAgQVdTIFZNLiBUaGlzIGlzIG5lZWRlZCBmb3IgY2FsbGluZyB0aGUgc2VjdXJpdHktY3JlZGVudGlhbHMgZW5kcG9pbnQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXdzUm9sZU5hbWUoaGVhZGVycykge1xuICAgICAgICBpZiAoIXRoaXMuc2VjdXJpdHlDcmVkZW50aWFsc1VybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGV0ZXJtaW5lIEFXUyByb2xlIG5hbWUgZHVlIHRvIG1pc3NpbmcgJyArXG4gICAgICAgICAgICAgICAgJ1wib3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS51cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuc2VjdXJpdHlDcmVkZW50aWFsc1VybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB0ZW1wb3JhcnkgQVdTIGNyZWRlbnRpYWxzIGJ5IGNhbGxpbmcgdGhlIHNlY3VyaXR5LWNyZWRlbnRpYWxzXG4gICAgICogZW5kcG9pbnQgYXMgc3BlY2lmaWVkIGluIHRoZSBgY3JlZGVudGlhbF9zb3VyY2VgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcm9sZU5hbWUgVGhlIHJvbGUgYXR0YWNoZWQgdG8gdGhlIGN1cnJlbnQgVk0uXG4gICAgICogQHBhcmFtIGhlYWRlcnMgVGhlIGhlYWRlcnMgdG8gYmUgdXNlZCBpbiB0aGUgbWV0YWRhdGEgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHRlbXBvcmFyeSBBV1MgY3JlZGVudGlhbHNcbiAgICAgKiAgIG5lZWRlZCBmb3IgY3JlYXRpbmcgdGhlIEdldENhbGxlcklkZW50aXR5IHNpZ25lZCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF3c1NlY3VyaXR5Q3JlZGVudGlhbHMocm9sZU5hbWUsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiBgJHt0aGlzLnNlY3VyaXR5Q3JlZGVudGlhbHNVcmx9LyR7cm9sZU5hbWV9YCxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICBzaG91bGRVc2VNZXRhZGF0YVNlcnZlcigpIHtcbiAgICAgICAgLy8gVGhlIG1ldGFkYXRhIHNlcnZlciBtdXN0IGJlIHVzZWQgd2hlbiBlaXRoZXIgdGhlIEFXUyByZWdpb24gb3IgQVdTIHNlY3VyaXR5XG4gICAgICAgIC8vIGNyZWRlbnRpYWxzIGNhbm5vdCBiZSByZXRyaWV2ZWQgdGhyb3VnaCB0aGVpciBkZWZpbmVkIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgICAgcmV0dXJuICF0aGlzLnJlZ2lvbkZyb21FbnYgfHwgIXRoaXMuc2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnY7XG4gICAgfVxuICAgIGdldCByZWdpb25Gcm9tRW52KCkge1xuICAgICAgICAvLyBUaGUgQVdTIHJlZ2lvbiBjYW4gYmUgcHJvdmlkZWQgdGhyb3VnaCBBV1NfUkVHSU9OIG9yIEFXU19ERUZBVUxUX1JFR0lPTi5cbiAgICAgICAgLy8gT25seSBvbmUgaXMgcmVxdWlyZWQuXG4gICAgICAgIHJldHVybiAocHJvY2Vzcy5lbnZbJ0FXU19SRUdJT04nXSB8fCBwcm9jZXNzLmVudlsnQVdTX0RFRkFVTFRfUkVHSU9OJ10gfHwgbnVsbCk7XG4gICAgfVxuICAgIGdldCBzZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudigpIHtcbiAgICAgICAgLy8gQm90aCBBV1NfQUNDRVNTX0tFWV9JRCBhbmQgQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZIGFyZSByZXF1aXJlZC5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52WydBV1NfQUNDRVNTX0tFWV9JRCddICYmXG4gICAgICAgICAgICBwcm9jZXNzLmVudlsnQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6IHByb2Nlc3MuZW52WydBV1NfQUNDRVNTX0tFWV9JRCddLFxuICAgICAgICAgICAgICAgIHNlY3JldEFjY2Vzc0tleTogcHJvY2Vzcy5lbnZbJ0FXU19TRUNSRVRfQUNDRVNTX0tFWSddLFxuICAgICAgICAgICAgICAgIHRva2VuOiBwcm9jZXNzLmVudlsnQVdTX1NFU1NJT05fVE9LRU4nXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5Bd3NDbGllbnQgPSBBd3NDbGllbnQ7XG5Bd3NDbGllbnQuQVdTX0VDMl9NRVRBREFUQV9JUFY0X0FERFJFU1MgPSAnMTY5LjI1NC4xNjkuMjU0JztcbkF3c0NsaWVudC5BV1NfRUMyX01FVEFEQVRBX0lQVjZfQUREUkVTUyA9ICdmZDAwOmVjMjo6MjU0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF3c2NsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/awsclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/awsrequestsigner.js":
/*!******************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/awsrequestsigner.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwsRequestSigner = void 0;\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(api)/../node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** AWS Signature Version 4 signing algorithm identifier.  */\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\n/**\n * The termination string for the AWS credential scope value as defined in\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n */\nconst AWS_REQUEST_TYPE = 'aws4_request';\n/**\n * Implements an AWS API request signer based on the AWS Signature Version 4\n * signing process.\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\nclass AwsRequestSigner {\n    /**\n     * Instantiates an AWS API request signer used to send authenticated signed\n     * requests to AWS APIs based on the AWS Signature Version 4 signing process.\n     * This also provides a mechanism to generate the signed request without\n     * sending it.\n     * @param getCredentials A mechanism to retrieve AWS security credentials\n     *   when needed.\n     * @param region The AWS region to use.\n     */\n    constructor(getCredentials, region) {\n        this.getCredentials = getCredentials;\n        this.region = region;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Generates the signed request for the provided HTTP request for calling\n     * an AWS API. This follows the steps described at:\n     * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n     * @param amzOptions The AWS request options that need to be signed.\n     * @return A promise that resolves with the GaxiosOptions containing the\n     *   signed HTTP request parameters.\n     */\n    async getRequestOptions(amzOptions) {\n        if (!amzOptions.url) {\n            throw new Error('\"url\" is required in \"amzOptions\"');\n        }\n        // Stringify JSON requests. This will be set in the request body of the\n        // generated signed request.\n        const requestPayloadData = typeof amzOptions.data === 'object'\n            ? JSON.stringify(amzOptions.data)\n            : amzOptions.data;\n        const url = amzOptions.url;\n        const method = amzOptions.method || 'GET';\n        const requestPayload = amzOptions.body || requestPayloadData;\n        const additionalAmzHeaders = amzOptions.headers;\n        const awsSecurityCredentials = await this.getCredentials();\n        const uri = new URL(url);\n        const headerMap = await generateAuthenticationHeaderMap({\n            crypto: this.crypto,\n            host: uri.host,\n            canonicalUri: uri.pathname,\n            canonicalQuerystring: uri.search.substr(1),\n            method,\n            region: this.region,\n            securityCredentials: awsSecurityCredentials,\n            requestPayload,\n            additionalAmzHeaders,\n        });\n        // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n        const headers = Object.assign(\n        // Add x-amz-date if available.\n        headerMap.amzDate ? { 'x-amz-date': headerMap.amzDate } : {}, {\n            Authorization: headerMap.authorizationHeader,\n            host: uri.host,\n        }, additionalAmzHeaders || {});\n        if (awsSecurityCredentials.token) {\n            Object.assign(headers, {\n                'x-amz-security-token': awsSecurityCredentials.token,\n            });\n        }\n        const awsSignedReq = {\n            url,\n            method: method,\n            headers,\n        };\n        if (typeof requestPayload !== 'undefined') {\n            awsSignedReq.body = requestPayload;\n        }\n        return awsSignedReq;\n    }\n}\nexports.AwsRequestSigner = AwsRequestSigner;\n/**\n * Creates the HMAC-SHA256 hash of the provided message using the\n * provided key.\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The HMAC-SHA256 key to use.\n * @param msg The message to hash.\n * @return The computed hash bytes.\n */\nasync function sign(crypto, key, msg) {\n    return await crypto.signWithHmacSha256(key, msg);\n}\n/**\n * Calculates the signing key used to calculate the signature for\n * AWS Signature Version 4 based on:\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The AWS secret access key.\n * @param dateStamp The '%Y%m%d' date format.\n * @param region The AWS region.\n * @param serviceName The AWS service name, eg. sts.\n * @return The signing key bytes.\n */\nasync function getSigningKey(crypto, key, dateStamp, region, serviceName) {\n    const kDate = await sign(crypto, `AWS4${key}`, dateStamp);\n    const kRegion = await sign(crypto, kDate, region);\n    const kService = await sign(crypto, kRegion, serviceName);\n    const kSigning = await sign(crypto, kService, 'aws4_request');\n    return kSigning;\n}\n/**\n * Generates the authentication header map needed for generating the AWS\n * Signature Version 4 signed request.\n *\n * @param option The options needed to compute the authentication header map.\n * @return The AWS authentication header map which constitutes of the following\n *   components: amz-date, authorization header and canonical query string.\n */\nasync function generateAuthenticationHeaderMap(options) {\n    const additionalAmzHeaders = options.additionalAmzHeaders || {};\n    const requestPayload = options.requestPayload || '';\n    // iam.amazonaws.com host => iam service.\n    // sts.us-east-2.amazonaws.com => sts service.\n    const serviceName = options.host.split('.')[0];\n    const now = new Date();\n    // Format: '%Y%m%dT%H%M%SZ'.\n    const amzDate = now\n        .toISOString()\n        .replace(/[-:]/g, '')\n        .replace(/\\.[0-9]+/, '');\n    // Format: '%Y%m%d'.\n    const dateStamp = now.toISOString().replace(/[-]/g, '').replace(/T.*/, '');\n    // Change all additional headers to be lower case.\n    const reformattedAdditionalAmzHeaders = {};\n    Object.keys(additionalAmzHeaders).forEach(key => {\n        reformattedAdditionalAmzHeaders[key.toLowerCase()] =\n            additionalAmzHeaders[key];\n    });\n    // Add AWS token if available.\n    if (options.securityCredentials.token) {\n        reformattedAdditionalAmzHeaders['x-amz-security-token'] =\n            options.securityCredentials.token;\n    }\n    // Header keys need to be sorted alphabetically.\n    const amzHeaders = Object.assign({\n        host: options.host,\n    }, \n    // Previously the date was not fixed with x-amz- and could be provided manually.\n    // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n    reformattedAdditionalAmzHeaders.date ? {} : { 'x-amz-date': amzDate }, reformattedAdditionalAmzHeaders);\n    let canonicalHeaders = '';\n    const signedHeadersList = Object.keys(amzHeaders).sort();\n    signedHeadersList.forEach(key => {\n        canonicalHeaders += `${key}:${amzHeaders[key]}\\n`;\n    });\n    const signedHeaders = signedHeadersList.join(';');\n    const payloadHash = await options.crypto.sha256DigestHex(requestPayload);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n    const canonicalRequest = `${options.method}\\n` +\n        `${options.canonicalUri}\\n` +\n        `${options.canonicalQuerystring}\\n` +\n        `${canonicalHeaders}\\n` +\n        `${signedHeaders}\\n` +\n        `${payloadHash}`;\n    const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n    const stringToSign = `${AWS_ALGORITHM}\\n` +\n        `${amzDate}\\n` +\n        `${credentialScope}\\n` +\n        (await options.crypto.sha256DigestHex(canonicalRequest));\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n    const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\n    const signature = await sign(options.crypto, signingKey, stringToSign);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/` +\n        `${credentialScope}, SignedHeaders=${signedHeaders}, ` +\n        `Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;\n    return {\n        // Do not return x-amz-date if date is available.\n        amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\n        authorizationHeader,\n        canonicalQuerystring: options.canonicalQuerystring,\n    };\n}\n//# sourceMappingURL=awsrequestsigner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYXdzcmVxdWVzdHNpZ25lci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixpQkFBaUIsbUJBQU8sQ0FBQyw4RkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0MsSUFBSTtBQUNwRTtBQUNBO0FBQ0EsU0FBUyw0QkFBNEI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhDQUE4QyxJQUFJLHVCQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSSxHQUFHLGdCQUFnQjtBQUN0RCxLQUFLO0FBQ0wsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQyxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGNBQWM7QUFDekIsV0FBVyxZQUFZO0FBQ3ZCLCtCQUErQixVQUFVLEdBQUcsZUFBZSxHQUFHLFlBQVksR0FBRyxpQkFBaUI7QUFDOUY7QUFDQSw0QkFBNEIsY0FBYztBQUMxQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlLGFBQWEsd0NBQXdDO0FBQ3ZHLFdBQVcsZ0JBQWdCLGtCQUFrQixjQUFjO0FBQzNELHFCQUFxQiw4Q0FBOEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYXdzcmVxdWVzdHNpZ25lci5qcz9jOGI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF3c1JlcXVlc3RTaWduZXIgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vY3J5cHRvXCIpO1xuLyoqIEFXUyBTaWduYXR1cmUgVmVyc2lvbiA0IHNpZ25pbmcgYWxnb3JpdGhtIGlkZW50aWZpZXIuICAqL1xuY29uc3QgQVdTX0FMR09SSVRITSA9ICdBV1M0LUhNQUMtU0hBMjU2Jztcbi8qKlxuICogVGhlIHRlcm1pbmF0aW9uIHN0cmluZyBmb3IgdGhlIEFXUyBjcmVkZW50aWFsIHNjb3BlIHZhbHVlIGFzIGRlZmluZWQgaW5cbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jcmVhdGUtc3RyaW5nLXRvLXNpZ24uaHRtbFxuICovXG5jb25zdCBBV1NfUkVRVUVTVF9UWVBFID0gJ2F3czRfcmVxdWVzdCc7XG4vKipcbiAqIEltcGxlbWVudHMgYW4gQVdTIEFQSSByZXF1ZXN0IHNpZ25lciBiYXNlZCBvbiB0aGUgQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDRcbiAqIHNpZ25pbmcgcHJvY2Vzcy5cbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWduYXR1cmUtdmVyc2lvbi00Lmh0bWxcbiAqL1xuY2xhc3MgQXdzUmVxdWVzdFNpZ25lciB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIEFXUyBBUEkgcmVxdWVzdCBzaWduZXIgdXNlZCB0byBzZW5kIGF1dGhlbnRpY2F0ZWQgc2lnbmVkXG4gICAgICogcmVxdWVzdHMgdG8gQVdTIEFQSXMgYmFzZWQgb24gdGhlIEFXUyBTaWduYXR1cmUgVmVyc2lvbiA0IHNpZ25pbmcgcHJvY2Vzcy5cbiAgICAgKiBUaGlzIGFsc28gcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gZ2VuZXJhdGUgdGhlIHNpZ25lZCByZXF1ZXN0IHdpdGhvdXRcbiAgICAgKiBzZW5kaW5nIGl0LlxuICAgICAqIEBwYXJhbSBnZXRDcmVkZW50aWFscyBBIG1lY2hhbmlzbSB0byByZXRyaWV2ZSBBV1Mgc2VjdXJpdHkgY3JlZGVudGlhbHNcbiAgICAgKiAgIHdoZW4gbmVlZGVkLlxuICAgICAqIEBwYXJhbSByZWdpb24gVGhlIEFXUyByZWdpb24gdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdldENyZWRlbnRpYWxzLCByZWdpb24pIHtcbiAgICAgICAgdGhpcy5nZXRDcmVkZW50aWFscyA9IGdldENyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgdGhpcy5jcnlwdG8gPSAoMCwgY3J5cHRvXzEuY3JlYXRlQ3J5cHRvKSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHNpZ25lZCByZXF1ZXN0IGZvciB0aGUgcHJvdmlkZWQgSFRUUCByZXF1ZXN0IGZvciBjYWxsaW5nXG4gICAgICogYW4gQVdTIEFQSS4gVGhpcyBmb2xsb3dzIHRoZSBzdGVwcyBkZXNjcmliZWQgYXQ6XG4gICAgICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0X3NpZ25pbmcuaHRtbFxuICAgICAqIEBwYXJhbSBhbXpPcHRpb25zIFRoZSBBV1MgcmVxdWVzdCBvcHRpb25zIHRoYXQgbmVlZCB0byBiZSBzaWduZWQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBHYXhpb3NPcHRpb25zIGNvbnRhaW5pbmcgdGhlXG4gICAgICogICBzaWduZWQgSFRUUCByZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdE9wdGlvbnMoYW16T3B0aW9ucykge1xuICAgICAgICBpZiAoIWFtek9wdGlvbnMudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widXJsXCIgaXMgcmVxdWlyZWQgaW4gXCJhbXpPcHRpb25zXCInKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJpbmdpZnkgSlNPTiByZXF1ZXN0cy4gVGhpcyB3aWxsIGJlIHNldCBpbiB0aGUgcmVxdWVzdCBib2R5IG9mIHRoZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgc2lnbmVkIHJlcXVlc3QuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXlsb2FkRGF0YSA9IHR5cGVvZiBhbXpPcHRpb25zLmRhdGEgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGFtek9wdGlvbnMuZGF0YSlcbiAgICAgICAgICAgIDogYW16T3B0aW9ucy5kYXRhO1xuICAgICAgICBjb25zdCB1cmwgPSBhbXpPcHRpb25zLnVybDtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gYW16T3B0aW9ucy5tZXRob2QgfHwgJ0dFVCc7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXlsb2FkID0gYW16T3B0aW9ucy5ib2R5IHx8IHJlcXVlc3RQYXlsb2FkRGF0YTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbEFtekhlYWRlcnMgPSBhbXpPcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMgPSBhd2FpdCB0aGlzLmdldENyZWRlbnRpYWxzKCk7XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgY29uc3QgaGVhZGVyTWFwID0gYXdhaXQgZ2VuZXJhdGVBdXRoZW50aWNhdGlvbkhlYWRlck1hcCh7XG4gICAgICAgICAgICBjcnlwdG86IHRoaXMuY3J5cHRvLFxuICAgICAgICAgICAgaG9zdDogdXJpLmhvc3QsXG4gICAgICAgICAgICBjYW5vbmljYWxVcmk6IHVyaS5wYXRobmFtZSxcbiAgICAgICAgICAgIGNhbm9uaWNhbFF1ZXJ5c3RyaW5nOiB1cmkuc2VhcmNoLnN1YnN0cigxKSxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlZ2lvbjogdGhpcy5yZWdpb24sXG4gICAgICAgICAgICBzZWN1cml0eUNyZWRlbnRpYWxzOiBhd3NTZWN1cml0eUNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgcmVxdWVzdFBheWxvYWQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsQW16SGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFwcGVuZCBhZGRpdGlvbmFsIG9wdGlvbmFsIGhlYWRlcnMsIGVnLiBYLUFtei1UYXJnZXQsIENvbnRlbnQtVHlwZSwgZXRjLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgLy8gQWRkIHgtYW16LWRhdGUgaWYgYXZhaWxhYmxlLlxuICAgICAgICBoZWFkZXJNYXAuYW16RGF0ZSA/IHsgJ3gtYW16LWRhdGUnOiBoZWFkZXJNYXAuYW16RGF0ZSB9IDoge30sIHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGhlYWRlck1hcC5hdXRob3JpemF0aW9uSGVhZGVyLFxuICAgICAgICAgICAgaG9zdDogdXJpLmhvc3QsXG4gICAgICAgIH0sIGFkZGl0aW9uYWxBbXpIZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgaWYgKGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW4pIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywge1xuICAgICAgICAgICAgICAgICd4LWFtei1zZWN1cml0eS10b2tlbic6IGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhd3NTaWduZWRSZXEgPSB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdFBheWxvYWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhd3NTaWduZWRSZXEuYm9keSA9IHJlcXVlc3RQYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd3NTaWduZWRSZXE7XG4gICAgfVxufVxuZXhwb3J0cy5Bd3NSZXF1ZXN0U2lnbmVyID0gQXdzUmVxdWVzdFNpZ25lcjtcbi8qKlxuICogQ3JlYXRlcyB0aGUgSE1BQy1TSEEyNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWQgbWVzc2FnZSB1c2luZyB0aGVcbiAqIHByb3ZpZGVkIGtleS5cbiAqXG4gKiBAcGFyYW0gY3J5cHRvIFRoZSBjcnlwdG8gaW5zdGFuY2UgdXNlZCB0byBmYWNpbGl0YXRlIGNyeXB0b2dyYXBoaWNcbiAqICAgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSBrZXkgVGhlIEhNQUMtU0hBMjU2IGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcmV0dXJuIFRoZSBjb21wdXRlZCBoYXNoIGJ5dGVzLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduKGNyeXB0bywga2V5LCBtc2cpIHtcbiAgICByZXR1cm4gYXdhaXQgY3J5cHRvLnNpZ25XaXRoSG1hY1NoYTI1NihrZXksIG1zZyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNpZ25pbmcga2V5IHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBzaWduYXR1cmUgZm9yXG4gKiBBV1MgU2lnbmF0dXJlIFZlcnNpb24gNCBiYXNlZCBvbjpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jYWxjdWxhdGUtc2lnbmF0dXJlLmh0bWxcbiAqXG4gKiBAcGFyYW0gY3J5cHRvIFRoZSBjcnlwdG8gaW5zdGFuY2UgdXNlZCB0byBmYWNpbGl0YXRlIGNyeXB0b2dyYXBoaWNcbiAqICAgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSBrZXkgVGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleS5cbiAqIEBwYXJhbSBkYXRlU3RhbXAgVGhlICclWSVtJWQnIGRhdGUgZm9ybWF0LlxuICogQHBhcmFtIHJlZ2lvbiBUaGUgQVdTIHJlZ2lvbi5cbiAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBUaGUgQVdTIHNlcnZpY2UgbmFtZSwgZWcuIHN0cy5cbiAqIEByZXR1cm4gVGhlIHNpZ25pbmcga2V5IGJ5dGVzLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTaWduaW5nS2V5KGNyeXB0bywga2V5LCBkYXRlU3RhbXAsIHJlZ2lvbiwgc2VydmljZU5hbWUpIHtcbiAgICBjb25zdCBrRGF0ZSA9IGF3YWl0IHNpZ24oY3J5cHRvLCBgQVdTNCR7a2V5fWAsIGRhdGVTdGFtcCk7XG4gICAgY29uc3Qga1JlZ2lvbiA9IGF3YWl0IHNpZ24oY3J5cHRvLCBrRGF0ZSwgcmVnaW9uKTtcbiAgICBjb25zdCBrU2VydmljZSA9IGF3YWl0IHNpZ24oY3J5cHRvLCBrUmVnaW9uLCBzZXJ2aWNlTmFtZSk7XG4gICAgY29uc3Qga1NpZ25pbmcgPSBhd2FpdCBzaWduKGNyeXB0bywga1NlcnZpY2UsICdhd3M0X3JlcXVlc3QnKTtcbiAgICByZXR1cm4ga1NpZ25pbmc7XG59XG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgYXV0aGVudGljYXRpb24gaGVhZGVyIG1hcCBuZWVkZWQgZm9yIGdlbmVyYXRpbmcgdGhlIEFXU1xuICogU2lnbmF0dXJlIFZlcnNpb24gNCBzaWduZWQgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uIFRoZSBvcHRpb25zIG5lZWRlZCB0byBjb21wdXRlIHRoZSBhdXRoZW50aWNhdGlvbiBoZWFkZXIgbWFwLlxuICogQHJldHVybiBUaGUgQVdTIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBtYXAgd2hpY2ggY29uc3RpdHV0ZXMgb2YgdGhlIGZvbGxvd2luZ1xuICogICBjb21wb25lbnRzOiBhbXotZGF0ZSwgYXV0aG9yaXphdGlvbiBoZWFkZXIgYW5kIGNhbm9uaWNhbCBxdWVyeSBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQXV0aGVudGljYXRpb25IZWFkZXJNYXAob3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGl0aW9uYWxBbXpIZWFkZXJzID0gb3B0aW9ucy5hZGRpdGlvbmFsQW16SGVhZGVycyB8fCB7fTtcbiAgICBjb25zdCByZXF1ZXN0UGF5bG9hZCA9IG9wdGlvbnMucmVxdWVzdFBheWxvYWQgfHwgJyc7XG4gICAgLy8gaWFtLmFtYXpvbmF3cy5jb20gaG9zdCA9PiBpYW0gc2VydmljZS5cbiAgICAvLyBzdHMudXMtZWFzdC0yLmFtYXpvbmF3cy5jb20gPT4gc3RzIHNlcnZpY2UuXG4gICAgY29uc3Qgc2VydmljZU5hbWUgPSBvcHRpb25zLmhvc3Quc3BsaXQoJy4nKVswXTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIEZvcm1hdDogJyVZJW0lZFQlSCVNJVNaJy5cbiAgICBjb25zdCBhbXpEYXRlID0gbm93XG4gICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgIC5yZXBsYWNlKC9bLTpdL2csICcnKVxuICAgICAgICAucmVwbGFjZSgvXFwuWzAtOV0rLywgJycpO1xuICAgIC8vIEZvcm1hdDogJyVZJW0lZCcuXG4gICAgY29uc3QgZGF0ZVN0YW1wID0gbm93LnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWy1dL2csICcnKS5yZXBsYWNlKC9ULiovLCAnJyk7XG4gICAgLy8gQ2hhbmdlIGFsbCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gYmUgbG93ZXIgY2FzZS5cbiAgICBjb25zdCByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbEFtekhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPVxuICAgICAgICAgICAgYWRkaXRpb25hbEFtekhlYWRlcnNba2V5XTtcbiAgICB9KTtcbiAgICAvLyBBZGQgQVdTIHRva2VuIGlmIGF2YWlsYWJsZS5cbiAgICBpZiAob3B0aW9ucy5zZWN1cml0eUNyZWRlbnRpYWxzLnRva2VuKSB7XG4gICAgICAgIHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPVxuICAgICAgICAgICAgb3B0aW9ucy5zZWN1cml0eUNyZWRlbnRpYWxzLnRva2VuO1xuICAgIH1cbiAgICAvLyBIZWFkZXIga2V5cyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICBjb25zdCBhbXpIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdCxcbiAgICB9LCBcbiAgICAvLyBQcmV2aW91c2x5IHRoZSBkYXRlIHdhcyBub3QgZml4ZWQgd2l0aCB4LWFtei0gYW5kIGNvdWxkIGJlIHByb3ZpZGVkIG1hbnVhbGx5LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ib3RvL2JvdG9jb3JlL2Jsb2IvODc5Zjg0NDBhNGU5YWNlNWQzY2YxNDVjZThiM2Q1ZTVmZmI4OTJlZi90ZXN0cy91bml0L2F1dGgvYXdzNF90ZXN0c3VpdGUvZ2V0LWhlYWRlci12YWx1ZS10cmltLnJlcVxuICAgIHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnMuZGF0ZSA/IHt9IDogeyAneC1hbXotZGF0ZSc6IGFtekRhdGUgfSwgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVycyk7XG4gICAgbGV0IGNhbm9uaWNhbEhlYWRlcnMgPSAnJztcbiAgICBjb25zdCBzaWduZWRIZWFkZXJzTGlzdCA9IE9iamVjdC5rZXlzKGFtekhlYWRlcnMpLnNvcnQoKTtcbiAgICBzaWduZWRIZWFkZXJzTGlzdC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNhbm9uaWNhbEhlYWRlcnMgKz0gYCR7a2V5fToke2FtekhlYWRlcnNba2V5XX1cXG5gO1xuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25lZEhlYWRlcnMgPSBzaWduZWRIZWFkZXJzTGlzdC5qb2luKCc7Jyk7XG4gICAgY29uc3QgcGF5bG9hZEhhc2ggPSBhd2FpdCBvcHRpb25zLmNyeXB0by5zaGEyNTZEaWdlc3RIZXgocmVxdWVzdFBheWxvYWQpO1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jcmVhdGUtY2Fub25pY2FsLXJlcXVlc3QuaHRtbFxuICAgIGNvbnN0IGNhbm9uaWNhbFJlcXVlc3QgPSBgJHtvcHRpb25zLm1ldGhvZH1cXG5gICtcbiAgICAgICAgYCR7b3B0aW9ucy5jYW5vbmljYWxVcml9XFxuYCArXG4gICAgICAgIGAke29wdGlvbnMuY2Fub25pY2FsUXVlcnlzdHJpbmd9XFxuYCArXG4gICAgICAgIGAke2Nhbm9uaWNhbEhlYWRlcnN9XFxuYCArXG4gICAgICAgIGAke3NpZ25lZEhlYWRlcnN9XFxuYCArXG4gICAgICAgIGAke3BheWxvYWRIYXNofWA7XG4gICAgY29uc3QgY3JlZGVudGlhbFNjb3BlID0gYCR7ZGF0ZVN0YW1wfS8ke29wdGlvbnMucmVnaW9ufS8ke3NlcnZpY2VOYW1lfS8ke0FXU19SRVFVRVNUX1RZUEV9YDtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lndjQtY3JlYXRlLXN0cmluZy10by1zaWduLmh0bWxcbiAgICBjb25zdCBzdHJpbmdUb1NpZ24gPSBgJHtBV1NfQUxHT1JJVEhNfVxcbmAgK1xuICAgICAgICBgJHthbXpEYXRlfVxcbmAgK1xuICAgICAgICBgJHtjcmVkZW50aWFsU2NvcGV9XFxuYCArXG4gICAgICAgIChhd2FpdCBvcHRpb25zLmNyeXB0by5zaGEyNTZEaWdlc3RIZXgoY2Fub25pY2FsUmVxdWVzdCkpO1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jYWxjdWxhdGUtc2lnbmF0dXJlLmh0bWxcbiAgICBjb25zdCBzaWduaW5nS2V5ID0gYXdhaXQgZ2V0U2lnbmluZ0tleShvcHRpb25zLmNyeXB0bywgb3B0aW9ucy5zZWN1cml0eUNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgZGF0ZVN0YW1wLCBvcHRpb25zLnJlZ2lvbiwgc2VydmljZU5hbWUpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ24ob3B0aW9ucy5jcnlwdG8sIHNpZ25pbmdLZXksIHN0cmluZ1RvU2lnbik7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWFkZC1zaWduYXR1cmUtdG8tcmVxdWVzdC5odG1sXG4gICAgY29uc3QgYXV0aG9yaXphdGlvbkhlYWRlciA9IGAke0FXU19BTEdPUklUSE19IENyZWRlbnRpYWw9JHtvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMuYWNjZXNzS2V5SWR9L2AgK1xuICAgICAgICBgJHtjcmVkZW50aWFsU2NvcGV9LCBTaWduZWRIZWFkZXJzPSR7c2lnbmVkSGVhZGVyc30sIGAgK1xuICAgICAgICBgU2lnbmF0dXJlPSR7KDAsIGNyeXB0b18xLmZyb21BcnJheUJ1ZmZlclRvSGV4KShzaWduYXR1cmUpfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRG8gbm90IHJldHVybiB4LWFtei1kYXRlIGlmIGRhdGUgaXMgYXZhaWxhYmxlLlxuICAgICAgICBhbXpEYXRlOiByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzLmRhdGUgPyB1bmRlZmluZWQgOiBhbXpEYXRlLFxuICAgICAgICBhdXRob3JpemF0aW9uSGVhZGVyLFxuICAgICAgICBjYW5vbmljYWxRdWVyeXN0cmluZzogb3B0aW9ucy5jYW5vbmljYWxRdWVyeXN0cmluZyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXdzcmVxdWVzdHNpZ25lci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js":
/*!********************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/baseexternalclient.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(api)/../node_modules/google-auth-library/build/src/auth/stscredentials.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** Default impersonated token lifespan in seconds.*/\nconst DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam.googleapis.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        var _a, _b;\n        super();\n        if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` +\n                `received \"${options.type}\"`);\n        }\n        this.clientAuth = options.client_id\n            ? {\n                confidentialClientType: 'basic',\n                clientId: options.client_id,\n                clientSecret: options.client_secret,\n            }\n            : undefined;\n        this.stsCredential = new sts.StsCredentials(options.token_url, this.clientAuth);\n        // Default OAuth scope. This could be overridden via public property.\n        this.scopes = [DEFAULT_OAUTH_SCOPE];\n        this.cachedAccessToken = null;\n        this.audience = options.audience;\n        this.subjectTokenType = options.subject_token_type;\n        this.quotaProjectId = options.quota_project_id;\n        this.workforcePoolUserProject = options.workforce_pool_user_project;\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n        if (this.workforcePoolUserProject &&\n            !this.audience.match(workforceAudiencePattern)) {\n            throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' +\n                'credentials.');\n        }\n        this.serviceAccountImpersonationUrl =\n            options.service_account_impersonation_url;\n        this.serviceAccountImpersonationLifetime =\n            (_b = (_a = options.service_account_impersonation) === null || _a === void 0 ? void 0 : _a.token_lifetime_seconds) !== null && _b !== void 0 ? _b : DEFAULT_TOKEN_LIFESPAN;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.projectId = null;\n        this.projectNumber = this.getProjectNumber(this.audience);\n        this.universeDomain = options.universe_domain;\n    }\n    /** The service account email to be impersonated, if available. */\n    getServiceAccountEmail() {\n        var _a;\n        if (this.serviceAccountImpersonationUrl) {\n            // Parse email from URL. The formal looks as follows:\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n            const result = re.exec(this.serviceAccountImpersonationUrl);\n            return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n        }\n        return null;\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool or current workforce pool if\n     *   determinable. For workforce pool credential, it returns the project ID\n     *   corresponding to the workforcePoolUserProject.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */\n    async getProjectId() {\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        }\n        else if (projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const response = await this.transporter.request({\n                headers,\n                url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\n                responseType: 'json',\n            });\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */\n    async refreshAccessTokenAsync() {\n        // Retrieve the external credential.\n        const subjectToken = await this.retrieveSubjectToken();\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            audience: this.audience,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken,\n            subjectTokenType: this.subjectTokenType,\n            // generateAccessToken requires the provided access token to have\n            // scopes:\n            // https://www.googleapis.com/auth/iam or\n            // https://www.googleapis.com/auth/cloud-platform\n            // The new service account access token scopes will match the user\n            // provided ones.\n            scope: this.serviceAccountImpersonationUrl\n                ? [DEFAULT_OAUTH_SCOPE]\n                : this.getScopesArray(),\n        };\n        // Exchange the external credentials for a GCP access token.\n        // Client auth is prioritized over passing the workforcePoolUserProject\n        // parameter for STS token exchange.\n        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject\n            ? { userProject: this.workforcePoolUserProject }\n            : undefined;\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, additionalOptions);\n        if (this.serviceAccountImpersonationUrl) {\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n        }\n        else if (stsResponse.expires_in) {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                res: stsResponse.res,\n            };\n        }\n        else {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                res: stsResponse.res,\n            };\n        }\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedAccessToken.expiry_date,\n            access_token: this.cachedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */\n    getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */\n    async getImpersonatedAccessToken(token) {\n        const opts = {\n            url: this.serviceAccountImpersonationUrl,\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${token}`,\n            },\n            data: {\n                scope: this.getScopesArray(),\n                lifetime: this.serviceAccountImpersonationLifetime + 's',\n            },\n            responseType: 'json',\n        };\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response,\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date\n            ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */\n    getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === 'string') {\n            return [this.scopes];\n        }\n        else if (typeof this.scopes === 'undefined') {\n            return [DEFAULT_OAUTH_SCOPE];\n        }\n        else {\n            return this.scopes;\n        }\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\n//# sourceMappingURL=baseexternalclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYmFzZWV4dGVybmFsY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsOEJBQThCLEdBQUcsNkJBQTZCLEdBQUcsOEJBQThCO0FBQ25JLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBYztBQUMzQyxZQUFZLG1CQUFPLENBQUMsb0dBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw4QkFBOEI7QUFDdkUsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxVQUFVO0FBQzdFLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQixFQUFFLGNBQWM7QUFDdkU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYmFzZWV4dGVybmFsY2xpZW50LmpzP2IxMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCA9IGV4cG9ydHMuQ0xPVURfUkVTT1VSQ0VfTUFOQUdFUiA9IGV4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9UWVBFID0gZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGhjbGllbnRcIik7XG5jb25zdCBzdHMgPSByZXF1aXJlKFwiLi9zdHNjcmVkZW50aWFsc1wiKTtcbi8qKlxuICogVGhlIHJlcXVpcmVkIHRva2VuIGV4Y2hhbmdlIGdyYW50X3R5cGU6IHJmYzg2OTMjc2VjdGlvbi0yLjFcbiAqL1xuY29uc3QgU1RTX0dSQU5UX1RZUEUgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmdyYW50LXR5cGU6dG9rZW4tZXhjaGFuZ2UnO1xuLyoqXG4gKiBUaGUgcmVxdWVzdGVkIHRva2VuIGV4Y2hhbmdlIHJlcXVlc3RlZF90b2tlbl90eXBlOiByZmM4NjkzI3NlY3Rpb24tMi4xXG4gKi9cbmNvbnN0IFNUU19SRVFVRVNUX1RPS0VOX1RZUEUgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6YWNjZXNzX3Rva2VuJztcbi8qKiBUaGUgZGVmYXVsdCBPQXV0aCBzY29wZSB0byByZXF1ZXN0IHdoZW4gbm9uZSBpcyBwcm92aWRlZC4gKi9cbmNvbnN0IERFRkFVTFRfT0FVVEhfU0NPUEUgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybSc7XG4vKiogRGVmYXVsdCBpbXBlcnNvbmF0ZWQgdG9rZW4gbGlmZXNwYW4gaW4gc2Vjb25kcy4qL1xuY29uc3QgREVGQVVMVF9UT0tFTl9MSUZFU1BBTiA9IDM2MDA7XG4vKipcbiAqIE9mZnNldCB0byB0YWtlIGludG8gYWNjb3VudCBuZXR3b3JrIGRlbGF5cyBhbmQgc2VydmVyIGNsb2NrIHNrZXdzLlxuICovXG5leHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQgPSA1ICogNjAgKiAxMDAwO1xuLyoqXG4gKiBUaGUgY3JlZGVudGlhbHMgSlNPTiBmaWxlIHR5cGUgZm9yIGV4dGVybmFsIGFjY291bnQgY2xpZW50cy5cbiAqIFRoZXJlIGFyZSAzIHR5cGVzIG9mIEpTT04gY29uZmlnczpcbiAqIDEuIGF1dGhvcml6ZWRfdXNlciA9PiBHb29nbGUgZW5kIHVzZXIgY3JlZGVudGlhbFxuICogMi4gc2VydmljZV9hY2NvdW50ID0+IEdvb2dsZSBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbFxuICogMy4gZXh0ZXJuYWxfQWNjb3VudCA9PiBub24tR0NQIHNlcnZpY2UgKGVnLiBBV1MsIEF6dXJlLCBLOHMpXG4gKi9cbmV4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9UWVBFID0gJ2V4dGVybmFsX2FjY291bnQnO1xuLyoqIENsb3VkIHJlc291cmNlIG1hbmFnZXIgVVJMIHVzZWQgdG8gcmV0cmlldmUgcHJvamVjdCBpbmZvcm1hdGlvbi4gKi9cbmV4cG9ydHMuQ0xPVURfUkVTT1VSQ0VfTUFOQUdFUiA9ICdodHRwczovL2Nsb3VkcmVzb3VyY2VtYW5hZ2VyLmdvb2dsZWFwaXMuY29tL3YxL3Byb2plY3RzLyc7XG4vKiogVGhlIHdvcmtmb3JjZSBhdWRpZW5jZSBwYXR0ZXJuLiAqL1xuY29uc3QgV09SS0ZPUkNFX0FVRElFTkNFX1BBVFRFUk4gPSAnLy9pYW0uZ29vZ2xlYXBpcy5jb20vbG9jYXRpb25zL1teL10rL3dvcmtmb3JjZVBvb2xzL1teL10rL3Byb3ZpZGVycy8uKyc7XG4vKipcbiAqIEJhc2UgZXh0ZXJuYWwgYWNjb3VudCBjbGllbnQuIFRoaXMgaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBBdXRoQ2xpZW50cyBmb3JcbiAqIGV4Y2hhbmdpbmcgZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFscyBmb3IgR0NQIGFjY2VzcyB0b2tlbiBhbmQgYXV0aG9yaXppbmdcbiAqIHJlcXVlc3RzIHRvIEdDUCBBUElzLlxuICogVGhlIGJhc2UgY2xhc3MgaW1wbGVtZW50cyBjb21tb24gbG9naWMgZm9yIGV4Y2hhbmdpbmcgdmFyaW91cyB0eXBlIG9mXG4gKiBleHRlcm5hbCBjcmVkZW50aWFscyBmb3IgR0NQIGFjY2VzcyB0b2tlbi4gVGhlIGxvZ2ljIG9mIGRldGVybWluaW5nIGFuZFxuICogcmV0cmlldmluZyB0aGUgZXh0ZXJuYWwgY3JlZGVudGlhbCBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQgYW5kXG4gKiBjcmVkZW50aWFsX3NvdXJjZSB3aWxsIGJlIGxlZnQgZm9yIHRoZSBzdWJjbGFzc2VzLlxuICovXG5jbGFzcyBCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IGV4dGVuZHMgYXV0aGNsaWVudF8xLkF1dGhDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCBpbnN0YW5jZSB1c2luZyB0aGUgcHJvdmlkZWQgSlNPTlxuICAgICAqIG9iamVjdCBsb2FkZWQgZnJvbSBhbiBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWxzIGZpbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucyBvYmplY3QgdHlwaWNhbGx5IGxvYWRlZFxuICAgICAqICAgZnJvbSB0aGUgZXh0ZXJuYWwgYWNjb3VudCBKU09OIGNyZWRlbnRpYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uXG4gICAgICogICBvcHRpb25zLiBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kXG4gICAgICogICB3aGV0aGVyIHRvIHJldHJ5IG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgIT09IGV4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFwiJHtleHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfVFlQRX1cIiB0eXBlIGJ1dCBgICtcbiAgICAgICAgICAgICAgICBgcmVjZWl2ZWQgXCIke29wdGlvbnMudHlwZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50QXV0aCA9IG9wdGlvbnMuY2xpZW50X2lkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBjb25maWRlbnRpYWxDbGllbnRUeXBlOiAnYmFzaWMnLFxuICAgICAgICAgICAgICAgIGNsaWVudElkOiBvcHRpb25zLmNsaWVudF9pZCxcbiAgICAgICAgICAgICAgICBjbGllbnRTZWNyZXQ6IG9wdGlvbnMuY2xpZW50X3NlY3JldCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0c0NyZWRlbnRpYWwgPSBuZXcgc3RzLlN0c0NyZWRlbnRpYWxzKG9wdGlvbnMudG9rZW5fdXJsLCB0aGlzLmNsaWVudEF1dGgpO1xuICAgICAgICAvLyBEZWZhdWx0IE9BdXRoIHNjb3BlLiBUaGlzIGNvdWxkIGJlIG92ZXJyaWRkZW4gdmlhIHB1YmxpYyBwcm9wZXJ0eS5cbiAgICAgICAgdGhpcy5zY29wZXMgPSBbREVGQVVMVF9PQVVUSF9TQ09QRV07XG4gICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmF1ZGllbmNlID0gb3B0aW9ucy5hdWRpZW5jZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0VG9rZW5UeXBlID0gb3B0aW9ucy5zdWJqZWN0X3Rva2VuX3R5cGU7XG4gICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQgPSBvcHRpb25zLnF1b3RhX3Byb2plY3RfaWQ7XG4gICAgICAgIHRoaXMud29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0ID0gb3B0aW9ucy53b3JrZm9yY2VfcG9vbF91c2VyX3Byb2plY3Q7XG4gICAgICAgIGNvbnN0IHdvcmtmb3JjZUF1ZGllbmNlUGF0dGVybiA9IG5ldyBSZWdFeHAoV09SS0ZPUkNFX0FVRElFTkNFX1BBVFRFUk4pO1xuICAgICAgICBpZiAodGhpcy53b3JrZm9yY2VQb29sVXNlclByb2plY3QgJiZcbiAgICAgICAgICAgICF0aGlzLmF1ZGllbmNlLm1hdGNoKHdvcmtmb3JjZUF1ZGllbmNlUGF0dGVybikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0IHNob3VsZCBub3QgYmUgc2V0IGZvciBub24td29ya2ZvcmNlIHBvb2wgJyArXG4gICAgICAgICAgICAgICAgJ2NyZWRlbnRpYWxzLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsID1cbiAgICAgICAgICAgIG9wdGlvbnMuc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsO1xuICAgICAgICB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvbkxpZmV0aW1lID1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IG9wdGlvbnMuc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b2tlbl9saWZldGltZV9zZWNvbmRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBERUZBVUxUX1RPS0VOX0xJRkVTUEFOO1xuICAgICAgICAvLyBBcyB0aHJlc2hvbGQgY291bGQgYmUgemVybyxcbiAgICAgICAgLy8gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIHx8IEVYUElSQVRJT05fVElNRV9PRkZTRVQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICAgICAgLy8gemVybyB2YWx1ZS5cbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkaXRpb25hbE9wdGlvbnMgPT09IG51bGwgfHwgYWRkaXRpb25hbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxPcHRpb25zLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IGV4cG9ydHMuRVhQSVJBVElPTl9USU1FX09GRlNFVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gYWRkaXRpb25hbE9wdGlvbnNcbiAgICAgICAgICAgICAgICAuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlID0gISEoYWRkaXRpb25hbE9wdGlvbnMgPT09IG51bGwgfHwgYWRkaXRpb25hbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxPcHRpb25zLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSk7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9qZWN0TnVtYmVyID0gdGhpcy5nZXRQcm9qZWN0TnVtYmVyKHRoaXMuYXVkaWVuY2UpO1xuICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluID0gb3B0aW9ucy51bml2ZXJzZV9kb21haW47XG4gICAgfVxuICAgIC8qKiBUaGUgc2VydmljZSBhY2NvdW50IGVtYWlsIHRvIGJlIGltcGVyc29uYXRlZCwgaWYgYXZhaWxhYmxlLiAqL1xuICAgIGdldFNlcnZpY2VBY2NvdW50RW1haWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBlbWFpbCBmcm9tIFVSTC4gVGhlIGZvcm1hbCBsb29rcyBhcyBmb2xsb3dzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9pYW1jcmVkZW50aWFscy5nb29nbGVhcGlzLmNvbS92MS9wcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy9uYW1lQHByb2plY3QtaWQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb206Z2VuZXJhdGVBY2Nlc3NUb2tlblxuICAgICAgICAgICAgY29uc3QgcmUgPSAvc2VydmljZUFjY291bnRzXFwvKD88ZW1haWw+W146XSspOmdlbmVyYXRlQWNjZXNzVG9rZW4kLztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlLmV4ZWModGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwpO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZ3JvdXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1haWwpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIGluamVjdCBHQ1AgYWNjZXNzIHRva2VucyBkaXJlY3RseS5cbiAgICAgKiBXaGVuIHRoZSBwcm92aWRlZCBjcmVkZW50aWFsIGV4cGlyZXMsIGEgbmV3IGNyZWRlbnRpYWwsIHVzaW5nIHRoZVxuICAgICAqIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucywgaXMgcmV0cmlldmVkLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgQ3JlZGVudGlhbHMgb2JqZWN0IHRvIHNldCBvbiB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgc3VwZXIuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY3VycmVudCBHQ1AgYWNjZXNzIHRva2VuXG4gICAgICogICByZXNwb25zZS4gSWYgdGhlIGN1cnJlbnQgY3JlZGVudGlhbCBpcyBleHBpcmVkLCBhIG5ldyBvbmUgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICAvLyBJZiBjYWNoZWQgYWNjZXNzIHRva2VuIGlzIHVuYXZhaWxhYmxlIG9yIGV4cGlyZWQsIGZvcmNlIHJlZnJlc2guXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiB8fCB0aGlzLmlzRXhwaXJlZCh0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBHQ1AgYWNjZXNzIHRva2VuIGluIEdldEFjY2Vzc1Rva2VuUmVzcG9uc2UgZm9ybWF0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgcmVzOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLnJlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gYXV0aGVudGljYXRpb24gaW50ZXJmYWNlLiBJdCB0YWtlcyBhbiBvcHRpb25hbCB1cmwgd2hpY2ggd2hlblxuICAgICAqIHByZXNlbnQgaXMgdGhlIGVuZHBvaW50IGJlaW5nIGFjY2Vzc2VkLCBhbmQgcmV0dXJucyBhIFByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB3aXRoIGF1dGhvcml6YXRpb24gaGVhZGVyIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHQgaGFzIHRoZSBmb3JtOlxuICAgICAqIHsgQXV0aG9yaXphdGlvbjogJ0JlYXJlciA8YWNjZXNzX3Rva2VuX3ZhbHVlPicgfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VuUmVzcG9uc2UudG9rZW59YCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHByb2plY3QgSUQgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiAgIGN1cnJlbnQgd29ya2xvYWQgaWRlbnRpdHkgcG9vbCBvciBjdXJyZW50IHdvcmtmb3JjZSBwb29sIGlmXG4gICAgICogICBkZXRlcm1pbmFibGUuIEZvciB3b3JrZm9yY2UgcG9vbCBjcmVkZW50aWFsLCBpdCByZXR1cm5zIHRoZSBwcm9qZWN0IElEXG4gICAgICogICBjb3JyZXNwb25kaW5nIHRvIHRoZSB3b3JrZm9yY2VQb29sVXNlclByb2plY3QuXG4gICAgICogICBUaGlzIGlzIGludHJvZHVjZWQgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgcGF0dGVybiBvZiB1c2luZyB0aGUgQXV0aFxuICAgICAqICAgbGlicmFyeTpcbiAgICAgKiAgIGNvbnN0IHByb2plY3RJZCA9IGF3YWl0IGF1dGguZ2V0UHJvamVjdElkKCk7XG4gICAgICogICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9kbnMuZ29vZ2xlYXBpcy5jb20vZG5zL3YxL3Byb2plY3RzLyR7cHJvamVjdElkfWA7XG4gICAgICogICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCB9KTtcbiAgICAgKiAgIFRoZSByZXNvdXJjZSBtYXkgbm90IGhhdmUgcGVybWlzc2lvblxuICAgICAqICAgKHJlc291cmNlbWFuYWdlci5wcm9qZWN0cy5nZXQpIHRvIGNhbGwgdGhpcyBBUEkgb3IgdGhlIHJlcXVpcmVkXG4gICAgICogICBzY29wZXMgbWF5IG5vdCBiZSBzZWxlY3RlZDpcbiAgICAgKiAgIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9yZXNvdXJjZS1tYW5hZ2VyL3JlZmVyZW5jZS9yZXN0L3YxL3Byb2plY3RzL2dldCNhdXRob3JpemF0aW9uLXNjb3Blc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2plY3RJZCgpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdE51bWJlciA9IHRoaXMucHJvamVjdE51bWJlciB8fCB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdDtcbiAgICAgICAgaWYgKHRoaXMucHJvamVjdElkKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gcHJldmlvdXNseSBkZXRlcm1pbmVkIHByb2plY3QgSUQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE51bWJlcikge1xuICAgICAgICAgICAgLy8gUHJlZmVyYWJsZSBub3QgdG8gdXNlIHJlcXVlc3QoKSB0byBhdm9pZCByZXRyaWFsIHBvbGljaWVzLlxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHVybDogYCR7ZXhwb3J0cy5DTE9VRF9SRVNPVVJDRV9NQU5BR0VSfSR7cHJvamVjdE51bWJlcn1gLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3RJZCA9IHJlc3BvbnNlLmRhdGEucHJvamVjdElkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGVzIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QsIHByb2Nlc3NlcyBpdCBhbmQgcmVzb2x2ZXMgd2l0aCB0aGVcbiAgICAgKiByZXR1cm5lZCByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgSFRUUCByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHJldHJ5IFdoZXRoZXIgdGhlIGN1cnJlbnQgYXR0ZW1wdCBpcyBhIHJldHJ5IGFmdGVyIGEgZmFpbGVkIGF0dGVtcHQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RBc3luYyhvcHRzLCByZXRyeSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGZvciBtZXRhZGF0YSBpZiB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNSZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRva2VuIHJlZnJlc2gsIGV2ZW4gaWYgdW5leHBpcmVkIHRva2VucyBhcmUgY3VycmVudGx5IGNhY2hlZC5cbiAgICAgKiBFeHRlcm5hbCBjcmVkZW50aWFscyBhcmUgZXhjaGFuZ2VkIGZvciBHQ1AgYWNjZXNzIHRva2VucyB2aWEgdGhlIHRva2VuXG4gICAgICogZXhjaGFuZ2UgZW5kcG9pbnQgYW5kIG90aGVyIHNldHRpbmdzIHByb3ZpZGVkIGluIHRoZSBjbGllbnQgb3B0aW9uc1xuICAgICAqIG9iamVjdC5cbiAgICAgKiBJZiB0aGUgc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsIGlzIHByb3ZpZGVkLCBhbiBhZGRpdGlvbmFsXG4gICAgICogc3RlcCB0byBleGNoYW5nZSB0aGUgZXh0ZXJuYWwgYWNjb3VudCBHQ1AgYWNjZXNzIHRva2VuIGZvciBhIHNlcnZpY2VcbiAgICAgKiBhY2NvdW50IGltcGVyc29uYXRlZCB0b2tlbiBpcyBwZXJmb3JtZWQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmcmVzaCBHQ1AgYWNjZXNzIHRva2Vucy5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGV4dGVybmFsIGNyZWRlbnRpYWwuXG4gICAgICAgIGNvbnN0IHN1YmplY3RUb2tlbiA9IGF3YWl0IHRoaXMucmV0cmlldmVTdWJqZWN0VG9rZW4oKTtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBTVFMgY3JlZGVudGlhbHMgb3B0aW9ucy5cbiAgICAgICAgY29uc3Qgc3RzQ3JlZGVudGlhbHNPcHRpb25zID0ge1xuICAgICAgICAgICAgZ3JhbnRUeXBlOiBTVFNfR1JBTlRfVFlQRSxcbiAgICAgICAgICAgIGF1ZGllbmNlOiB0aGlzLmF1ZGllbmNlLFxuICAgICAgICAgICAgcmVxdWVzdGVkVG9rZW5UeXBlOiBTVFNfUkVRVUVTVF9UT0tFTl9UWVBFLFxuICAgICAgICAgICAgc3ViamVjdFRva2VuLFxuICAgICAgICAgICAgc3ViamVjdFRva2VuVHlwZTogdGhpcy5zdWJqZWN0VG9rZW5UeXBlLFxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVBY2Nlc3NUb2tlbiByZXF1aXJlcyB0aGUgcHJvdmlkZWQgYWNjZXNzIHRva2VuIHRvIGhhdmVcbiAgICAgICAgICAgIC8vIHNjb3BlczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvaWFtIG9yXG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtXG4gICAgICAgICAgICAvLyBUaGUgbmV3IHNlcnZpY2UgYWNjb3VudCBhY2Nlc3MgdG9rZW4gc2NvcGVzIHdpbGwgbWF0Y2ggdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIHByb3ZpZGVkIG9uZXMuXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmxcbiAgICAgICAgICAgICAgICA/IFtERUZBVUxUX09BVVRIX1NDT1BFXVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRTY29wZXNBcnJheSgpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBFeGNoYW5nZSB0aGUgZXh0ZXJuYWwgY3JlZGVudGlhbHMgZm9yIGEgR0NQIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgLy8gQ2xpZW50IGF1dGggaXMgcHJpb3JpdGl6ZWQgb3ZlciBwYXNzaW5nIHRoZSB3b3JrZm9yY2VQb29sVXNlclByb2plY3RcbiAgICAgICAgLy8gcGFyYW1ldGVyIGZvciBTVFMgdG9rZW4gZXhjaGFuZ2UuXG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxPcHRpb25zID0gIXRoaXMuY2xpZW50QXV0aCAmJiB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdFxuICAgICAgICAgICAgPyB7IHVzZXJQcm9qZWN0OiB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RzUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0c0NyZWRlbnRpYWwuZXhjaGFuZ2VUb2tlbihzdHNDcmVkZW50aWFsc09wdGlvbnMsIHVuZGVmaW5lZCwgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLmdldEltcGVyc29uYXRlZEFjY2Vzc1Rva2VuKHN0c1Jlc3BvbnNlLmFjY2Vzc190b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RzUmVzcG9uc2UuZXhwaXJlc19pbikge1xuICAgICAgICAgICAgLy8gU2F2ZSByZXNwb25zZSBpbiBjYWNoZWQgYWNjZXNzIHRva2VuLlxuICAgICAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHN0c1Jlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICBleHBpcnlfZGF0ZTogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBzdHNSZXNwb25zZS5leHBpcmVzX2luICogMTAwMCxcbiAgICAgICAgICAgICAgICByZXM6IHN0c1Jlc3BvbnNlLnJlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTYXZlIHJlc3BvbnNlIGluIGNhY2hlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0ge1xuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3RzUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIHJlczogc3RzUmVzcG9uc2UucmVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYXZlIGNyZWRlbnRpYWxzLlxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jcmVkZW50aWFscywgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNyZWRlbnRpYWxzLnJlcztcbiAgICAgICAgLy8gVHJpZ2dlciB0b2tlbnMgZXZlbnQgdG8gbm90aWZ5IGV4dGVybmFsIGxpc3RlbmVycy5cbiAgICAgICAgdGhpcy5lbWl0KCd0b2tlbnMnLCB7XG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBudWxsLFxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGUsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgdG9rZW5fdHlwZTogJ0JlYXJlcicsXG4gICAgICAgICAgICBpZF90b2tlbjogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdvcmtsb2FkIGlkZW50aXR5IHBvb2wgcHJvamVjdCBudW1iZXIgaWYgaXQgaXMgZGV0ZXJtaW5hYmxlXG4gICAgICogZnJvbSB0aGUgYXVkaWVuY2UgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBAcGFyYW0gYXVkaWVuY2UgVGhlIFNUUyBhdWRpZW5jZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJvamVjdCBudW1iZXIuXG4gICAgICogQHJldHVybiBUaGUgcHJvamVjdCBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSB3b3JrbG9hZCBpZGVudGl0eSBwb29sLCBpZlxuICAgICAqICAgdGhpcyBjYW4gYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBTVFMgYXVkaWVuY2UgZmllbGQuIE90aGVyd2lzZSwgbnVsbCBpc1xuICAgICAqICAgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0UHJvamVjdE51bWJlcihhdWRpZW5jZSkge1xuICAgICAgICAvLyBTVFMgYXVkaWVuY2UgcGF0dGVybjpcbiAgICAgICAgLy8gLy9pYW0uZ29vZ2xlYXBpcy5jb20vcHJvamVjdHMvJFBST0pFQ1RfTlVNQkVSL2xvY2F0aW9ucy8uLi5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBhdWRpZW5jZS5tYXRjaCgvXFwvcHJvamVjdHNcXC8oW14vXSspLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjaGFuZ2VzIGFuIGV4dGVybmFsIGFjY291bnQgR0NQIGFjY2VzcyB0b2tlbiBmb3IgYSBzZXJ2aWNlXG4gICAgICogYWNjb3VudCBpbXBlcnNvbmF0ZWQgYWNjZXNzIHRva2VuIHVzaW5nIGlhbWNyZWRlbnRpYWxzXG4gICAgICogR2VuZXJhdGVBY2Nlc3NUb2tlbiBBUEkuXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhY2Nlc3MgdG9rZW4gdG8gZXhjaGFuZ2UgZm9yIGEgc2VydmljZSBhY2NvdW50IGFjY2Vzc1xuICAgICAqICAgdG9rZW4uXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzZXJ2aWNlIGFjY291bnQgaW1wZXJzb25hdGVkXG4gICAgICogICBjcmVkZW50aWFscyByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbXBlcnNvbmF0ZWRBY2Nlc3NUb2tlbih0b2tlbikge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmdldFNjb3Blc0FycmF5KCksXG4gICAgICAgICAgICAgICAgbGlmZXRpbWU6IHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUgKyAncycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICBjb25zdCBzdWNjZXNzUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdWNjZXNzUmVzcG9uc2UuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gSVNPIGZvcm1hdCB0byB0aW1lc3RhbXAuXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogbmV3IERhdGUoc3VjY2Vzc1Jlc3BvbnNlLmV4cGlyZVRpbWUpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIHJlczogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGV4cGlyeSB0aW1lLCBhc3N1bWVzIHRoZSB0b2tlbiBpcyBub3QgZXhwaXJlZCBvciBleHBpcmluZy5cbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gVGhlIGNyZWRlbnRpYWxzIHRvIGNoZWNrIGZvciBleHBpcmF0aW9uLlxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGUgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqL1xuICAgIGlzRXhwaXJlZChhY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlXG4gICAgICAgICAgICA/IG5vdyA+PSBhY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZSAtIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFRoZSBsaXN0IG9mIHNjb3BlcyBmb3IgdGhlIHJlcXVlc3RlZCBHQ1AgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIGdldFNjb3Blc0FycmF5KCkge1xuICAgICAgICAvLyBTaW5jZSBzY29wZXMgY2FuIGJlIHByb3ZpZGVkIGFzIHN0cmluZyBvciBhcnJheSwgdGhlIHR5cGUgc2hvdWxkXG4gICAgICAgIC8vIGJlIG5vcm1hbGl6ZWQuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zY29wZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuc2NvcGVzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5zY29wZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gW0RFRkFVTFRfT0FVVEhfU0NPUEVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gQmFzZUV4dGVybmFsQWNjb3VudENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2VleHRlcm5hbGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/computeclient.js":
/*!***************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/computeclient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Compute = void 0;\nconst arrify = __webpack_require__(/*! arrify */ \"arrify\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(api)/../node_modules/gaxios/build/src/index.js\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(api)/../node_modules/gcp-metadata/build/src/index.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(api)/../node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass Compute extends oauth2client_1.OAuth2Client {\n    /**\n     * Google Compute Engine service account credentials.\n     *\n     * Retrieve access token from the metadata server.\n     * See: https://developers.google.com/compute/docs/authentication\n     */\n    constructor(options = {}) {\n        super(options);\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = { expiry_date: 1, refresh_token: 'compute-placeholder' };\n        this.serviceAccountEmail = options.serviceAccountEmail || 'default';\n        this.scopes = arrify(options.scopes);\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */\n    async refreshTokenNoCache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;\n        let data;\n        try {\n            const instanceOptions = {\n                property: tokenPath,\n            };\n            if (this.scopes.length > 0) {\n                instanceOptions.params = {\n                    scopes: this.scopes.join(','),\n                };\n            }\n            data = await gcpMetadata.instance(instanceOptions);\n        }\n        catch (e) {\n            if (e instanceof gaxios_1.GaxiosError) {\n                e.message = `Could not refresh access token: ${e.message}`;\n                this.wrapError(e);\n            }\n            throw e;\n        }\n        const tokens = data;\n        if (data && data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res: null };\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */\n    async fetchIdToken(targetAudience) {\n        const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity` +\n            `?format=full&audience=${targetAudience}`;\n        let idToken;\n        try {\n            const instanceOptions = {\n                property: idTokenPath,\n            };\n            idToken = await gcpMetadata.instance(instanceOptions);\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Could not fetch ID token: ${e.message}`;\n            }\n            throw e;\n        }\n        return idToken;\n    }\n    wrapError(e) {\n        const res = e.response;\n        if (res && res.status) {\n            e.code = res.status.toString();\n            if (res.status === 403) {\n                e.message =\n                    'A Forbidden error was returned while attempting to retrieve an access ' +\n                        'token for the Compute Engine built-in service account. This may be because the Compute ' +\n                        'Engine instance does not have the correct permission scopes specified: ' +\n                        e.message;\n            }\n            else if (res.status === 404) {\n                e.message =\n                    'A Not Found error was returned while attempting to retrieve an access' +\n                        'token for the Compute Engine built-in service account. This may be because the Compute ' +\n                        'Engine instance does not have any permission scopes specified: ' +\n                        e.message;\n            }\n        }\n    }\n}\nexports.Compute = Compute;\n//# sourceMappingURL=computeclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvY29tcHV0ZWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsK0RBQVE7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsMkVBQWM7QUFDMUMsdUJBQXVCLG1CQUFPLENBQUMsZ0dBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxVQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUI7QUFDekUscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvY29tcHV0ZWNsaWVudC5qcz8xMjAxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTMgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXB1dGUgPSB2b2lkIDA7XG5jb25zdCBhcnJpZnkgPSByZXF1aXJlKFwiYXJyaWZ5XCIpO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3QgZ2NwTWV0YWRhdGEgPSByZXF1aXJlKFwiZ2NwLW1ldGFkYXRhXCIpO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5jbGFzcyBDb21wdXRlIGV4dGVuZHMgb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogUmV0cmlldmUgYWNjZXNzIHRva2VuIGZyb20gdGhlIG1ldGFkYXRhIHNlcnZlci5cbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9hdXRoZW50aWNhdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhbiBleHBpcmVkIHJlZnJlc2ggdG9rZW4sIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBiZVxuICAgICAgICAvLyByZWZyZXNoZWQgYmVmb3JlIHRoZSBmaXJzdCBBUEkgY2FsbCBpcyBtYWRlLlxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0geyBleHBpcnlfZGF0ZTogMSwgcmVmcmVzaF90b2tlbjogJ2NvbXB1dGUtcGxhY2Vob2xkZXInIH07XG4gICAgICAgIHRoaXMuc2VydmljZUFjY291bnRFbWFpbCA9IG9wdGlvbnMuc2VydmljZUFjY291bnRFbWFpbCB8fCAnZGVmYXVsdCc7XG4gICAgICAgIHRoaXMuc2NvcGVzID0gYXJyaWZ5KG9wdGlvbnMuc2NvcGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBVbnVzZWQgcGFyYW1ldGVyXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuTm9DYWNoZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRva2VuUGF0aCA9IGBzZXJ2aWNlLWFjY291bnRzLyR7dGhpcy5zZXJ2aWNlQWNjb3VudEVtYWlsfS90b2tlbmA7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB0b2tlblBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMucGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29wZXM6IHRoaXMuc2NvcGVzLmpvaW4oJywnKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGdjcE1ldGFkYXRhLmluc3RhbmNlKGluc3RhbmNlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgZ2F4aW9zXzEuR2F4aW9zRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgQ291bGQgbm90IHJlZnJlc2ggYWNjZXNzIHRva2VuOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbnMgPSBkYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgIHRva2Vucy5leHBpcnlfZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbnMuZXhwaXJlc19pbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHRva2VucywgcmVzOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYW4gSUQgdG9rZW4uXG4gICAgICogQHBhcmFtIHRhcmdldEF1ZGllbmNlIHRoZSBhdWRpZW5jZSBmb3IgdGhlIGZldGNoZWQgSUQgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hJZFRva2VuKHRhcmdldEF1ZGllbmNlKSB7XG4gICAgICAgIGNvbnN0IGlkVG9rZW5QYXRoID0gYHNlcnZpY2UtYWNjb3VudHMvJHt0aGlzLnNlcnZpY2VBY2NvdW50RW1haWx9L2lkZW50aXR5YCArXG4gICAgICAgICAgICBgP2Zvcm1hdD1mdWxsJmF1ZGllbmNlPSR7dGFyZ2V0QXVkaWVuY2V9YDtcbiAgICAgICAgbGV0IGlkVG9rZW47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IGlkVG9rZW5QYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlkVG9rZW4gPSBhd2FpdCBnY3BNZXRhZGF0YS5pbnN0YW5jZShpbnN0YW5jZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYENvdWxkIG5vdCBmZXRjaCBJRCB0b2tlbjogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkVG9rZW47XG4gICAgfVxuICAgIHdyYXBFcnJvcihlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgIGlmIChyZXMgJiYgcmVzLnN0YXR1cykge1xuICAgICAgICAgICAgZS5jb2RlID0gcmVzLnN0YXR1cy50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICdBIEZvcmJpZGRlbiBlcnJvciB3YXMgcmV0dXJuZWQgd2hpbGUgYXR0ZW1wdGluZyB0byByZXRyaWV2ZSBhbiBhY2Nlc3MgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAndG9rZW4gZm9yIHRoZSBDb21wdXRlIEVuZ2luZSBidWlsdC1pbiBzZXJ2aWNlIGFjY291bnQuIFRoaXMgbWF5IGJlIGJlY2F1c2UgdGhlIENvbXB1dGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnRW5naW5lIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgcGVybWlzc2lvbiBzY29wZXMgc3BlY2lmaWVkOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICdBIE5vdCBGb3VuZCBlcnJvciB3YXMgcmV0dXJuZWQgd2hpbGUgYXR0ZW1wdGluZyB0byByZXRyaWV2ZSBhbiBhY2Nlc3MnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b2tlbiBmb3IgdGhlIENvbXB1dGUgRW5naW5lIGJ1aWx0LWluIHNlcnZpY2UgYWNjb3VudC4gVGhpcyBtYXkgYmUgYmVjYXVzZSB0aGUgQ29tcHV0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbmdpbmUgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBhbnkgcGVybWlzc2lvbiBzY29wZXMgc3BlY2lmaWVkOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHV0ZSA9IENvbXB1dGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wdXRlY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/computeclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/downscopedclient.js":
/*!******************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/downscopedclient.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(api)/../node_modules/google-auth-library/build/src/auth/stscredentials.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\nclass DownscopedClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates a downscoped client object using the provided source\n     * AuthClient and credential access boundary rules.\n     * To downscope permissions of a source AuthClient, a Credential Access\n     * Boundary that specifies which resources the new credential can access, as\n     * well as an upper bound on the permissions that are available on each\n     * resource, has to be defined. A downscoped client can then be instantiated\n     * using the source AuthClient and the Credential Access Boundary.\n     * @param authClient The source AuthClient to be downscoped based on the\n     *   provided Credential Access Boundary rules.\n     * @param credentialAccessBoundary The Credential Access Boundary which\n     *   contains a list of access boundary rules. Each rule contains information\n     *   on the resource that the rule applies to, the upper bound of the\n     *   permissions that are available on that resource and an optional\n     *   condition to further restrict permissions.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     * @param quotaProjectId Optional quota project id for setting up in the\n     *   x-goog-user-project header.\n     */\n    constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n        super();\n        this.authClient = authClient;\n        this.credentialAccessBoundary = credentialAccessBoundary;\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\n        // Boundary.\n        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n            throw new Error('At least one access boundary rule needs to be defined.');\n        }\n        else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length >\n            exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n            throw new Error('The provided access boundary has more than ' +\n                `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n        }\n        // Check at least one permission should be defined in each Access Boundary\n        // Rule.\n        for (const rule of credentialAccessBoundary.accessBoundary\n            .accessBoundaryRules) {\n            if (rule.availablePermissions.length === 0) {\n                throw new Error('At least one permission should be defined in access boundary rules.');\n            }\n        }\n        this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n        this.cachedDownscopedAccessToken = null;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.quotaProjectId = quotaProjectId;\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * The expiry_date field is required to facilitate determination of the token\n     * expiration which would make it easier for the token consumer to handle.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        if (!credentials.expiry_date) {\n            throw new Error('The access token expiry_date field is missing in the provided ' +\n                'credentials.');\n        }\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in\n        // DownscopedAccessTokenResponse format.\n        if (!this.cachedDownscopedAccessToken ||\n            this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n            res: this.cachedDownscopedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n    async refreshAccessTokenAsync() {\n        var _a;\n        // Retrieve GCP access token from source credential.\n        const subjectToken = (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE,\n        };\n        // Exchange the source AuthClient access token for a Downscoped access\n        // token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        /**\n         * The STS endpoint will only return the expiration time for the downscoped\n         * access token if the original access token represents a service account.\n         * The downscoped token's expiration time will always match the source\n         * credential expiration. When no expires_in is returned, we can copy the\n         * source credential's expiration time.\n         */\n        const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n        const expiryDate = stsResponse.expires_in\n            ? new Date().getTime() + stsResponse.expires_in * 1000\n            : sourceCredExpireDate;\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: expiryDate,\n            res: stsResponse.res,\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date\n            ? now >=\n                downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient;\n//# sourceMappingURL=downscopedclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZG93bnNjb3BlZGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLDhCQUE4QixHQUFHLHVDQUF1QztBQUNuRyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsNEZBQWM7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLG9HQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZG93bnNjb3BlZGNsaWVudC5qcz8zZGQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvd25zY29wZWRDbGllbnQgPSBleHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQgPSBleHBvcnRzLk1BWF9BQ0NFU1NfQk9VTkRBUllfUlVMRVNfQ09VTlQgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IHN0cyA9IHJlcXVpcmUoXCIuL3N0c2NyZWRlbnRpYWxzXCIpO1xuLyoqXG4gKiBUaGUgcmVxdWlyZWQgdG9rZW4gZXhjaGFuZ2UgZ3JhbnRfdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfR1JBTlRfVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTp0b2tlbi1leGNoYW5nZSc7XG4vKipcbiAqIFRoZSByZXF1ZXN0ZWQgdG9rZW4gZXhjaGFuZ2UgcmVxdWVzdGVkX3Rva2VuX3R5cGU6IHJmYzg2OTMjc2VjdGlvbi0yLjFcbiAqL1xuY29uc3QgU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTphY2Nlc3NfdG9rZW4nO1xuLyoqXG4gKiBUaGUgcmVxdWVzdGVkIHRva2VuIGV4Y2hhbmdlIHN1YmplY3RfdG9rZW5fdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfU1VCSkVDVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmFjY2Vzc190b2tlbic7XG4vKiogVGhlIFNUUyBhY2Nlc3MgdG9rZW4gZXhjaGFuZ2UgZW5kIHBvaW50LiAqL1xuY29uc3QgU1RTX0FDQ0VTU19UT0tFTl9VUkwgPSAnaHR0cHM6Ly9zdHMuZ29vZ2xlYXBpcy5jb20vdjEvdG9rZW4nO1xuLyoqXG4gKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYWNjZXNzIGJvdW5kYXJ5IHJ1bGVzIGEgQ3JlZGVudGlhbCBBY2Nlc3MgQm91bmRhcnlcbiAqIGNhbiBjb250YWluLlxuICovXG5leHBvcnRzLk1BWF9BQ0NFU1NfQk9VTkRBUllfUlVMRVNfQ09VTlQgPSAxMDtcbi8qKlxuICogT2Zmc2V0IHRvIHRha2UgaW50byBhY2NvdW50IG5ldHdvcmsgZGVsYXlzIGFuZCBzZXJ2ZXIgY2xvY2sgc2tld3MuXG4gKi9cbmV4cG9ydHMuRVhQSVJBVElPTl9USU1FX09GRlNFVCA9IDUgKiA2MCAqIDEwMDA7XG4vKipcbiAqIERlZmluZXMgYSBzZXQgb2YgR29vZ2xlIGNyZWRlbnRpYWxzIHRoYXQgYXJlIGRvd25zY29wZWQgZnJvbSBhbiBleGlzdGluZyBzZXRcbiAqIG9mIEdvb2dsZSBPQXV0aDIgY3JlZGVudGlhbHMuIFRoaXMgaXMgdXNlZnVsIHRvIHJlc3RyaWN0IHRoZSBJZGVudGl0eSBhbmRcbiAqIEFjY2VzcyBNYW5hZ2VtZW50IChJQU0pIHBlcm1pc3Npb25zIHRoYXQgYSBzaG9ydC1saXZlZCBjcmVkZW50aWFsIGNhbiB1c2UuXG4gKiBUaGUgY29tbW9uIHBhdHRlcm4gb2YgdXNhZ2UgaXMgdG8gaGF2ZSBhIHRva2VuIGJyb2tlciB3aXRoIGVsZXZhdGVkIGFjY2Vzc1xuICogZ2VuZXJhdGUgdGhlc2UgZG93bnNjb3BlZCBjcmVkZW50aWFscyBmcm9tIGhpZ2hlciBhY2Nlc3Mgc291cmNlIGNyZWRlbnRpYWxzXG4gKiBhbmQgcGFzcyB0aGUgZG93bnNjb3BlZCBzaG9ydC1saXZlZCBhY2Nlc3MgdG9rZW5zIHRvIGEgdG9rZW4gY29uc3VtZXIgdmlhXG4gKiBzb21lIHNlY3VyZSBhdXRoZW50aWNhdGVkIGNoYW5uZWwgZm9yIGxpbWl0ZWQgYWNjZXNzIHRvIEdvb2dsZSBDbG91ZCBTdG9yYWdlXG4gKiByZXNvdXJjZXMuXG4gKi9cbmNsYXNzIERvd25zY29wZWRDbGllbnQgZXh0ZW5kcyBhdXRoY2xpZW50XzEuQXV0aENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGEgZG93bnNjb3BlZCBjbGllbnQgb2JqZWN0IHVzaW5nIHRoZSBwcm92aWRlZCBzb3VyY2VcbiAgICAgKiBBdXRoQ2xpZW50IGFuZCBjcmVkZW50aWFsIGFjY2VzcyBib3VuZGFyeSBydWxlcy5cbiAgICAgKiBUbyBkb3duc2NvcGUgcGVybWlzc2lvbnMgb2YgYSBzb3VyY2UgQXV0aENsaWVudCwgYSBDcmVkZW50aWFsIEFjY2Vzc1xuICAgICAqIEJvdW5kYXJ5IHRoYXQgc3BlY2lmaWVzIHdoaWNoIHJlc291cmNlcyB0aGUgbmV3IGNyZWRlbnRpYWwgY2FuIGFjY2VzcywgYXNcbiAgICAgKiB3ZWxsIGFzIGFuIHVwcGVyIGJvdW5kIG9uIHRoZSBwZXJtaXNzaW9ucyB0aGF0IGFyZSBhdmFpbGFibGUgb24gZWFjaFxuICAgICAqIHJlc291cmNlLCBoYXMgdG8gYmUgZGVmaW5lZC4gQSBkb3duc2NvcGVkIGNsaWVudCBjYW4gdGhlbiBiZSBpbnN0YW50aWF0ZWRcbiAgICAgKiB1c2luZyB0aGUgc291cmNlIEF1dGhDbGllbnQgYW5kIHRoZSBDcmVkZW50aWFsIEFjY2VzcyBCb3VuZGFyeS5cbiAgICAgKiBAcGFyYW0gYXV0aENsaWVudCBUaGUgc291cmNlIEF1dGhDbGllbnQgdG8gYmUgZG93bnNjb3BlZCBiYXNlZCBvbiB0aGVcbiAgICAgKiAgIHByb3ZpZGVkIENyZWRlbnRpYWwgQWNjZXNzIEJvdW5kYXJ5IHJ1bGVzLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFsQWNjZXNzQm91bmRhcnkgVGhlIENyZWRlbnRpYWwgQWNjZXNzIEJvdW5kYXJ5IHdoaWNoXG4gICAgICogICBjb250YWlucyBhIGxpc3Qgb2YgYWNjZXNzIGJvdW5kYXJ5IHJ1bGVzLiBFYWNoIHJ1bGUgY29udGFpbnMgaW5mb3JtYXRpb25cbiAgICAgKiAgIG9uIHRoZSByZXNvdXJjZSB0aGF0IHRoZSBydWxlIGFwcGxpZXMgdG8sIHRoZSB1cHBlciBib3VuZCBvZiB0aGVcbiAgICAgKiAgIHBlcm1pc3Npb25zIHRoYXQgYXJlIGF2YWlsYWJsZSBvbiB0aGF0IHJlc291cmNlIGFuZCBhbiBvcHRpb25hbFxuICAgICAqICAgY29uZGl0aW9uIHRvIGZ1cnRoZXIgcmVzdHJpY3QgcGVybWlzc2lvbnMuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvblxuICAgICAqICAgb3B0aW9ucy4gVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZFxuICAgICAqICAgd2hldGhlciB0byByZXRyeSBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKiBAcGFyYW0gcXVvdGFQcm9qZWN0SWQgT3B0aW9uYWwgcXVvdGEgcHJvamVjdCBpZCBmb3Igc2V0dGluZyB1cCBpbiB0aGVcbiAgICAgKiAgIHgtZ29vZy11c2VyLXByb2plY3QgaGVhZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGF1dGhDbGllbnQsIGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeSwgYWRkaXRpb25hbE9wdGlvbnMsIHF1b3RhUHJvamVjdElkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXV0aENsaWVudCA9IGF1dGhDbGllbnQ7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5ID0gY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5O1xuICAgICAgICAvLyBDaGVjayAxLTEwIEFjY2VzcyBCb3VuZGFyeSBSdWxlcyBhcmUgZGVmaW5lZCB3aXRoaW4gQ3JlZGVudGlhbCBBY2Nlc3NcbiAgICAgICAgLy8gQm91bmRhcnkuXG4gICAgICAgIGlmIChjcmVkZW50aWFsQWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnlSdWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIGFjY2VzcyBib3VuZGFyeSBydWxlIG5lZWRzIHRvIGJlIGRlZmluZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5LmFjY2Vzc0JvdW5kYXJ5LmFjY2Vzc0JvdW5kYXJ5UnVsZXMubGVuZ3RoID5cbiAgICAgICAgICAgIGV4cG9ydHMuTUFYX0FDQ0VTU19CT1VOREFSWV9SVUxFU19DT1VOVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgYWNjZXNzIGJvdW5kYXJ5IGhhcyBtb3JlIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgYCR7ZXhwb3J0cy5NQVhfQUNDRVNTX0JPVU5EQVJZX1JVTEVTX0NPVU5UfSBhY2Nlc3MgYm91bmRhcnkgcnVsZXMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgYXQgbGVhc3Qgb25lIHBlcm1pc3Npb24gc2hvdWxkIGJlIGRlZmluZWQgaW4gZWFjaCBBY2Nlc3MgQm91bmRhcnlcbiAgICAgICAgLy8gUnVsZS5cbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeVxuICAgICAgICAgICAgLmFjY2Vzc0JvdW5kYXJ5UnVsZXMpIHtcbiAgICAgICAgICAgIGlmIChydWxlLmF2YWlsYWJsZVBlcm1pc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIHBlcm1pc3Npb24gc2hvdWxkIGJlIGRlZmluZWQgaW4gYWNjZXNzIGJvdW5kYXJ5IHJ1bGVzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RzQ3JlZGVudGlhbCA9IG5ldyBzdHMuU3RzQ3JlZGVudGlhbHMoU1RTX0FDQ0VTU19UT0tFTl9VUkwpO1xuICAgICAgICB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICAgIC8vIEFzIHRocmVzaG9sZCBjb3VsZCBiZSB6ZXJvLFxuICAgICAgICAvLyBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgfHwgRVhQSVJBVElPTl9USU1FX09GRlNFVCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgICAgICAvLyB6ZXJvIHZhbHVlLlxuICAgICAgICBpZiAodHlwZW9mIChhZGRpdGlvbmFsT3B0aW9ucyA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRkaXRpb25hbE9wdGlvbnMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBhZGRpdGlvbmFsT3B0aW9uc1xuICAgICAgICAgICAgICAgIC5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUgPSAhIShhZGRpdGlvbmFsT3B0aW9ucyA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRkaXRpb25hbE9wdGlvbnMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKTtcbiAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCA9IHF1b3RhUHJvamVjdElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIG1lY2hhbmlzbSB0byBpbmplY3QgRG93bnNjb3BlZCBhY2Nlc3MgdG9rZW5zIGRpcmVjdGx5LlxuICAgICAqIFRoZSBleHBpcnlfZGF0ZSBmaWVsZCBpcyByZXF1aXJlZCB0byBmYWNpbGl0YXRlIGRldGVybWluYXRpb24gb2YgdGhlIHRva2VuXG4gICAgICogZXhwaXJhdGlvbiB3aGljaCB3b3VsZCBtYWtlIGl0IGVhc2llciBmb3IgdGhlIHRva2VuIGNvbnN1bWVyIHRvIGhhbmRsZS5cbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIENyZWRlbnRpYWxzIG9iamVjdCB0byBzZXQgb24gdGhlIGN1cnJlbnQgY2xpZW50LlxuICAgICAqL1xuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGlmICghY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGFjY2VzcyB0b2tlbiBleHBpcnlfZGF0ZSBmaWVsZCBpcyBtaXNzaW5nIGluIHRoZSBwcm92aWRlZCAnICtcbiAgICAgICAgICAgICAgICAnY3JlZGVudGlhbHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgICAgICB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbiA9IGNyZWRlbnRpYWxzO1xuICAgIH1cbiAgICBhc3luYyBnZXRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNhY2hlZCBhY2Nlc3MgdG9rZW4gaXMgdW5hdmFpbGFibGUgb3IgZXhwaXJlZCwgZm9yY2UgcmVmcmVzaC5cbiAgICAgICAgLy8gVGhlIERvd25zY29wZWQgYWNjZXNzIHRva2VuIHdpbGwgYmUgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gRG93bnNjb3BlZEFjY2Vzc1Rva2VuUmVzcG9uc2UgZm9ybWF0LlxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuIHx8XG4gICAgICAgICAgICB0aGlzLmlzRXhwaXJlZCh0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbikpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gRG93bnNjb3BlZCBhY2Nlc3MgdG9rZW4gaW4gRG93bnNjb3BlZEFjY2Vzc1Rva2VuUmVzcG9uc2UgZm9ybWF0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZSxcbiAgICAgICAgICAgIHJlczogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4ucmVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBhdXRoZW50aWNhdGlvbiBpbnRlcmZhY2UuIEl0IHRha2VzIGFuIG9wdGlvbmFsIHVybCB3aGljaCB3aGVuXG4gICAgICogcHJlc2VudCBpcyB0aGUgZW5kcG9pbnQgYmVpbmcgYWNjZXNzZWQsIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB3aGljaFxuICAgICAqIHJlc29sdmVzIHdpdGggYXV0aG9yaXphdGlvbiBoZWFkZXIgZmllbGRzLlxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdCBoYXMgdGhlIGZvcm06XG4gICAgICogeyBBdXRob3JpemF0aW9uOiAnQmVhcmVyIDxhY2Nlc3NfdG9rZW5fdmFsdWU+JyB9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdEhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW5SZXNwb25zZS50b2tlbn1gLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycyk7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlLCBlLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dGhlbnRpY2F0ZXMgdGhlIHByb3ZpZGVkIEhUVFAgcmVxdWVzdCwgcHJvY2Vzc2VzIGl0IGFuZCByZXNvbHZlcyB3aXRoIHRoZVxuICAgICAqIHJldHVybmVkIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBIVFRQIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gcmV0cnkgV2hldGhlciB0aGUgY3VycmVudCBhdHRlbXB0IGlzIGEgcmV0cnkgYWZ0ZXIgYSBmYWlsZWQgYXR0ZW1wdC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdEFzeW5jKG9wdHMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddID1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SGVhZGVycyAmJiByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3QgZm9yIG1ldGFkYXRhIGlmIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWEgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgLy8gLSBXZSBoYXZlbid0IGFscmVhZHkgcmV0cmllZC4gIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gcmV0cnkgb25jZS5cbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXNwb25zZSB3YXMgYSA0MDEgb3IgYSA0MDNcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXF1ZXN0IGRpZG4ndCBzZW5kIGEgcmVhZGFibGVTdHJlYW1cbiAgICAgICAgICAgICAgICAvLyAtIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSBpcyB0cnVlXG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9IHJlcy5jb25maWcuZGF0YSBpbnN0YW5jZW9mIHN0cmVhbS5SZWFkYWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F1dGhFcnIgPSBzdGF0dXNDb2RlID09PSA0MDEgfHwgc3RhdHVzQ29kZSA9PT0gNDAzO1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoRXJyICYmXG4gICAgICAgICAgICAgICAgICAgICFpc1JlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdEFzeW5jKG9wdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdG9rZW4gcmVmcmVzaCwgZXZlbiBpZiB1bmV4cGlyZWQgdG9rZW5zIGFyZSBjdXJyZW50bHkgY2FjaGVkLlxuICAgICAqIEdDUCBhY2Nlc3MgdG9rZW5zIGFyZSByZXRyaWV2ZWQgZnJvbSBhdXRoY2xpZW50IG9iamVjdC9zb3VyY2UgY3JlZGVudGlhbC5cbiAgICAgKiBUaGVuIEdDUCBhY2Nlc3MgdG9rZW5zIGFyZSBleGNoYW5nZWQgZm9yIGRvd25zY29wZWQgYWNjZXNzIHRva2VucyB2aWEgdGhlXG4gICAgICogdG9rZW4gZXhjaGFuZ2UgZW5kcG9pbnQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmcmVzaCBkb3duc2NvcGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBSZXRyaWV2ZSBHQ1AgYWNjZXNzIHRva2VuIGZyb20gc291cmNlIGNyZWRlbnRpYWwuXG4gICAgICAgIGNvbnN0IHN1YmplY3RUb2tlbiA9IChhd2FpdCB0aGlzLmF1dGhDbGllbnQuZ2V0QWNjZXNzVG9rZW4oKSkudG9rZW47XG4gICAgICAgIC8vIENvbnN0cnVjdCB0aGUgU1RTIGNyZWRlbnRpYWxzIG9wdGlvbnMuXG4gICAgICAgIGNvbnN0IHN0c0NyZWRlbnRpYWxzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGdyYW50VHlwZTogU1RTX0dSQU5UX1RZUEUsXG4gICAgICAgICAgICByZXF1ZXN0ZWRUb2tlblR5cGU6IFNUU19SRVFVRVNUX1RPS0VOX1RZUEUsXG4gICAgICAgICAgICBzdWJqZWN0VG9rZW46IHN1YmplY3RUb2tlbixcbiAgICAgICAgICAgIHN1YmplY3RUb2tlblR5cGU6IFNUU19TVUJKRUNUX1RPS0VOX1RZUEUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEV4Y2hhbmdlIHRoZSBzb3VyY2UgQXV0aENsaWVudCBhY2Nlc3MgdG9rZW4gZm9yIGEgRG93bnNjb3BlZCBhY2Nlc3NcbiAgICAgICAgLy8gdG9rZW4uXG4gICAgICAgIGNvbnN0IHN0c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHNDcmVkZW50aWFsLmV4Y2hhbmdlVG9rZW4oc3RzQ3JlZGVudGlhbHNPcHRpb25zLCB1bmRlZmluZWQsIHRoaXMuY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBTVFMgZW5kcG9pbnQgd2lsbCBvbmx5IHJldHVybiB0aGUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgZG93bnNjb3BlZFxuICAgICAgICAgKiBhY2Nlc3MgdG9rZW4gaWYgdGhlIG9yaWdpbmFsIGFjY2VzcyB0b2tlbiByZXByZXNlbnRzIGEgc2VydmljZSBhY2NvdW50LlxuICAgICAgICAgKiBUaGUgZG93bnNjb3BlZCB0b2tlbidzIGV4cGlyYXRpb24gdGltZSB3aWxsIGFsd2F5cyBtYXRjaCB0aGUgc291cmNlXG4gICAgICAgICAqIGNyZWRlbnRpYWwgZXhwaXJhdGlvbi4gV2hlbiBubyBleHBpcmVzX2luIGlzIHJldHVybmVkLCB3ZSBjYW4gY29weSB0aGVcbiAgICAgICAgICogc291cmNlIGNyZWRlbnRpYWwncyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzb3VyY2VDcmVkRXhwaXJlRGF0ZSA9ICgoX2EgPSB0aGlzLmF1dGhDbGllbnQuY3JlZGVudGlhbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHBpcnlfZGF0ZSkgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgZXhwaXJ5RGF0ZSA9IHN0c1Jlc3BvbnNlLmV4cGlyZXNfaW5cbiAgICAgICAgICAgID8gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBzdHNSZXNwb25zZS5leHBpcmVzX2luICogMTAwMFxuICAgICAgICAgICAgOiBzb3VyY2VDcmVkRXhwaXJlRGF0ZTtcbiAgICAgICAgLy8gU2F2ZSByZXNwb25zZSBpbiBjYWNoZWQgYWNjZXNzIHRva2VuLlxuICAgICAgICB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3RzUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IGV4cGlyeURhdGUsXG4gICAgICAgICAgICByZXM6IHN0c1Jlc3BvbnNlLnJlcyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2F2ZSBjcmVkZW50aWFscy5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY3JlZGVudGlhbHMucmVzO1xuICAgICAgICAvLyBUcmlnZ2VyIHRva2VucyBldmVudCB0byBub3RpZnkgZXh0ZXJuYWwgbGlzdGVuZXJzLlxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHtcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IG51bGwsXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGUsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIHRva2VuX3R5cGU6ICdCZWFyZXInLFxuICAgICAgICAgICAgaWRfdG9rZW46IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGNhY2hlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICogSWYgdGhlcmUgaXMgbm8gZXhwaXJ5IHRpbWUsIGFzc3VtZXMgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkIG9yIGV4cGlyaW5nLlxuICAgICAqIEBwYXJhbSBkb3duc2NvcGVkQWNjZXNzVG9rZW4gVGhlIGNyZWRlbnRpYWxzIHRvIGNoZWNrIGZvciBleHBpcmF0aW9uLlxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGUgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqL1xuICAgIGlzRXhwaXJlZChkb3duc2NvcGVkQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiBkb3duc2NvcGVkQWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGVcbiAgICAgICAgICAgID8gbm93ID49XG4gICAgICAgICAgICAgICAgZG93bnNjb3BlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlIC0gdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3duc2NvcGVkQ2xpZW50ID0gRG93bnNjb3BlZENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvd25zY29wZWRjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/downscopedclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/envDetect.js":
/*!***********************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/envDetect.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEnv = exports.clear = exports.GCPEnv = void 0;\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(api)/../node_modules/gcp-metadata/build/src/index.js\");\nvar GCPEnv;\n(function (GCPEnv) {\n    GCPEnv[\"APP_ENGINE\"] = \"APP_ENGINE\";\n    GCPEnv[\"KUBERNETES_ENGINE\"] = \"KUBERNETES_ENGINE\";\n    GCPEnv[\"CLOUD_FUNCTIONS\"] = \"CLOUD_FUNCTIONS\";\n    GCPEnv[\"COMPUTE_ENGINE\"] = \"COMPUTE_ENGINE\";\n    GCPEnv[\"CLOUD_RUN\"] = \"CLOUD_RUN\";\n    GCPEnv[\"NONE\"] = \"NONE\";\n})(GCPEnv = exports.GCPEnv || (exports.GCPEnv = {}));\nlet envPromise;\nfunction clear() {\n    envPromise = undefined;\n}\nexports.clear = clear;\nasync function getEnv() {\n    if (envPromise) {\n        return envPromise;\n    }\n    envPromise = getEnvMemoized();\n    return envPromise;\n}\nexports.getEnv = getEnv;\nasync function getEnvMemoized() {\n    let env = GCPEnv.NONE;\n    if (isAppEngine()) {\n        env = GCPEnv.APP_ENGINE;\n    }\n    else if (isCloudFunction()) {\n        env = GCPEnv.CLOUD_FUNCTIONS;\n    }\n    else if (await isComputeEngine()) {\n        if (await isKubernetesEngine()) {\n            env = GCPEnv.KUBERNETES_ENGINE;\n        }\n        else if (isCloudRun()) {\n            env = GCPEnv.CLOUD_RUN;\n        }\n        else {\n            env = GCPEnv.COMPUTE_ENGINE;\n        }\n    }\n    else {\n        env = GCPEnv.NONE;\n    }\n    return env;\n}\nfunction isAppEngine() {\n    return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);\n}\nfunction isCloudFunction() {\n    return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);\n}\n/**\n * This check only verifies that the environment is running knative.\n * This must be run *after* checking for Kubernetes, otherwise it will\n * return a false positive.\n */\nfunction isCloudRun() {\n    return !!process.env.K_CONFIGURATION;\n}\nasync function isKubernetesEngine() {\n    try {\n        await gcpMetadata.instance('attributes/cluster-name');\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nasync function isComputeEngine() {\n    return gcpMetadata.isAvailable();\n}\n//# sourceMappingURL=envDetect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZW52RGV0ZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGFBQWEsR0FBRyxjQUFjO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLDJFQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QixjQUFjLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9lbnZEZXRlY3QuanM/YmNmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbnYgPSBleHBvcnRzLmNsZWFyID0gZXhwb3J0cy5HQ1BFbnYgPSB2b2lkIDA7XG5jb25zdCBnY3BNZXRhZGF0YSA9IHJlcXVpcmUoXCJnY3AtbWV0YWRhdGFcIik7XG52YXIgR0NQRW52O1xuKGZ1bmN0aW9uIChHQ1BFbnYpIHtcbiAgICBHQ1BFbnZbXCJBUFBfRU5HSU5FXCJdID0gXCJBUFBfRU5HSU5FXCI7XG4gICAgR0NQRW52W1wiS1VCRVJORVRFU19FTkdJTkVcIl0gPSBcIktVQkVSTkVURVNfRU5HSU5FXCI7XG4gICAgR0NQRW52W1wiQ0xPVURfRlVOQ1RJT05TXCJdID0gXCJDTE9VRF9GVU5DVElPTlNcIjtcbiAgICBHQ1BFbnZbXCJDT01QVVRFX0VOR0lORVwiXSA9IFwiQ09NUFVURV9FTkdJTkVcIjtcbiAgICBHQ1BFbnZbXCJDTE9VRF9SVU5cIl0gPSBcIkNMT1VEX1JVTlwiO1xuICAgIEdDUEVudltcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbn0pKEdDUEVudiA9IGV4cG9ydHMuR0NQRW52IHx8IChleHBvcnRzLkdDUEVudiA9IHt9KSk7XG5sZXQgZW52UHJvbWlzZTtcbmZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGVudlByb21pc2UgPSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNsZWFyID0gY2xlYXI7XG5hc3luYyBmdW5jdGlvbiBnZXRFbnYoKSB7XG4gICAgaWYgKGVudlByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIGVudlByb21pc2U7XG4gICAgfVxuICAgIGVudlByb21pc2UgPSBnZXRFbnZNZW1vaXplZCgpO1xuICAgIHJldHVybiBlbnZQcm9taXNlO1xufVxuZXhwb3J0cy5nZXRFbnYgPSBnZXRFbnY7XG5hc3luYyBmdW5jdGlvbiBnZXRFbnZNZW1vaXplZCgpIHtcbiAgICBsZXQgZW52ID0gR0NQRW52Lk5PTkU7XG4gICAgaWYgKGlzQXBwRW5naW5lKCkpIHtcbiAgICAgICAgZW52ID0gR0NQRW52LkFQUF9FTkdJTkU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ2xvdWRGdW5jdGlvbigpKSB7XG4gICAgICAgIGVudiA9IEdDUEVudi5DTE9VRF9GVU5DVElPTlM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF3YWl0IGlzQ29tcHV0ZUVuZ2luZSgpKSB7XG4gICAgICAgIGlmIChhd2FpdCBpc0t1YmVybmV0ZXNFbmdpbmUoKSkge1xuICAgICAgICAgICAgZW52ID0gR0NQRW52LktVQkVSTkVURVNfRU5HSU5FO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2xvdWRSdW4oKSkge1xuICAgICAgICAgICAgZW52ID0gR0NQRW52LkNMT1VEX1JVTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVudiA9IEdDUEVudi5DT01QVVRFX0VOR0lORTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW52ID0gR0NQRW52Lk5PTkU7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59XG5mdW5jdGlvbiBpc0FwcEVuZ2luZSgpIHtcbiAgICByZXR1cm4gISEocHJvY2Vzcy5lbnYuR0FFX1NFUlZJQ0UgfHwgcHJvY2Vzcy5lbnYuR0FFX01PRFVMRV9OQU1FKTtcbn1cbmZ1bmN0aW9uIGlzQ2xvdWRGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISEocHJvY2Vzcy5lbnYuRlVOQ1RJT05fTkFNRSB8fCBwcm9jZXNzLmVudi5GVU5DVElPTl9UQVJHRVQpO1xufVxuLyoqXG4gKiBUaGlzIGNoZWNrIG9ubHkgdmVyaWZpZXMgdGhhdCB0aGUgZW52aXJvbm1lbnQgaXMgcnVubmluZyBrbmF0aXZlLlxuICogVGhpcyBtdXN0IGJlIHJ1biAqYWZ0ZXIqIGNoZWNraW5nIGZvciBLdWJlcm5ldGVzLCBvdGhlcndpc2UgaXQgd2lsbFxuICogcmV0dXJuIGEgZmFsc2UgcG9zaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvdWRSdW4oKSB7XG4gICAgcmV0dXJuICEhcHJvY2Vzcy5lbnYuS19DT05GSUdVUkFUSU9OO1xufVxuYXN5bmMgZnVuY3Rpb24gaXNLdWJlcm5ldGVzRW5naW5lKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGdjcE1ldGFkYXRhLmluc3RhbmNlKCdhdHRyaWJ1dGVzL2NsdXN0ZXItbmFtZScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzQ29tcHV0ZUVuZ2luZSgpIHtcbiAgICByZXR1cm4gZ2NwTWV0YWRhdGEuaXNBdmFpbGFibGUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudkRldGVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/envDetect.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/executable-response.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/executable-response.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;\nconst SAML_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:saml2';\nconst OIDC_SUBJECT_TOKEN_TYPE1 = 'urn:ietf:params:oauth:token-type:id_token';\nconst OIDC_SUBJECT_TOKEN_TYPE2 = 'urn:ietf:params:oauth:token-type:jwt';\n/**\n * Defines the response of a 3rd party executable run by the pluggable auth client.\n */\nclass ExecutableResponse {\n    /**\n     * Instantiates an ExecutableResponse instance using the provided JSON object\n     * from the output of the executable.\n     * @param responseJson Response from a 3rd party executable, loaded from a\n     * run of the executable or a cached output file.\n     */\n    constructor(responseJson) {\n        // Check that the required fields exist in the json response.\n        if (!responseJson.version) {\n            throw new InvalidVersionFieldError(\"Executable response must contain a 'version' field.\");\n        }\n        if (responseJson.success === undefined) {\n            throw new InvalidSuccessFieldError(\"Executable response must contain a 'success' field.\");\n        }\n        this.version = responseJson.version;\n        this.success = responseJson.success;\n        // Validate required fields for a successful response.\n        if (this.success) {\n            this.expirationTime = responseJson.expiration_time;\n            this.tokenType = responseJson.token_type;\n            // Validate token type field.\n            if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE &&\n                this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 &&\n                this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {\n                throw new InvalidTokenTypeFieldError(\"Executable response must contain a 'token_type' field when successful \" +\n                    `and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);\n            }\n            // Validate subject token.\n            if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {\n                if (!responseJson.saml_response) {\n                    throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);\n                }\n                this.subjectToken = responseJson.saml_response;\n            }\n            else {\n                if (!responseJson.id_token) {\n                    throw new InvalidSubjectTokenError(\"Executable response must contain a 'id_token' field when \" +\n                        `token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);\n                }\n                this.subjectToken = responseJson.id_token;\n            }\n        }\n        else {\n            // Both code and message must be provided for unsuccessful responses.\n            if (!responseJson.code) {\n                throw new InvalidCodeFieldError(\"Executable response must contain a 'code' field when unsuccessful.\");\n            }\n            if (!responseJson.message) {\n                throw new InvalidMessageFieldError(\"Executable response must contain a 'message' field when unsuccessful.\");\n            }\n            this.errorCode = responseJson.code;\n            this.errorMessage = responseJson.message;\n        }\n    }\n    /**\n     * @return A boolean representing if the response has a valid token. Returns\n     * true when the response was successful and the token is not expired.\n     */\n    isValid() {\n        return !this.isExpired() && this.success;\n    }\n    /**\n     * @return A boolean representing if the response is expired. Returns true if the\n     * provided timeout has passed.\n     */\n    isExpired() {\n        return (this.expirationTime !== undefined &&\n            this.expirationTime < Math.round(Date.now() / 1000));\n    }\n}\nexports.ExecutableResponse = ExecutableResponse;\n/**\n * An error thrown by the ExecutableResponse class.\n */\nclass ExecutableResponseError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableResponseError = ExecutableResponseError;\n/**\n * An error thrown when the 'version' field in an executable response is missing or invalid.\n */\nclass InvalidVersionFieldError extends ExecutableResponseError {\n}\nexports.InvalidVersionFieldError = InvalidVersionFieldError;\n/**\n * An error thrown when the 'success' field in an executable response is missing or invalid.\n */\nclass InvalidSuccessFieldError extends ExecutableResponseError {\n}\nexports.InvalidSuccessFieldError = InvalidSuccessFieldError;\n/**\n * An error thrown when the 'expiration_time' field in an executable response is missing or invalid.\n */\nclass InvalidExpirationTimeFieldError extends ExecutableResponseError {\n}\nexports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;\n/**\n * An error thrown when the 'token_type' field in an executable response is missing or invalid.\n */\nclass InvalidTokenTypeFieldError extends ExecutableResponseError {\n}\nexports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;\n/**\n * An error thrown when the 'code' field in an executable response is missing or invalid.\n */\nclass InvalidCodeFieldError extends ExecutableResponseError {\n}\nexports.InvalidCodeFieldError = InvalidCodeFieldError;\n/**\n * An error thrown when the 'message' field in an executable response is missing or invalid.\n */\nclass InvalidMessageFieldError extends ExecutableResponseError {\n}\nexports.InvalidMessageFieldError = InvalidMessageFieldError;\n/**\n * An error thrown when the subject token in an executable response is missing or invalid.\n */\nclass InvalidSubjectTokenError extends ExecutableResponseError {\n}\nexports.InvalidSubjectTokenError = InvalidSubjectTokenError;\n//# sourceMappingURL=executable-response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXhlY3V0YWJsZS1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDZCQUE2QixHQUFHLGtDQUFrQyxHQUFHLHVDQUF1QyxHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLCtCQUErQixHQUFHLDBCQUEwQjtBQUN2VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QixJQUFJLHlCQUF5QixPQUFPLHdCQUF3QjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSSx3QkFBd0I7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBCQUEwQixLQUFLLHlCQUF5QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leGVjdXRhYmxlLXJlc3BvbnNlLmpzPzNkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFN1YmplY3RUb2tlbkVycm9yID0gZXhwb3J0cy5JbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRDb2RlRmllbGRFcnJvciA9IGV4cG9ydHMuSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRTdWNjZXNzRmllbGRFcnJvciA9IGV4cG9ydHMuSW52YWxpZFZlcnNpb25GaWVsZEVycm9yID0gZXhwb3J0cy5FeGVjdXRhYmxlUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuRXhlY3V0YWJsZVJlc3BvbnNlID0gdm9pZCAwO1xuY29uc3QgU0FNTF9TVUJKRUNUX1RPS0VOX1RZUEUgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6c2FtbDInO1xuY29uc3QgT0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUxID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmlkX3Rva2VuJztcbmNvbnN0IE9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMiA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTpqd3QnO1xuLyoqXG4gKiBEZWZpbmVzIHRoZSByZXNwb25zZSBvZiBhIDNyZCBwYXJ0eSBleGVjdXRhYmxlIHJ1biBieSB0aGUgcGx1Z2dhYmxlIGF1dGggY2xpZW50LlxuICovXG5jbGFzcyBFeGVjdXRhYmxlUmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBFeGVjdXRhYmxlUmVzcG9uc2UgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIEpTT04gb2JqZWN0XG4gICAgICogZnJvbSB0aGUgb3V0cHV0IG9mIHRoZSBleGVjdXRhYmxlLlxuICAgICAqIEBwYXJhbSByZXNwb25zZUpzb24gUmVzcG9uc2UgZnJvbSBhIDNyZCBwYXJ0eSBleGVjdXRhYmxlLCBsb2FkZWQgZnJvbSBhXG4gICAgICogcnVuIG9mIHRoZSBleGVjdXRhYmxlIG9yIGEgY2FjaGVkIG91dHB1dCBmaWxlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlSnNvbikge1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSByZXF1aXJlZCBmaWVsZHMgZXhpc3QgaW4gdGhlIGpzb24gcmVzcG9uc2UuXG4gICAgICAgIGlmICghcmVzcG9uc2VKc29uLnZlcnNpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmVyc2lvbkZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICd2ZXJzaW9uJyBmaWVsZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlSnNvbi5zdWNjZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdzdWNjZXNzJyBmaWVsZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gcmVzcG9uc2VKc29uLnZlcnNpb247XG4gICAgICAgIHRoaXMuc3VjY2VzcyA9IHJlc3BvbnNlSnNvbi5zdWNjZXNzO1xuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMgZm9yIGEgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgICAgaWYgKHRoaXMuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IHJlc3BvbnNlSnNvbi5leHBpcmF0aW9uX3RpbWU7XG4gICAgICAgICAgICB0aGlzLnRva2VuVHlwZSA9IHJlc3BvbnNlSnNvbi50b2tlbl90eXBlO1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdG9rZW4gdHlwZSBmaWVsZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuVHlwZSAhPT0gU0FNTF9TVUJKRUNUX1RPS0VOX1RZUEUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuVHlwZSAhPT0gT0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUxICYmXG4gICAgICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgIT09IE9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5UeXBlRmllbGRFcnJvcihcIkV4ZWN1dGFibGUgcmVzcG9uc2UgbXVzdCBjb250YWluIGEgJ3Rva2VuX3R5cGUnIGZpZWxkIHdoZW4gc3VjY2Vzc2Z1bCBcIiArXG4gICAgICAgICAgICAgICAgICAgIGBhbmQgaXQgbXVzdCBiZSBvbmUgb2YgJHtPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTF9LCAke09JRENfU1VCSkVDVF9UT0tFTl9UWVBFMn0sIG9yICR7U0FNTF9TVUJKRUNUX1RPS0VOX1RZUEV9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgc3ViamVjdCB0b2tlbi5cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuVHlwZSA9PT0gU0FNTF9TVUJKRUNUX1RPS0VOX1RZUEUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi5zYW1sX3Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3ViamVjdFRva2VuRXJyb3IoYEV4ZWN1dGFibGUgcmVzcG9uc2UgbXVzdCBjb250YWluIGEgJ3NhbWxfcmVzcG9uc2UnIGZpZWxkIHdoZW4gdG9rZW5fdHlwZT0ke1NBTUxfU1VCSkVDVF9UT0tFTl9UWVBFfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJqZWN0VG9rZW4gPSByZXNwb25zZUpzb24uc2FtbF9yZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2VKc29uLmlkX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3ViamVjdFRva2VuRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdpZF90b2tlbicgZmllbGQgd2hlbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBgdG9rZW5fdHlwZT0ke09JRENfU1VCSkVDVF9UT0tFTl9UWVBFMX0gb3IgJHtPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTJ9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3RUb2tlbiA9IHJlc3BvbnNlSnNvbi5pZF90b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEJvdGggY29kZSBhbmQgbWVzc2FnZSBtdXN0IGJlIHByb3ZpZGVkIGZvciB1bnN1Y2Nlc3NmdWwgcmVzcG9uc2VzLlxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUpzb24uY29kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ29kZUZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdjb2RlJyBmaWVsZCB3aGVuIHVuc3VjY2Vzc2Z1bC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlRmllbGRFcnJvcihcIkV4ZWN1dGFibGUgcmVzcG9uc2UgbXVzdCBjb250YWluIGEgJ21lc3NhZ2UnIGZpZWxkIHdoZW4gdW5zdWNjZXNzZnVsLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb2RlID0gcmVzcG9uc2VKc29uLmNvZGU7XG4gICAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IHJlc3BvbnNlSnNvbi5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBib29sZWFuIHJlcHJlc2VudGluZyBpZiB0aGUgcmVzcG9uc2UgaGFzIGEgdmFsaWQgdG9rZW4uIFJldHVybnNcbiAgICAgKiB0cnVlIHdoZW4gdGhlIHJlc3BvbnNlIHdhcyBzdWNjZXNzZnVsIGFuZCB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQuXG4gICAgICovXG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRXhwaXJlZCgpICYmIHRoaXMuc3VjY2VzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIGlmIHRoZSByZXNwb25zZSBpcyBleHBpcmVkLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAgICogcHJvdmlkZWQgdGltZW91dCBoYXMgcGFzc2VkLlxuICAgICAqL1xuICAgIGlzRXhwaXJlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmV4cGlyYXRpb25UaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPCBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeGVjdXRhYmxlUmVzcG9uc2UgPSBFeGVjdXRhYmxlUmVzcG9uc2U7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biBieSB0aGUgRXhlY3V0YWJsZVJlc3BvbnNlIGNsYXNzLlxuICovXG5jbGFzcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IgPSBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICd2ZXJzaW9uJyBmaWVsZCBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZFZlcnNpb25GaWVsZEVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkVmVyc2lvbkZpZWxkRXJyb3IgPSBJbnZhbGlkVmVyc2lvbkZpZWxkRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAnc3VjY2VzcycgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRTdWNjZXNzRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yID0gSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ2V4cGlyYXRpb25fdGltZScgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IgPSBJbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ3Rva2VuX3R5cGUnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkVG9rZW5UeXBlRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IgPSBJbnZhbGlkVG9rZW5UeXBlRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICdjb2RlJyBmaWVsZCBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZENvZGVGaWVsZEVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkQ29kZUZpZWxkRXJyb3IgPSBJbnZhbGlkQ29kZUZpZWxkRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAnbWVzc2FnZScgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRNZXNzYWdlRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yID0gSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgc3ViamVjdCB0b2tlbiBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZFN1YmplY3RUb2tlbkVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkU3ViamVjdFRva2VuRXJyb3IgPSBJbnZhbGlkU3ViamVjdFRva2VuRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGVjdXRhYmxlLXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/executable-response.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(api)/../node_modules/google-auth-library/build/src/auth/oauth2common.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(api)/../node_modules/gaxios/build/src/index.js\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * The credentials JSON file type for external account authorized user clients.\n */\nexports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = 'external_account_authorized_user';\n/**\n * Handler for token refresh requests sent to the token_url endpoint for external\n * authorized user credentials.\n */\nclass ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an ExternalAccountAuthorizedUserHandler instance.\n     * @param url The URL of the token refresh endpoint.\n     * @param transporter The transporter to use for the refresh request.\n     * @param clientAuthentication The client authentication credentials to use\n     *   for the refresh request.\n     */\n    constructor(url, transporter, clientAuthentication) {\n        super(clientAuthentication);\n        this.url = url;\n        this.transporter = transporter;\n    }\n    /**\n     * Requests a new access token from the token_url endpoint using the provided\n     *   refresh token.\n     * @param refreshToken The refresh token to use to generate a new access token.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @return A promise that resolves with the token refresh response containing\n     *   the requested access token and its expiration time.\n     */\n    async refreshToken(refreshToken, additionalHeaders) {\n        const values = new URLSearchParams({\n            grant_type: 'refresh_token',\n            refresh_token: refreshToken,\n        });\n        const headers = {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            ...additionalHeaders,\n        };\n        const opts = {\n            url: this.url,\n            method: 'POST',\n            headers,\n            data: values.toString(),\n            responseType: 'json',\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const tokenRefreshResponse = response.data;\n            tokenRefreshResponse.res = response;\n            return tokenRefreshResponse;\n        }\n        catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, \n                // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\n/**\n * External Account Authorized User Client. This is used for OAuth2 credentials\n * sourced using external identities through Workforce Identity Federation.\n * Obtaining the initial access and refresh token can be done through the\n * Google Cloud CLI.\n */\nclass ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates an ExternalAccountAuthorizedUserClient instances using the\n     * provided JSON object loaded from a credentials files.\n     * An error is throws if the credential is not valid.\n     * @param options The external account authorized user option object typically\n     *   from the external accoutn authorized user JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super();\n        this.refreshToken = options.refresh_token;\n        const clientAuth = {\n            confidentialClientType: 'basic',\n            clientId: options.client_id,\n            clientSecret: options.client_secret,\n        };\n        this.externalAccountAuthorizedUserHandler =\n            new ExternalAccountAuthorizedUserHandler(options.token_url, this.transporter, clientAuth);\n        this.cachedAccessToken = null;\n        this.quotaProjectId = options.quota_project_id;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    }\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * @return A promise that resolves with the refreshed credential.\n     */\n    async refreshAccessTokenAsync() {\n        // Refresh the access token using the refresh token.\n        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);\n        this.cachedAccessToken = {\n            access_token: refreshResponse.access_token,\n            expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\n            res: refreshResponse.res,\n        };\n        if (refreshResponse.refresh_token !== undefined) {\n            this.refreshToken = refreshResponse.refresh_token;\n        }\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param credentials The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(credentials) {\n        const now = new Date().getTime();\n        return credentials.expiry_date\n            ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;\n//# sourceMappingURL=externalAccountAuthorizedUserClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQ0FBMkMsR0FBRyw2Q0FBNkM7QUFDM0YscUJBQXFCLG1CQUFPLENBQUMsNEZBQWM7QUFDM0MsdUJBQXVCLG1CQUFPLENBQUMsZ0dBQWdCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLCtEQUFRO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudC5qcz9kYjczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50ID0gZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFID0gdm9pZCAwO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IG9hdXRoMmNvbW1vbl8xID0gcmVxdWlyZShcIi4vb2F1dGgyY29tbW9uXCIpO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3Qgc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuLyoqXG4gKiBUaGUgY3JlZGVudGlhbHMgSlNPTiBmaWxlIHR5cGUgZm9yIGV4dGVybmFsIGFjY291bnQgYXV0aG9yaXplZCB1c2VyIGNsaWVudHMuXG4gKi9cbmV4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9BVVRIT1JJWkVEX1VTRVJfVFlQRSA9ICdleHRlcm5hbF9hY2NvdW50X2F1dGhvcml6ZWRfdXNlcic7XG4vKipcbiAqIEhhbmRsZXIgZm9yIHRva2VuIHJlZnJlc2ggcmVxdWVzdHMgc2VudCB0byB0aGUgdG9rZW5fdXJsIGVuZHBvaW50IGZvciBleHRlcm5hbFxuICogYXV0aG9yaXplZCB1c2VyIGNyZWRlbnRpYWxzLlxuICovXG5jbGFzcyBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIgZXh0ZW5kcyBvYXV0aDJjb21tb25fMS5PQXV0aENsaWVudEF1dGhIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJMIG9mIHRoZSB0b2tlbiByZWZyZXNoIGVuZHBvaW50LlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRlciBUaGUgdHJhbnNwb3J0ZXIgdG8gdXNlIGZvciB0aGUgcmVmcmVzaCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBjbGllbnRBdXRoZW50aWNhdGlvbiBUaGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIHRvIHVzZVxuICAgICAqICAgZm9yIHRoZSByZWZyZXNoIHJlcXVlc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCB0cmFuc3BvcnRlciwgY2xpZW50QXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgc3VwZXIoY2xpZW50QXV0aGVudGljYXRpb24pO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRlciA9IHRyYW5zcG9ydGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhIG5ldyBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgdG9rZW5fdXJsIGVuZHBvaW50IHVzaW5nIHRoZSBwcm92aWRlZFxuICAgICAqICAgcmVmcmVzaCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIFRoZSByZWZyZXNoIHRva2VuIHRvIHVzZSB0byBnZW5lcmF0ZSBhIG5ldyBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIE9wdGlvbmFsIGFkZGl0aW9uYWwgaGVhZGVycyB0byBwYXNzIGFsb25nIHRoZVxuICAgICAqICAgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHRva2VuIHJlZnJlc2ggcmVzcG9uc2UgY29udGFpbmluZ1xuICAgICAqICAgdGhlIHJlcXVlc3RlZCBhY2Nlc3MgdG9rZW4gYW5kIGl0cyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbiwgYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgLi4uYWRkaXRpb25hbEhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgZGF0YTogdmFsdWVzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXBwbHkgT0F1dGggY2xpZW50IGF1dGhlbnRpY2F0aW9uLlxuICAgICAgICB0aGlzLmFwcGx5Q2xpZW50QXV0aGVudGljYXRpb25PcHRpb25zKG9wdHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICAvLyBTdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAgICAgICAgY29uc3QgdG9rZW5SZWZyZXNoUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgdG9rZW5SZWZyZXNoUmVzcG9uc2UucmVzID0gcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5SZWZyZXNoUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgZXJyb3IgdG8gT0F1dGhFcnJvci5cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yICYmIGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIG9hdXRoMmNvbW1vbl8xLmdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSkoZXJyb3IucmVzcG9uc2UuZGF0YSwgXG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgb3RoZXIgZmllbGRzIGZyb20gdGhlIG9yaWdpbmFsIGVycm9yLlxuICAgICAgICAgICAgICAgIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcXVlc3QgY291bGQgZmFpbCBiZWZvcmUgdGhlIHNlcnZlciByZXNwb25kcy5cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBFeHRlcm5hbCBBY2NvdW50IEF1dGhvcml6ZWQgVXNlciBDbGllbnQuIFRoaXMgaXMgdXNlZCBmb3IgT0F1dGgyIGNyZWRlbnRpYWxzXG4gKiBzb3VyY2VkIHVzaW5nIGV4dGVybmFsIGlkZW50aXRpZXMgdGhyb3VnaCBXb3JrZm9yY2UgSWRlbnRpdHkgRmVkZXJhdGlvbi5cbiAqIE9idGFpbmluZyB0aGUgaW5pdGlhbCBhY2Nlc3MgYW5kIHJlZnJlc2ggdG9rZW4gY2FuIGJlIGRvbmUgdGhyb3VnaCB0aGVcbiAqIEdvb2dsZSBDbG91ZCBDTEkuXG4gKi9cbmNsYXNzIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50IGV4dGVuZHMgYXV0aGNsaWVudF8xLkF1dGhDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudCBpbnN0YW5jZXMgdXNpbmcgdGhlXG4gICAgICogcHJvdmlkZWQgSlNPTiBvYmplY3QgbG9hZGVkIGZyb20gYSBjcmVkZW50aWFscyBmaWxlcy5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd3MgaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IHZhbGlkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IGF1dGhvcml6ZWQgdXNlciBvcHRpb24gb2JqZWN0IHR5cGljYWxseVxuICAgICAqICAgZnJvbSB0aGUgZXh0ZXJuYWwgYWNjb3V0biBhdXRob3JpemVkIHVzZXIgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvblxuICAgICAqICAgb3B0aW9ucy4gVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZFxuICAgICAqICAgd2hldGhlciB0byByZXRyeSBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IG9wdGlvbnMucmVmcmVzaF90b2tlbjtcbiAgICAgICAgY29uc3QgY2xpZW50QXV0aCA9IHtcbiAgICAgICAgICAgIGNvbmZpZGVudGlhbENsaWVudFR5cGU6ICdiYXNpYycsXG4gICAgICAgICAgICBjbGllbnRJZDogb3B0aW9ucy5jbGllbnRfaWQsXG4gICAgICAgICAgICBjbGllbnRTZWNyZXQ6IG9wdGlvbnMuY2xpZW50X3NlY3JldCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIgPVxuICAgICAgICAgICAgbmV3IEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlcihvcHRpb25zLnRva2VuX3VybCwgdGhpcy50cmFuc3BvcnRlciwgY2xpZW50QXV0aCk7XG4gICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0gb3B0aW9ucy5xdW90YV9wcm9qZWN0X2lkO1xuICAgICAgICAvLyBBcyB0aHJlc2hvbGQgY291bGQgYmUgemVybyxcbiAgICAgICAgLy8gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIHx8IEVYUElSQVRJT05fVElNRV9PRkZTRVQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICAgICAgLy8gemVybyB2YWx1ZS5cbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkaXRpb25hbE9wdGlvbnMgPT09IG51bGwgfHwgYWRkaXRpb25hbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxPcHRpb25zLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYUElSQVRJT05fVElNRV9PRkZTRVQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IGFkZGl0aW9uYWxPcHRpb25zXG4gICAgICAgICAgICAgICAgLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSA9ICEhKGFkZGl0aW9uYWxPcHRpb25zID09PSBudWxsIHx8IGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRpdGlvbmFsT3B0aW9ucy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgLy8gSWYgY2FjaGVkIGFjY2VzcyB0b2tlbiBpcyB1bmF2YWlsYWJsZSBvciBleHBpcmVkLCBmb3JjZSByZWZyZXNoLlxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gfHwgdGhpcy5pc0V4cGlyZWQodGhpcy5jYWNoZWRBY2Nlc3NUb2tlbikpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gR0NQIGFjY2VzcyB0b2tlbiBpbiBHZXRBY2Nlc3NUb2tlblJlc3BvbnNlIGZvcm1hdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIHJlczogdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbi5yZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldFJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VuUmVzcG9uc2UudG9rZW59YCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGVzIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QsIHByb2Nlc3NlcyBpdCBhbmQgcmVzb2x2ZXMgd2l0aCB0aGVcbiAgICAgKiByZXR1cm5lZCByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgSFRUUCByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHJldHJ5IFdoZXRoZXIgdGhlIGN1cnJlbnQgYXR0ZW1wdCBpcyBhIHJldHJ5IGFmdGVyIGEgZmFpbGVkIGF0dGVtcHQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RBc3luYyhvcHRzLCByZXRyeSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGZvciBtZXRhZGF0YSBpZiB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNSZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRva2VuIHJlZnJlc2gsIGV2ZW4gaWYgdW5leHBpcmVkIHRva2VucyBhcmUgY3VycmVudGx5IGNhY2hlZC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlZnJlc2hlZCBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCkge1xuICAgICAgICAvLyBSZWZyZXNoIHRoZSBhY2Nlc3MgdG9rZW4gdXNpbmcgdGhlIHJlZnJlc2ggdG9rZW4uXG4gICAgICAgIGNvbnN0IHJlZnJlc2hSZXNwb25zZSA9IGF3YWl0IHRoaXMuZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJIYW5kbGVyLnJlZnJlc2hUb2tlbih0aGlzLnJlZnJlc2hUb2tlbik7XG4gICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSB7XG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHJlZnJlc2hSZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyByZWZyZXNoUmVzcG9uc2UuZXhwaXJlc19pbiAqIDEwMDAsXG4gICAgICAgICAgICByZXM6IHJlZnJlc2hSZXNwb25zZS5yZXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWZyZXNoUmVzcG9uc2UucmVmcmVzaF90b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hSZXNwb25zZS5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyBleHBpcnkgdGltZSwgYXNzdW1lcyB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQgb3IgZXhwaXJpbmcuXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBjcmVkZW50aWFscyB0byBjaGVjayBmb3IgZXhwaXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBpc0V4cGlyZWQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiBjcmVkZW50aWFscy5leHBpcnlfZGF0ZVxuICAgICAgICAgICAgPyBub3cgPj0gY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgLSB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1xuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50ID0gRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/externalclient.js":
/*!****************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/externalclient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExternalAccountClient = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst identitypoolclient_1 = __webpack_require__(/*! ./identitypoolclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nconst awsclient_1 = __webpack_require__(/*! ./awsclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/awsclient.js\");\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(api)/../node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\n/**\n * Dummy class with no constructor. Developers are expected to use fromJSON.\n */\nclass ExternalAccountClient {\n    constructor() {\n        throw new Error('ExternalAccountClients should be initialized via: ' +\n            'ExternalAccountClient.fromJSON(), ' +\n            'directly via explicit constructors, eg. ' +\n            'new AwsClient(options), new IdentityPoolClient(options), new' +\n            'PluggableAuthClientOptions, or via ' +\n            'new GoogleAuth(options).getClient()');\n    }\n    /**\n     * This static method will instantiate the\n     * corresponding type of external account credential depending on the\n     * underlying credential source.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     * @return A BaseExternalAccountClient instance or null if the options\n     *   provided do not correspond to an external account credential.\n     */\n    static fromJSON(options, additionalOptions) {\n        var _a, _b;\n        if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            if ((_a = options.credential_source) === null || _a === void 0 ? void 0 : _a.environment_id) {\n                return new awsclient_1.AwsClient(options, additionalOptions);\n            }\n            else if ((_b = options.credential_source) === null || _b === void 0 ? void 0 : _b.executable) {\n                return new pluggable_auth_client_1.PluggableAuthClient(options, additionalOptions);\n            }\n            else {\n                return new identitypoolclient_1.IdentityPoolClient(options, additionalOptions);\n            }\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.ExternalAccountClient = ExternalAccountClient;\n//# sourceMappingURL=externalclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXh0ZXJuYWxjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXNCO0FBQzNELDZCQUE2QixtQkFBTyxDQUFDLDRHQUFzQjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQywwRkFBYTtBQUN6QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxrSEFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbGNsaWVudC5qcz83OTJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4dGVybmFsQWNjb3VudENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgaWRlbnRpdHlwb29sY2xpZW50XzEgPSByZXF1aXJlKFwiLi9pZGVudGl0eXBvb2xjbGllbnRcIik7XG5jb25zdCBhd3NjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F3c2NsaWVudFwiKTtcbmNvbnN0IHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xID0gcmVxdWlyZShcIi4vcGx1Z2dhYmxlLWF1dGgtY2xpZW50XCIpO1xuLyoqXG4gKiBEdW1teSBjbGFzcyB3aXRoIG5vIGNvbnN0cnVjdG9yLiBEZXZlbG9wZXJzIGFyZSBleHBlY3RlZCB0byB1c2UgZnJvbUpTT04uXG4gKi9cbmNsYXNzIEV4dGVybmFsQWNjb3VudENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZXJuYWxBY2NvdW50Q2xpZW50cyBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgdmlhOiAnICtcbiAgICAgICAgICAgICdFeHRlcm5hbEFjY291bnRDbGllbnQuZnJvbUpTT04oKSwgJyArXG4gICAgICAgICAgICAnZGlyZWN0bHkgdmlhIGV4cGxpY2l0IGNvbnN0cnVjdG9ycywgZWcuICcgK1xuICAgICAgICAgICAgJ25ldyBBd3NDbGllbnQob3B0aW9ucyksIG5ldyBJZGVudGl0eVBvb2xDbGllbnQob3B0aW9ucyksIG5ldycgK1xuICAgICAgICAgICAgJ1BsdWdnYWJsZUF1dGhDbGllbnRPcHRpb25zLCBvciB2aWEgJyArXG4gICAgICAgICAgICAnbmV3IEdvb2dsZUF1dGgob3B0aW9ucykuZ2V0Q2xpZW50KCknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBzdGF0aWMgbWV0aG9kIHdpbGwgaW5zdGFudGlhdGUgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyB0eXBlIG9mIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbCBkZXBlbmRpbmcgb24gdGhlXG4gICAgICogdW5kZXJseWluZyBjcmVkZW50aWFsIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkXG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICogQHJldHVybiBBIEJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgaW5zdGFuY2Ugb3IgbnVsbCBpZiB0aGUgb3B0aW9uc1xuICAgICAqICAgcHJvdmlkZWQgZG8gbm90IGNvcnJlc3BvbmQgdG8gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgPT09IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbnZpcm9ubWVudF9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXdzY2xpZW50XzEuQXdzQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMS5QbHVnZ2FibGVBdXRoQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaWRlbnRpdHlwb29sY2xpZW50XzEuSWRlbnRpdHlQb29sQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRDbGllbnQgPSBFeHRlcm5hbEFjY291bnRDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlcm5hbGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/externalclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/googleauth.js":
/*!************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/googleauth.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(api)/../node_modules/gcp-metadata/build/src/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(api)/../node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(api)/../node_modules/google-auth-library/build/src/transporters.js\");\nconst computeclient_1 = __webpack_require__(/*! ./computeclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/computeclient.js\");\nconst idtokenclient_1 = __webpack_require__(/*! ./idtokenclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nconst envDetect_1 = __webpack_require__(/*! ./envDetect */ \"(api)/../node_modules/google-auth-library/build/src/auth/envDetect.js\");\nconst jwtclient_1 = __webpack_require__(/*! ./jwtclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nconst refreshclient_1 = __webpack_require__(/*! ./refreshclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nconst impersonated_1 = __webpack_require__(/*! ./impersonated */ \"(api)/../node_modules/google-auth-library/build/src/auth/impersonated.js\");\nconst externalclient_1 = __webpack_require__(/*! ./externalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/externalclient.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst externalAccountAuthorizedUserClient_1 = __webpack_require__(/*! ./externalAccountAuthorizedUserClient */ \"(api)/../node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\");\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nconst GoogleAuthExceptionMessages = {\n    NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \\n' +\n        'To learn more about authentication and Google APIs, visit: \\n' +\n        'https://cloud.google.com/docs/authentication/getting-started',\n};\nclass GoogleAuth {\n    // Note:  this properly is only public to satisify unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n    get isGCE() {\n        return this.checkIsGCE;\n    }\n    constructor(opts) {\n        /**\n         * Caches a value indicating whether the auth layer is running on Google\n         * Compute Engine.\n         * @private\n         */\n        this.checkIsGCE = undefined;\n        // To save the contents of the JSON credential file\n        this.jsonContent = null;\n        this.cachedCredential = null;\n        opts = opts || {};\n        this._cachedProjectId = opts.projectId || null;\n        this.cachedCredential = opts.authClient || null;\n        this.keyFilename = opts.keyFilename || opts.keyFile;\n        this.scopes = opts.scopes;\n        this.jsonContent = opts.credentials || null;\n        this.clientOptions = opts.clientOptions;\n    }\n    // GAPIC client libraries should always use self-signed JWTs. The following\n    // variables are set on the JWT client in order to indicate the type of library,\n    // and sign the JWT with the correct audience and scopes (if not supplied).\n    setGapicJWTValues(client) {\n        client.defaultServicePath = this.defaultServicePath;\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n        client.defaultScopes = this.defaultScopes;\n    }\n    getProjectId(callback) {\n        if (callback) {\n            this.getProjectIdAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getProjectIdAsync();\n        }\n    }\n    /**\n     * A temporary method for internal `getProjectId` usages where `null` is\n     * acceptable. In a future major release, `getProjectId` should return `null`\n     * (as the `Promise<string | null>` base signature describes) and this private\n     * method should be removed.\n     *\n     * @returns Promise that resolves with project id (or `null`)\n     */\n    async getProjectIdOptional() {\n        try {\n            return await this.getProjectId();\n        }\n        catch (e) {\n            if (e instanceof Error &&\n                e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n                return null;\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    /*\n     * A private method for finding and caching a projectId.\n     *\n     * Supports environments in order of precedence:\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n     * - Cloud SDK: `gcloud config config-helper --format json`\n     * - GCE project ID from metadata server\n     *\n     * @returns projectId\n     */\n    async findAndCacheProjectId() {\n        let projectId = null;\n        projectId || (projectId = await this.getProductionProjectId());\n        projectId || (projectId = await this.getFileProjectId());\n        projectId || (projectId = await this.getDefaultServiceProjectId());\n        projectId || (projectId = await this.getGCEProjectId());\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\n        if (projectId) {\n            this._cachedProjectId = projectId;\n            return projectId;\n        }\n        else {\n            throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n        }\n    }\n    async getProjectIdAsync() {\n        if (this._cachedProjectId) {\n            return this._cachedProjectId;\n        }\n        if (!this._findProjectIdPromise) {\n            this._findProjectIdPromise = this.findAndCacheProjectId();\n        }\n        return this._findProjectIdPromise;\n    }\n    /**\n     * @returns Any scopes (user-specified or default scopes specified by the\n     *   client library) that need to be set on the current Auth client.\n     */\n    getAnyScopes() {\n        return this.scopes || this.defaultScopes;\n    }\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n        let options;\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n        }\n        else {\n            return this.getApplicationDefaultAsync(options);\n        }\n    }\n    async getApplicationDefaultAsync(options = {}) {\n        // If we've already got a cached credential, return it.\n        // This will also preserve one's configured quota project, in case they\n        // set one directly on the credential previously.\n        if (this.cachedCredential) {\n            return await this.prepareAndCacheADC(this.cachedCredential);\n        }\n        // Since this is a 'new' ADC to cache we will use the environment variable\n        // if it's available. We prefer this value over the value from ADC.\n        const quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'];\n        let credential;\n        // Check for the existence of a local environment variable pointing to the\n        // location of the credential file. This is typically used in local\n        // developer scenarios.\n        credential =\n            await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            }\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Look in the well-known credential file location.\n        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            }\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Determine if we're running on GCE.\n        let isGCE;\n        try {\n            isGCE = await this._checkIsGCE();\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unexpected error determining execution environment: ${e.message}`;\n            }\n            throw e;\n        }\n        if (!isGCE) {\n            // We failed to find the default credentials. Bail out with an error.\n            throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n        }\n        // For GCE, just return a default ComputeClient. It will take care of\n        // the rest.\n        options.scopes = this.getAnyScopes();\n        return await this.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);\n    }\n    async prepareAndCacheADC(credential, quotaProjectIdOverride) {\n        const projectId = await this.getProjectIdOptional();\n        if (quotaProjectIdOverride) {\n            credential.quotaProjectId = quotaProjectIdOverride;\n        }\n        this.cachedCredential = credential;\n        return { credential, projectId };\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * Checks for GCP Residency, then fallback to checking if metadata server\n     * is available.\n     *\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */\n    async _checkIsGCE() {\n        if (this.checkIsGCE === undefined) {\n            this.checkIsGCE =\n                gcpMetadata.getGCPResidency() || (await gcpMetadata.isAvailable());\n        }\n        return this.checkIsGCE;\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n        const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\n            process.env['google_application_credentials'];\n        if (!credentialsPath || credentialsPath.length === 0) {\n            return null;\n        }\n        try {\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n        // First, figure out the location of the file, depending upon the OS type.\n        let location = null;\n        if (this._isWindows()) {\n            // Windows\n            location = process.env['APPDATA'];\n        }\n        else {\n            // Linux or Mac\n            const home = process.env['HOME'];\n            if (home) {\n                location = path.join(home, '.config');\n            }\n        }\n        // If we found the root path, expand it.\n        if (location) {\n            location = path.join(location, 'gcloud', 'application_default_credentials.json');\n            if (!fs.existsSync(location)) {\n                location = null;\n            }\n        }\n        // The file does not exist.\n        if (!location) {\n            return null;\n        }\n        // The file seems to exist. Try to use it.\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\n        return client;\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */\n    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n        // Make sure the path looks like a string.\n        if (!filePath || filePath.length === 0) {\n            throw new Error('The file path is invalid.');\n        }\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = fs.realpathSync(filePath);\n            if (!fs.lstatSync(filePath).isFile()) {\n                throw new Error();\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        // Now open a read stream on the file, and parse it.\n        const readStream = fs.createReadStream(filePath);\n        return this.fromStream(readStream, options);\n    }\n    /**\n     * Create a credentials instance using a given impersonated input options.\n     * @param json The impersonated input object.\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromImpersonatedJSON(json) {\n        var _a, _b, _c, _d;\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\n        }\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n        }\n        if (!json.source_credentials) {\n            throw new Error('The incoming JSON object does not contain a source_credentials field');\n        }\n        if (!json.service_account_impersonation_url) {\n            throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\n        }\n        // Create source client for impersonation\n        const sourceClient = new refreshclient_1.UserRefreshClient(json.source_credentials.client_id, json.source_credentials.client_secret, json.source_credentials.refresh_token);\n        // Extreact service account from service_account_impersonation_url\n        const targetPrincipal = (_b = (_a = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.target;\n        if (!targetPrincipal) {\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n        }\n        const targetScopes = (_c = this.getAnyScopes()) !== null && _c !== void 0 ? _c : [];\n        const client = new impersonated_1.Impersonated({\n            delegates: (_d = json.delegates) !== null && _d !== void 0 ? _d : [],\n            sourceClient: sourceClient,\n            targetPrincipal: targetPrincipal,\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes],\n        });\n        return client;\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromJSON(json, options = {}) {\n        let client;\n        options = options || {};\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n            client = new refreshclient_1.UserRefreshClient(options);\n            client.fromJSON(json);\n        }\n        else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            client = this.fromImpersonatedJSON(json);\n        }\n        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n            client.scopes = this.getAnyScopes();\n        }\n        else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n        }\n        else {\n            options.scopes = this.scopes;\n            client = new jwtclient_1.JWT(options);\n            this.setGapicJWTValues(client);\n            client.fromJSON(json);\n        }\n        return client;\n    }\n    /**\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n     * object used to instantiate and the client.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    _cacheClientFromJSON(json, options) {\n        const client = this.fromJSON(json, options);\n        // cache both raw data used to instantiate client and client itself.\n        this.jsonContent = json;\n        this.cachedCredential = client;\n        return client;\n    }\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream, options);\n        }\n    }\n    fromStreamAsync(inputStream, options) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                throw new Error('Must pass in a stream containing the Google auth settings.');\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    try {\n                        const data = JSON.parse(s);\n                        const r = this._cacheClientFromJSON(data, options);\n                        return resolve(r);\n                    }\n                    catch (err) {\n                        // If we failed parsing this.keyFileName, assume that it\n                        // is a PEM or p12 certificate:\n                        if (!this.keyFilename)\n                            throw err;\n                        const client = new jwtclient_1.JWT({\n                            ...this.clientOptions,\n                            keyFile: this.keyFilename,\n                        });\n                        this.cachedCredential = client;\n                        this.setGapicJWTValues(client);\n                        return resolve(client);\n                    }\n                }\n                catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */\n    fromAPIKey(apiKey, options) {\n        options = options || {};\n        const client = new jwtclient_1.JWT(options);\n        client.fromAPIKey(apiKey);\n        return client;\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */\n    _isWindows() {\n        const sys = os.platform();\n        if (sys && sys.length >= 3) {\n            if (sys.substring(0, 3).toLowerCase() === 'win') {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */\n    async getDefaultServiceProjectId() {\n        return new Promise(resolve => {\n            (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => {\n                if (!err && stdout) {\n                    try {\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\n                        resolve(projectId);\n                        return;\n                    }\n                    catch (e) {\n                        // ignore errors\n                    }\n                }\n                resolve(null);\n            });\n        });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */\n    getProductionProjectId() {\n        return (process.env['GCLOUD_PROJECT'] ||\n            process.env['GOOGLE_CLOUD_PROJECT'] ||\n            process.env['gcloud_project'] ||\n            process.env['google_cloud_project']);\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */\n    async getFileProjectId() {\n        if (this.cachedCredential) {\n            // Try to read the project ID from the cached credentials file\n            return this.cachedCredential.projectId;\n        }\n        // Ensure the projectId is loaded from the keyFile if available.\n        if (this.keyFilename) {\n            const creds = await this.getClient();\n            if (creds && creds.projectId) {\n                return creds.projectId;\n            }\n        }\n        // Try to load a credentials file and read its project ID\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n        if (r) {\n            return r.projectId;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Gets the project ID from external account client if available.\n     */\n    async getExternalAccountClientProjectId() {\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            return null;\n        }\n        const creds = await this.getClient();\n        // Do not suppress the underlying error, as the error could contain helpful\n        // information for debugging and fixing. This is especially true for\n        // external account creds as in order to get the project ID, the following\n        // operations have to succeed:\n        // 1. Valid credentials file should be supplied.\n        // 2. Ability to retrieve access tokens from STS token exchange API.\n        // 3. Ability to exchange for service account impersonated credentials (if\n        //    enabled).\n        // 4. Ability to get project info using the access token from step 2 or 3.\n        // Without surfacing the error, it is harder for developers to determine\n        // which step went wrong.\n        return await creds.getProjectId();\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */\n    async getGCEProjectId() {\n        try {\n            const r = await gcpMetadata.project('project-id');\n            return r;\n        }\n        catch (e) {\n            // Ignore any errors\n            return null;\n        }\n    }\n    getCredentials(callback) {\n        if (callback) {\n            this.getCredentialsAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getCredentialsAsync();\n        }\n    }\n    async getCredentialsAsync() {\n        const client = await this.getClient();\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n            const serviceAccountEmail = client.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                return { client_email: serviceAccountEmail };\n            }\n        }\n        if (this.jsonContent) {\n            const credential = {\n                client_email: this.jsonContent.client_email,\n                private_key: this.jsonContent.private_key,\n            };\n            return credential;\n        }\n        const isGCE = await this._checkIsGCE();\n        if (!isGCE) {\n            throw new Error('Unknown error.');\n        }\n        // For GCE, return the service account details from the metadata server\n        // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n        // The GCF metadata server doesn't respect querystring params if this / is\n        // not included.\n        const data = await gcpMetadata.instance({\n            property: 'service-accounts/',\n            params: { recursive: 'true' },\n        });\n        if (!data || !data.default || !data.default.email) {\n            throw new Error('Failure from metadata server.');\n        }\n        return { client_email: data.default.email };\n    }\n    /**\n     * Automatically obtain a client based on the provided configuration.  If no\n     * options were passed, use Application Default Credentials.\n     */\n    async getClient() {\n        if (!this.cachedCredential) {\n            if (this.jsonContent) {\n                this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n            }\n            else if (this.keyFilename) {\n                const filePath = path.resolve(this.keyFilename);\n                const stream = fs.createReadStream(filePath);\n                await this.fromStreamAsync(stream, this.clientOptions);\n            }\n            else {\n                await this.getApplicationDefaultAsync(this.clientOptions);\n            }\n        }\n        return this.cachedCredential;\n    }\n    /**\n     * Creates a client which will fetch an ID token for authorization.\n     * @param targetAudience the audience for the fetched ID token.\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n     */\n    async getIdTokenClient(targetAudience) {\n        const client = await this.getClient();\n        if (!('fetchIdToken' in client)) {\n            throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n        }\n        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */\n    async getAccessToken() {\n        const client = await this.getClient();\n        return (await client.getAccessToken()).token;\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */\n    async getRequestHeaders(url) {\n        const client = await this.getClient();\n        return client.getRequestHeaders(url);\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */\n    async authorizeRequest(opts) {\n        opts = opts || {};\n        const url = opts.url || opts.uri;\n        const client = await this.getClient();\n        const headers = await client.getRequestHeaders(url);\n        opts.headers = Object.assign(opts.headers || {}, headers);\n        return opts;\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(opts) {\n        const client = await this.getClient();\n        return client.request(opts);\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */\n    getEnv() {\n        return (0, envDetect_1.getEnv)();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     */\n    async sign(data) {\n        const client = await this.getClient();\n        const crypto = (0, crypto_1.createCrypto)();\n        if (client instanceof jwtclient_1.JWT && client.key) {\n            const sign = await crypto.sign(client.key, data);\n            return sign;\n        }\n        const creds = await this.getCredentials();\n        if (!creds.client_email) {\n            throw new Error('Cannot sign data without `client_email`.');\n        }\n        return this.signBlob(crypto, creds.client_email, data);\n    }\n    async signBlob(crypto, emailOrUniqueId, data) {\n        const url = 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/' +\n            `${emailOrUniqueId}:signBlob`;\n        const res = await this.request({\n            method: 'POST',\n            url,\n            data: {\n                payload: crypto.encodeBase64StringUtf8(data),\n            },\n        });\n        return res.data.signedBlob;\n    }\n}\nexports.GoogleAuth = GoogleAuth;\n/**\n * Export DefaultTransporter as a static property of the class.\n */\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\n//# sourceMappingURL=googleauth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZ29vZ2xlYXV0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLDJCQUEyQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQyxvQ0FBZTtBQUMvQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixvQkFBb0IsbUJBQU8sQ0FBQywyRUFBYztBQUMxQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsOEZBQWtCO0FBQzNDLHVCQUF1QixtQkFBTyxDQUFDLDRGQUFpQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQyxrR0FBaUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsa0dBQWlCO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3pDLHdCQUF3QixtQkFBTyxDQUFDLGtHQUFpQjtBQUNqRCx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBZ0I7QUFDL0MseUJBQXlCLG1CQUFPLENBQUMsb0dBQWtCO0FBQ25ELDZCQUE2QixtQkFBTyxDQUFDLDRHQUFzQjtBQUMzRCw4Q0FBOEMsbUJBQU8sQ0FBQyw4SUFBdUM7QUFDN0YsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFVBQVU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksVUFBVTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVUsdUNBQXVDLFlBQVk7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHlDQUF5QztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsdUNBQXVDO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQseUNBQXlDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2dvb2dsZWF1dGguanM/Y2YwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hb29nbGVBdXRoID0gZXhwb3J0cy5DTE9VRF9TREtfQ0xJRU5UX0lEID0gdm9pZCAwO1xuY29uc3QgY2hpbGRfcHJvY2Vzc18xID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IGdjcE1ldGFkYXRhID0gcmVxdWlyZShcImdjcC1tZXRhZGF0YVwiKTtcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2NyeXB0b1wiKTtcbmNvbnN0IHRyYW5zcG9ydGVyc18xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydGVyc1wiKTtcbmNvbnN0IGNvbXB1dGVjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NvbXB1dGVjbGllbnRcIik7XG5jb25zdCBpZHRva2VuY2xpZW50XzEgPSByZXF1aXJlKFwiLi9pZHRva2VuY2xpZW50XCIpO1xuY29uc3QgZW52RGV0ZWN0XzEgPSByZXF1aXJlKFwiLi9lbnZEZXRlY3RcIik7XG5jb25zdCBqd3RjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2p3dGNsaWVudFwiKTtcbmNvbnN0IHJlZnJlc2hjbGllbnRfMSA9IHJlcXVpcmUoXCIuL3JlZnJlc2hjbGllbnRcIik7XG5jb25zdCBpbXBlcnNvbmF0ZWRfMSA9IHJlcXVpcmUoXCIuL2ltcGVyc29uYXRlZFwiKTtcbmNvbnN0IGV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbGNsaWVudFwiKTtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50XCIpO1xuZXhwb3J0cy5DTE9VRF9TREtfQ0xJRU5UX0lEID0gJzc2NDA4NjA1MTg1MC02cXI0cDZncGk2aG41MDZwdDhlanVxODNkaTM0MWh1ci5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSc7XG5jb25zdCBHb29nbGVBdXRoRXhjZXB0aW9uTWVzc2FnZXMgPSB7XG4gICAgTk9fUFJPSkVDVF9JRF9GT1VORDogJ1VuYWJsZSB0byBkZXRlY3QgYSBQcm9qZWN0IElkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBcXG4nICtcbiAgICAgICAgJ1RvIGxlYXJuIG1vcmUgYWJvdXQgYXV0aGVudGljYXRpb24gYW5kIEdvb2dsZSBBUElzLCB2aXNpdDogXFxuJyArXG4gICAgICAgICdodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZG9jcy9hdXRoZW50aWNhdGlvbi9nZXR0aW5nLXN0YXJ0ZWQnLFxufTtcbmNsYXNzIEdvb2dsZUF1dGgge1xuICAgIC8vIE5vdGU6ICB0aGlzIHByb3Blcmx5IGlzIG9ubHkgcHVibGljIHRvIHNhdGlzaWZ5IHVuaXQgdGVzdHMuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy81MjI4XG4gICAgZ2V0IGlzR0NFKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0lzR0NFO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZXMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGF1dGggbGF5ZXIgaXMgcnVubmluZyBvbiBHb29nbGVcbiAgICAgICAgICogQ29tcHV0ZSBFbmdpbmUuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrSXNHQ0UgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRvIHNhdmUgdGhlIGNvbnRlbnRzIG9mIHRoZSBKU09OIGNyZWRlbnRpYWwgZmlsZVxuICAgICAgICB0aGlzLmpzb25Db250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gbnVsbDtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHRoaXMuX2NhY2hlZFByb2plY3RJZCA9IG9wdHMucHJvamVjdElkIHx8IG51bGw7XG4gICAgICAgIHRoaXMuY2FjaGVkQ3JlZGVudGlhbCA9IG9wdHMuYXV0aENsaWVudCB8fCBudWxsO1xuICAgICAgICB0aGlzLmtleUZpbGVuYW1lID0gb3B0cy5rZXlGaWxlbmFtZSB8fCBvcHRzLmtleUZpbGU7XG4gICAgICAgIHRoaXMuc2NvcGVzID0gb3B0cy5zY29wZXM7XG4gICAgICAgIHRoaXMuanNvbkNvbnRlbnQgPSBvcHRzLmNyZWRlbnRpYWxzIHx8IG51bGw7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucyA9IG9wdHMuY2xpZW50T3B0aW9ucztcbiAgICB9XG4gICAgLy8gR0FQSUMgY2xpZW50IGxpYnJhcmllcyBzaG91bGQgYWx3YXlzIHVzZSBzZWxmLXNpZ25lZCBKV1RzLiBUaGUgZm9sbG93aW5nXG4gICAgLy8gdmFyaWFibGVzIGFyZSBzZXQgb24gdGhlIEpXVCBjbGllbnQgaW4gb3JkZXIgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGlicmFyeSxcbiAgICAvLyBhbmQgc2lnbiB0aGUgSldUIHdpdGggdGhlIGNvcnJlY3QgYXVkaWVuY2UgYW5kIHNjb3BlcyAoaWYgbm90IHN1cHBsaWVkKS5cbiAgICBzZXRHYXBpY0pXVFZhbHVlcyhjbGllbnQpIHtcbiAgICAgICAgY2xpZW50LmRlZmF1bHRTZXJ2aWNlUGF0aCA9IHRoaXMuZGVmYXVsdFNlcnZpY2VQYXRoO1xuICAgICAgICBjbGllbnQudXNlSldUQWNjZXNzV2l0aFNjb3BlID0gdGhpcy51c2VKV1RBY2Nlc3NXaXRoU2NvcGU7XG4gICAgICAgIGNsaWVudC5kZWZhdWx0U2NvcGVzID0gdGhpcy5kZWZhdWx0U2NvcGVzO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0SWQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldFByb2plY3RJZEFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9qZWN0SWRBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgdGVtcG9yYXJ5IG1ldGhvZCBmb3IgaW50ZXJuYWwgYGdldFByb2plY3RJZGAgdXNhZ2VzIHdoZXJlIGBudWxsYCBpc1xuICAgICAqIGFjY2VwdGFibGUuIEluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UsIGBnZXRQcm9qZWN0SWRgIHNob3VsZCByZXR1cm4gYG51bGxgXG4gICAgICogKGFzIHRoZSBgUHJvbWlzZTxzdHJpbmcgfCBudWxsPmAgYmFzZSBzaWduYXR1cmUgZGVzY3JpYmVzKSBhbmQgdGhpcyBwcml2YXRlXG4gICAgICogbWV0aG9kIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggcHJvamVjdCBpZCAob3IgYG51bGxgKVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2plY3RJZE9wdGlvbmFsKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UHJvamVjdElkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPT09IEdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcy5OT19QUk9KRUNUX0lEX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICogQSBwcml2YXRlIG1ldGhvZCBmb3IgZmluZGluZyBhbmQgY2FjaGluZyBhIHByb2plY3RJZC5cbiAgICAgKlxuICAgICAqIFN1cHBvcnRzIGVudmlyb25tZW50cyBpbiBvcmRlciBvZiBwcmVjZWRlbmNlOlxuICAgICAqIC0gR0NMT1VEX1BST0pFQ1Qgb3IgR09PR0xFX0NMT1VEX1BST0pFQ1QgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgKiAtIEdPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMUyBKU09OIGZpbGVcbiAgICAgKiAtIENsb3VkIFNESzogYGdjbG91ZCBjb25maWcgY29uZmlnLWhlbHBlciAtLWZvcm1hdCBqc29uYFxuICAgICAqIC0gR0NFIHByb2plY3QgSUQgZnJvbSBtZXRhZGF0YSBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHByb2plY3RJZFxuICAgICAqL1xuICAgIGFzeW5jIGZpbmRBbmRDYWNoZVByb2plY3RJZCgpIHtcbiAgICAgICAgbGV0IHByb2plY3RJZCA9IG51bGw7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRQcm9kdWN0aW9uUHJvamVjdElkKCkpO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0RmlsZVByb2plY3RJZCgpKTtcbiAgICAgICAgcHJvamVjdElkIHx8IChwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldERlZmF1bHRTZXJ2aWNlUHJvamVjdElkKCkpO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0R0NFUHJvamVjdElkKCkpO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0RXh0ZXJuYWxBY2NvdW50Q2xpZW50UHJvamVjdElkKCkpO1xuICAgICAgICBpZiAocHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRQcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcy5OT19QUk9KRUNUX0lEX0ZPVU5EKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRQcm9qZWN0SWRBc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZFByb2plY3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2ZpbmRQcm9qZWN0SWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5kUHJvamVjdElkUHJvbWlzZSA9IHRoaXMuZmluZEFuZENhY2hlUHJvamVjdElkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRQcm9qZWN0SWRQcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBBbnkgc2NvcGVzICh1c2VyLXNwZWNpZmllZCBvciBkZWZhdWx0IHNjb3BlcyBzcGVjaWZpZWQgYnkgdGhlXG4gICAgICogICBjbGllbnQgbGlicmFyeSkgdGhhdCBuZWVkIHRvIGJlIHNldCBvbiB0aGUgY3VycmVudCBBdXRoIGNsaWVudC5cbiAgICAgKi9cbiAgICBnZXRBbnlTY29wZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlcyB8fCB0aGlzLmRlZmF1bHRTY29wZXM7XG4gICAgfVxuICAgIGdldEFwcGxpY2F0aW9uRGVmYXVsdChvcHRpb25zT3JDYWxsYmFjayA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zT3JDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QXBwbGljYXRpb25EZWZhdWx0QXN5bmMob3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIuY3JlZGVudGlhbCwgci5wcm9qZWN0SWQpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBcHBsaWNhdGlvbkRlZmF1bHRBc3luYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRBcHBsaWNhdGlvbkRlZmF1bHRBc3luYyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYSBjYWNoZWQgY3JlZGVudGlhbCwgcmV0dXJuIGl0LlxuICAgICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwcmVzZXJ2ZSBvbmUncyBjb25maWd1cmVkIHF1b3RhIHByb2plY3QsIGluIGNhc2UgdGhleVxuICAgICAgICAvLyBzZXQgb25lIGRpcmVjdGx5IG9uIHRoZSBjcmVkZW50aWFsIHByZXZpb3VzbHkuXG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENyZWRlbnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByZXBhcmVBbmRDYWNoZUFEQyh0aGlzLmNhY2hlZENyZWRlbnRpYWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSAnbmV3JyBBREMgdG8gY2FjaGUgd2Ugd2lsbCB1c2UgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgICAgIC8vIGlmIGl0J3MgYXZhaWxhYmxlLiBXZSBwcmVmZXIgdGhpcyB2YWx1ZSBvdmVyIHRoZSB2YWx1ZSBmcm9tIEFEQy5cbiAgICAgICAgY29uc3QgcXVvdGFQcm9qZWN0SWRPdmVycmlkZSA9IHByb2Nlc3MuZW52WydHT09HTEVfQ0xPVURfUVVPVEFfUFJPSkVDVCddO1xuICAgICAgICBsZXQgY3JlZGVudGlhbDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSBsb2NhbCBlbnZpcm9ubWVudCB2YXJpYWJsZSBwb2ludGluZyB0byB0aGVcbiAgICAgICAgLy8gbG9jYXRpb24gb2YgdGhlIGNyZWRlbnRpYWwgZmlsZS4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCBpbiBsb2NhbFxuICAgICAgICAvLyBkZXZlbG9wZXIgc2NlbmFyaW9zLlxuICAgICAgICBjcmVkZW50aWFsID1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRW52aXJvbm1lbnRWYXJpYWJsZShvcHRpb25zKTtcbiAgICAgICAgaWYgKGNyZWRlbnRpYWwpIHtcbiAgICAgICAgICAgIGlmIChjcmVkZW50aWFsIGluc3RhbmNlb2Ygand0Y2xpZW50XzEuSldUKSB7XG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbC5zY29wZXMgPSB0aGlzLnNjb3BlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNyZWRlbnRpYWwgaW5zdGFuY2VvZiBiYXNlZXh0ZXJuYWxjbGllbnRfMS5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50KSB7XG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbC5zY29wZXMgPSB0aGlzLmdldEFueVNjb3BlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJlcGFyZUFuZENhY2hlQURDKGNyZWRlbnRpYWwsIHF1b3RhUHJvamVjdElkT3ZlcnJpZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgaW4gdGhlIHdlbGwta25vd24gY3JlZGVudGlhbCBmaWxlIGxvY2F0aW9uLlxuICAgICAgICBjcmVkZW50aWFsID0gYXdhaXQgdGhpcy5fdHJ5R2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21XZWxsS25vd25GaWxlKG9wdGlvbnMpO1xuICAgICAgICBpZiAoY3JlZGVudGlhbCkge1xuICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWwgaW5zdGFuY2VvZiBqd3RjbGllbnRfMS5KV1QpIHtcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsLnNjb3BlcyA9IHRoaXMuc2NvcGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsLnNjb3BlcyA9IHRoaXMuZ2V0QW55U2NvcGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcmVwYXJlQW5kQ2FjaGVBREMoY3JlZGVudGlhbCwgcXVvdGFQcm9qZWN0SWRPdmVycmlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgb24gR0NFLlxuICAgICAgICBsZXQgaXNHQ0U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0dDRSA9IGF3YWl0IHRoaXMuX2NoZWNrSXNHQ0UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBVbmV4cGVjdGVkIGVycm9yIGRldGVybWluaW5nIGV4ZWN1dGlvbiBlbnZpcm9ubWVudDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0dDRSkge1xuICAgICAgICAgICAgLy8gV2UgZmFpbGVkIHRvIGZpbmQgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMuIEJhaWwgb3V0IHdpdGggYW4gZXJyb3IuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzLiBCcm93c2UgdG8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vZ2V0dGluZy1zdGFydGVkIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBHQ0UsIGp1c3QgcmV0dXJuIGEgZGVmYXVsdCBDb21wdXRlQ2xpZW50LiBJdCB3aWxsIHRha2UgY2FyZSBvZlxuICAgICAgICAvLyB0aGUgcmVzdC5cbiAgICAgICAgb3B0aW9ucy5zY29wZXMgPSB0aGlzLmdldEFueVNjb3BlcygpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcmVwYXJlQW5kQ2FjaGVBREMobmV3IGNvbXB1dGVjbGllbnRfMS5Db21wdXRlKG9wdGlvbnMpLCBxdW90YVByb2plY3RJZE92ZXJyaWRlKTtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZUFuZENhY2hlQURDKGNyZWRlbnRpYWwsIHF1b3RhUHJvamVjdElkT3ZlcnJpZGUpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRQcm9qZWN0SWRPcHRpb25hbCgpO1xuICAgICAgICBpZiAocXVvdGFQcm9qZWN0SWRPdmVycmlkZSkge1xuICAgICAgICAgICAgY3JlZGVudGlhbC5xdW90YVByb2plY3RJZCA9IHF1b3RhUHJvamVjdElkT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gY3JlZGVudGlhbDtcbiAgICAgICAgcmV0dXJuIHsgY3JlZGVudGlhbCwgcHJvamVjdElkIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYXV0aCBsYXllciBpcyBydW5uaW5nIG9uIEdvb2dsZSBDb21wdXRlIEVuZ2luZS5cbiAgICAgKiBDaGVja3MgZm9yIEdDUCBSZXNpZGVuY3ksIHRoZW4gZmFsbGJhY2sgdG8gY2hlY2tpbmcgaWYgbWV0YWRhdGEgc2VydmVyXG4gICAgICogaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYm9vbGVhbi5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfY2hlY2tJc0dDRSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tJc0dDRSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrSXNHQ0UgPVxuICAgICAgICAgICAgICAgIGdjcE1ldGFkYXRhLmdldEdDUFJlc2lkZW5jeSgpIHx8IChhd2FpdCBnY3BNZXRhZGF0YS5pc0F2YWlsYWJsZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0lzR0NFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBsb2FkIGRlZmF1bHQgY3JlZGVudGlhbHMgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgcGF0aC4uXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIE9BdXRoMkNsaWVudCBvciBudWxsLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUVudmlyb25tZW50VmFyaWFibGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjcmVkZW50aWFsc1BhdGggPSBwcm9jZXNzLmVudlsnR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTJ10gfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Wydnb29nbGVfYXBwbGljYXRpb25fY3JlZGVudGlhbHMnXTtcbiAgICAgICAgaWYgKCFjcmVkZW50aWFsc1BhdGggfHwgY3JlZGVudGlhbHNQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUZpbGVQYXRoKGNyZWRlbnRpYWxzUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgVW5hYmxlIHRvIHJlYWQgdGhlIGNyZWRlbnRpYWwgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIEdPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMUyBlbnZpcm9ubWVudCB2YXJpYWJsZTogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gbG9hZCBkZWZhdWx0IGNyZWRlbnRpYWxzIGZyb20gYSB3ZWxsLWtub3duIGZpbGUgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBPQXV0aDJDbGllbnQgb3IgbnVsbC5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfdHJ5R2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21XZWxsS25vd25GaWxlKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRmlyc3QsIGZpZ3VyZSBvdXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBmaWxlLCBkZXBlbmRpbmcgdXBvbiB0aGUgT1MgdHlwZS5cbiAgICAgICAgbGV0IGxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX2lzV2luZG93cygpKSB7XG4gICAgICAgICAgICAvLyBXaW5kb3dzXG4gICAgICAgICAgICBsb2NhdGlvbiA9IHByb2Nlc3MuZW52WydBUFBEQVRBJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBMaW51eCBvciBNYWNcbiAgICAgICAgICAgIGNvbnN0IGhvbWUgPSBwcm9jZXNzLmVudlsnSE9NRSddO1xuICAgICAgICAgICAgaWYgKGhvbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHBhdGguam9pbihob21lLCAnLmNvbmZpZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGZvdW5kIHRoZSByb290IHBhdGgsIGV4cGFuZCBpdC5cbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICBsb2NhdGlvbiA9IHBhdGguam9pbihsb2NhdGlvbiwgJ2djbG91ZCcsICdhcHBsaWNhdGlvbl9kZWZhdWx0X2NyZWRlbnRpYWxzLmpzb24nKTtcbiAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhsb2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZpbGUgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBmaWxlIHNlZW1zIHRvIGV4aXN0LiBUcnkgdG8gdXNlIGl0LlxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLl9nZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUZpbGVQYXRoKGxvY2F0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gbG9hZCBkZWZhdWx0IGNyZWRlbnRpYWxzIGZyb20gYSBmaWxlIGF0IHRoZSBnaXZlbiBwYXRoLi5cbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggVGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgT0F1dGgyQ2xpZW50XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2dldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRmlsZVBhdGgoZmlsZVBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhdGggbG9va3MgbGlrZSBhIHN0cmluZy5cbiAgICAgICAgaWYgKCFmaWxlUGF0aCB8fCBmaWxlUGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZpbGUgcGF0aCBpcyBpbnZhbGlkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBhIGZpbGUgYXQgdGhlIHBhdGguIGxzdGF0U3luYyB3aWxsIHRocm93IGlmIHRoZXJlIGlzXG4gICAgICAgIC8vIG5vdGhpbmcgdGhlcmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIHBhdGggdG8gYWN0dWFsIGZpbGUgaW4gY2FzZSBvZiBzeW1saW5rLiBFeHBlY3QgYSB0aHJvd24gZXJyb3JcbiAgICAgICAgICAgIC8vIGlmIG5vdCByZXNvbHZhYmxlLlxuICAgICAgICAgICAgZmlsZVBhdGggPSBmcy5yZWFscGF0aFN5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKCFmcy5sc3RhdFN5bmMoZmlsZVBhdGgpLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgVGhlIGZpbGUgYXQgJHtmaWxlUGF0aH0gZG9lcyBub3QgZXhpc3QsIG9yIGl0IGlzIG5vdCBhIGZpbGUuICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgb3BlbiBhIHJlYWQgc3RyZWFtIG9uIHRoZSBmaWxlLCBhbmQgcGFyc2UgaXQuXG4gICAgICAgIGNvbnN0IHJlYWRTdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVN0cmVhbShyZWFkU3RyZWFtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgYSBnaXZlbiBpbXBlcnNvbmF0ZWQgaW5wdXQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ganNvbiBUaGUgaW1wZXJzb25hdGVkIGlucHV0IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBKV1Qgb3IgVXNlclJlZnJlc2ggQ2xpZW50IHdpdGggZGF0YVxuICAgICAqL1xuICAgIGZyb21JbXBlcnNvbmF0ZWRKU09OKGpzb24pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyBhbiAgaW1wZXJzb25hdGVkIHJlZnJlc2ggdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlICE9PSBpbXBlcnNvbmF0ZWRfMS5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBoYXZlIHRoZSBcIiR7aW1wZXJzb25hdGVkXzEuSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRX1cIiB0eXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnNvdXJjZV9jcmVkZW50aWFscykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHNvdXJjZV9jcmVkZW50aWFscyBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5zZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBzZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgc291cmNlIGNsaWVudCBmb3IgaW1wZXJzb25hdGlvblxuICAgICAgICBjb25zdCBzb3VyY2VDbGllbnQgPSBuZXcgcmVmcmVzaGNsaWVudF8xLlVzZXJSZWZyZXNoQ2xpZW50KGpzb24uc291cmNlX2NyZWRlbnRpYWxzLmNsaWVudF9pZCwganNvbi5zb3VyY2VfY3JlZGVudGlhbHMuY2xpZW50X3NlY3JldCwganNvbi5zb3VyY2VfY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbik7XG4gICAgICAgIC8vIEV4dHJlYWN0IHNlcnZpY2UgYWNjb3VudCBmcm9tIHNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybFxuICAgICAgICBjb25zdCB0YXJnZXRQcmluY2lwYWwgPSAoX2IgPSAoX2EgPSAvKD88dGFyZ2V0PlteL10rKTpnZW5lcmF0ZUFjY2Vzc1Rva2VuJC8uZXhlYyhqc29uLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ncm91cHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50YXJnZXQ7XG4gICAgICAgIGlmICghdGFyZ2V0UHJpbmNpcGFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IGV4dHJhY3QgdGFyZ2V0IHByaW5jaXBhbCBmcm9tICR7anNvbi5zZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0U2NvcGVzID0gKF9jID0gdGhpcy5nZXRBbnlTY29wZXMoKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBpbXBlcnNvbmF0ZWRfMS5JbXBlcnNvbmF0ZWQoe1xuICAgICAgICAgICAgZGVsZWdhdGVzOiAoX2QgPSBqc29uLmRlbGVnYXRlcykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW10sXG4gICAgICAgICAgICBzb3VyY2VDbGllbnQ6IHNvdXJjZUNsaWVudCxcbiAgICAgICAgICAgIHRhcmdldFByaW5jaXBhbDogdGFyZ2V0UHJpbmNpcGFsLFxuICAgICAgICAgICAgdGFyZ2V0U2NvcGVzOiBBcnJheS5pc0FycmF5KHRhcmdldFNjb3BlcykgPyB0YXJnZXRTY29wZXMgOiBbdGFyZ2V0U2NvcGVzXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIHRoZSBnaXZlbiBpbnB1dCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbnB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIEpXVCBvciBVc2VyUmVmcmVzaCBvcHRpb25zIGZvciB0aGUgY2xpZW50XG4gICAgICogQHJldHVybnMgSldUIG9yIFVzZXJSZWZyZXNoIENsaWVudCB3aXRoIGRhdGFcbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChqc29uLnR5cGUgPT09IHJlZnJlc2hjbGllbnRfMS5VU0VSX1JFRlJFU0hfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgcmVmcmVzaGNsaWVudF8xLlVzZXJSZWZyZXNoQ2xpZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgY2xpZW50LmZyb21KU09OKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSA9PT0gaW1wZXJzb25hdGVkXzEuSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgY2xpZW50ID0gdGhpcy5mcm9tSW1wZXJzb25hdGVkSlNPTihqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uLnR5cGUgPT09IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgY2xpZW50ID0gZXh0ZXJuYWxjbGllbnRfMS5FeHRlcm5hbEFjY291bnRDbGllbnQuZnJvbUpTT04oanNvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjbGllbnQuc2NvcGVzID0gdGhpcy5nZXRBbnlTY29wZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uLnR5cGUgPT09IGV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50XzEuRVhURVJOQUxfQUNDT1VOVF9BVVRIT1JJWkVEX1VTRVJfVFlQRSkge1xuICAgICAgICAgICAgY2xpZW50ID0gbmV3IGV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50XzEuRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQoanNvbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlcyA9IHRoaXMuc2NvcGVzO1xuICAgICAgICAgICAgY2xpZW50ID0gbmV3IGp3dGNsaWVudF8xLkpXVChvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2V0R2FwaWNKV1RWYWx1ZXMoY2xpZW50KTtcbiAgICAgICAgICAgIGNsaWVudC5mcm9tSlNPTihqc29uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBKV1Qgb3IgVXNlclJlZnJlc2hDbGllbnQgZnJvbSBKYXZhU2NyaXB0IG9iamVjdCwgY2FjaGluZyBib3RoIHRoZVxuICAgICAqIG9iamVjdCB1c2VkIHRvIGluc3RhbnRpYXRlIGFuZCB0aGUgY2xpZW50LlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbnB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIEpXVCBvciBVc2VyUmVmcmVzaCBvcHRpb25zIGZvciB0aGUgY2xpZW50XG4gICAgICogQHJldHVybnMgSldUIG9yIFVzZXJSZWZyZXNoIENsaWVudCB3aXRoIGRhdGFcbiAgICAgKi9cbiAgICBfY2FjaGVDbGllbnRGcm9tSlNPTihqc29uLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZnJvbUpTT04oanNvbiwgb3B0aW9ucyk7XG4gICAgICAgIC8vIGNhY2hlIGJvdGggcmF3IGRhdGEgdXNlZCB0byBpbnN0YW50aWF0ZSBjbGllbnQgYW5kIGNsaWVudCBpdHNlbGYuXG4gICAgICAgIHRoaXMuanNvbkNvbnRlbnQgPSBqc29uO1xuICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBjbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIGZyb21TdHJlYW0oaW5wdXRTdHJlYW0sIG9wdGlvbnNPckNhbGxiYWNrID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSwgb3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIEdvb2dsZSBhdXRoIHNldHRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGlucHV0U3RyZWFtXG4gICAgICAgICAgICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC5vbignZGF0YScsIGNodW5rID0+IChzICs9IGNodW5rKSlcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fY2FjaGVDbGllbnRGcm9tSlNPTihkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGZhaWxlZCBwYXJzaW5nIHRoaXMua2V5RmlsZU5hbWUsIGFzc3VtZSB0aGF0IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBhIFBFTSBvciBwMTIgY2VydGlmaWNhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMua2V5RmlsZW5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGp3dGNsaWVudF8xLkpXVCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5jbGllbnRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUZpbGU6IHRoaXMua2V5RmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkQ3JlZGVudGlhbCA9IGNsaWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0R2FwaWNKV1RWYWx1ZXMoY2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGNsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyB0aGUgZ2l2ZW4gQVBJIGtleSBzdHJpbmcuXG4gICAgICogQHBhcmFtIGFwaUtleSBUaGUgQVBJIGtleSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBBIEpXVCBsb2FkZWQgZnJvbSB0aGUga2V5XG4gICAgICovXG4gICAgZnJvbUFQSUtleShhcGlLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBqd3RjbGllbnRfMS5KV1Qob3B0aW9ucyk7XG4gICAgICAgIGNsaWVudC5mcm9tQVBJS2V5KGFwaUtleSk7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgY3VycmVudCBvcGVyYXRpbmcgc3lzdGVtIGlzIFdpbmRvd3MuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgX2lzV2luZG93cygpIHtcbiAgICAgICAgY29uc3Qgc3lzID0gb3MucGxhdGZvcm0oKTtcbiAgICAgICAgaWYgKHN5cyAmJiBzeXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIGlmIChzeXMuc3Vic3RyaW5nKDAsIDMpLnRvTG93ZXJDYXNlKCkgPT09ICd3aW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIEdvb2dsZSBDbG91ZCBTREsgY29tbWFuZCB0aGF0IHByaW50cyB0aGUgZGVmYXVsdCBwcm9qZWN0IElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVmYXVsdFNlcnZpY2VQcm9qZWN0SWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICgwLCBjaGlsZF9wcm9jZXNzXzEuZXhlYykoJ2djbG91ZCBjb25maWcgY29uZmlnLWhlbHBlciAtLWZvcm1hdCBqc29uJywgKGVyciwgc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0SWQgPSBKU09OLnBhcnNlKHN0ZG91dCkuY29uZmlndXJhdGlvbi5wcm9wZXJ0aWVzLmNvcmUucHJvamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvamVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBwcm9qZWN0IGlkIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFByb2R1Y3Rpb25Qcm9qZWN0SWQoKSB7XG4gICAgICAgIHJldHVybiAocHJvY2Vzcy5lbnZbJ0dDTE9VRF9QUk9KRUNUJ10gfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52WydHT09HTEVfQ0xPVURfUFJPSkVDVCddIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudlsnZ2Nsb3VkX3Byb2plY3QnXSB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ2dvb2dsZV9jbG91ZF9wcm9qZWN0J10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgcHJvamVjdCBpZCBmcm9tIHRoZSBHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFMganNvbiBmaWxlLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVQcm9qZWN0SWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENyZWRlbnRpYWwpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byByZWFkIHRoZSBwcm9qZWN0IElEIGZyb20gdGhlIGNhY2hlZCBjcmVkZW50aWFscyBmaWxlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRDcmVkZW50aWFsLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHByb2plY3RJZCBpcyBsb2FkZWQgZnJvbSB0aGUga2V5RmlsZSBpZiBhdmFpbGFibGUuXG4gICAgICAgIGlmICh0aGlzLmtleUZpbGVuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgICAgICBpZiAoY3JlZHMgJiYgY3JlZHMucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWRzLnByb2plY3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gbG9hZCBhIGNyZWRlbnRpYWxzIGZpbGUgYW5kIHJlYWQgaXRzIHByb2plY3QgSURcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRW52aXJvbm1lbnRWYXJpYWJsZSgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHIucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvamVjdCBJRCBmcm9tIGV4dGVybmFsIGFjY291bnQgY2xpZW50IGlmIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRFeHRlcm5hbEFjY291bnRDbGllbnRQcm9qZWN0SWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5qc29uQ29udGVudCB8fCB0aGlzLmpzb25Db250ZW50LnR5cGUgIT09IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHVuZGVybHlpbmcgZXJyb3IsIGFzIHRoZSBlcnJvciBjb3VsZCBjb250YWluIGhlbHBmdWxcbiAgICAgICAgLy8gaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZyBhbmQgZml4aW5nLiBUaGlzIGlzIGVzcGVjaWFsbHkgdHJ1ZSBmb3JcbiAgICAgICAgLy8gZXh0ZXJuYWwgYWNjb3VudCBjcmVkcyBhcyBpbiBvcmRlciB0byBnZXQgdGhlIHByb2plY3QgSUQsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gb3BlcmF0aW9ucyBoYXZlIHRvIHN1Y2NlZWQ6XG4gICAgICAgIC8vIDEuIFZhbGlkIGNyZWRlbnRpYWxzIGZpbGUgc2hvdWxkIGJlIHN1cHBsaWVkLlxuICAgICAgICAvLyAyLiBBYmlsaXR5IHRvIHJldHJpZXZlIGFjY2VzcyB0b2tlbnMgZnJvbSBTVFMgdG9rZW4gZXhjaGFuZ2UgQVBJLlxuICAgICAgICAvLyAzLiBBYmlsaXR5IHRvIGV4Y2hhbmdlIGZvciBzZXJ2aWNlIGFjY291bnQgaW1wZXJzb25hdGVkIGNyZWRlbnRpYWxzIChpZlxuICAgICAgICAvLyAgICBlbmFibGVkKS5cbiAgICAgICAgLy8gNC4gQWJpbGl0eSB0byBnZXQgcHJvamVjdCBpbmZvIHVzaW5nIHRoZSBhY2Nlc3MgdG9rZW4gZnJvbSBzdGVwIDIgb3IgMy5cbiAgICAgICAgLy8gV2l0aG91dCBzdXJmYWNpbmcgdGhlIGVycm9yLCBpdCBpcyBoYXJkZXIgZm9yIGRldmVsb3BlcnMgdG8gZGV0ZXJtaW5lXG4gICAgICAgIC8vIHdoaWNoIHN0ZXAgd2VudCB3cm9uZy5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNyZWRzLmdldFByb2plY3RJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBDb21wdXRlIEVuZ2luZSBwcm9qZWN0IElEIGlmIGl0IGNhbiBiZSBpbmZlcnJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRHQ0VQcm9qZWN0SWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgZ2NwTWV0YWRhdGEucHJvamVjdCgncHJvamVjdC1pZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgZXJyb3JzXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDcmVkZW50aWFscyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3JlZGVudGlhbHNBc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3JlZGVudGlhbHNBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldENyZWRlbnRpYWxzQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGlmIChjbGllbnQgaW5zdGFuY2VvZiBiYXNlZXh0ZXJuYWxjbGllbnRfMS5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlQWNjb3VudEVtYWlsID0gY2xpZW50LmdldFNlcnZpY2VBY2NvdW50RW1haWwoKTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQWNjb3VudEVtYWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2xpZW50X2VtYWlsOiBzZXJ2aWNlQWNjb3VudEVtYWlsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuanNvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWRlbnRpYWwgPSB7XG4gICAgICAgICAgICAgICAgY2xpZW50X2VtYWlsOiB0aGlzLmpzb25Db250ZW50LmNsaWVudF9lbWFpbCxcbiAgICAgICAgICAgICAgICBwcml2YXRlX2tleTogdGhpcy5qc29uQ29udGVudC5wcml2YXRlX2tleSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY3JlZGVudGlhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0dDRSA9IGF3YWl0IHRoaXMuX2NoZWNrSXNHQ0UoKTtcbiAgICAgICAgaWYgKCFpc0dDRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVycm9yLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBHQ0UsIHJldHVybiB0aGUgc2VydmljZSBhY2NvdW50IGRldGFpbHMgZnJvbSB0aGUgbWV0YWRhdGEgc2VydmVyXG4gICAgICAgIC8vIE5PVEU6IFRoZSB0cmFpbGluZyAnLycgYXQgdGhlIGVuZCBvZiBzZXJ2aWNlLWFjY291bnRzLyBpcyB2ZXJ5IGltcG9ydGFudCFcbiAgICAgICAgLy8gVGhlIEdDRiBtZXRhZGF0YSBzZXJ2ZXIgZG9lc24ndCByZXNwZWN0IHF1ZXJ5c3RyaW5nIHBhcmFtcyBpZiB0aGlzIC8gaXNcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkLlxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2NwTWV0YWRhdGEuaW5zdGFuY2Uoe1xuICAgICAgICAgICAgcHJvcGVydHk6ICdzZXJ2aWNlLWFjY291bnRzLycsXG4gICAgICAgICAgICBwYXJhbXM6IHsgcmVjdXJzaXZlOiAndHJ1ZScgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5kZWZhdWx0IHx8ICFkYXRhLmRlZmF1bHQuZW1haWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbHVyZSBmcm9tIG1ldGFkYXRhIHNlcnZlci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjbGllbnRfZW1haWw6IGRhdGEuZGVmYXVsdC5lbWFpbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWNhbGx5IG9idGFpbiBhIGNsaWVudCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbi4gIElmIG5vXG4gICAgICogb3B0aW9ucyB3ZXJlIHBhc3NlZCwgdXNlIEFwcGxpY2F0aW9uIERlZmF1bHQgQ3JlZGVudGlhbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2xpZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuanNvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUNsaWVudEZyb21KU09OKHRoaXMuanNvbkNvbnRlbnQsIHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmtleUZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5rZXlGaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mcm9tU3RyZWFtQXN5bmMoc3RyZWFtLCB0aGlzLmNsaWVudE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRBcHBsaWNhdGlvbkRlZmF1bHRBc3luYyh0aGlzLmNsaWVudE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZENyZWRlbnRpYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbGllbnQgd2hpY2ggd2lsbCBmZXRjaCBhbiBJRCB0b2tlbiBmb3IgYXV0aG9yaXphdGlvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0QXVkaWVuY2UgdGhlIGF1ZGllbmNlIGZvciB0aGUgZmV0Y2hlZCBJRCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBJZFRva2VuQ2xpZW50IGZvciBtYWtpbmcgSFRUUCBjYWxscyBhdXRoZW50aWNhdGVkIHdpdGggSUQgdG9rZW5zLlxuICAgICAqL1xuICAgIGFzeW5jIGdldElkVG9rZW5DbGllbnQodGFyZ2V0QXVkaWVuY2UpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgaWYgKCEoJ2ZldGNoSWRUb2tlbicgaW4gY2xpZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmV0Y2ggSUQgdG9rZW4gaW4gdGhpcyBlbnZpcm9ubWVudCwgdXNlIEdDRSBvciBzZXQgdGhlIEdPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMUyBlbnZpcm9ubWVudCB2YXJpYWJsZSB0byBhIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFscyBKU09OIGZpbGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBpZHRva2VuY2xpZW50XzEuSWRUb2tlbkNsaWVudCh7IHRhcmdldEF1ZGllbmNlLCBpZFRva2VuUHJvdmlkZXI6IGNsaWVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBvYnRhaW4gYXBwbGljYXRpb24gZGVmYXVsdCBjcmVkZW50aWFscywgYW5kIHJldHVyblxuICAgICAqIGFuIGFjY2VzcyB0b2tlbiBmb3IgbWFraW5nIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICByZXR1cm4gKGF3YWl0IGNsaWVudC5nZXRBY2Nlc3NUb2tlbigpKS50b2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWluIHRoZSBIVFRQIGhlYWRlcnMgdGhhdCB3aWxsIHByb3ZpZGUgYXV0aG9yaXphdGlvbiBmb3IgYSBnaXZlblxuICAgICAqIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdEhlYWRlcnModXJsKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIHJldHVybiBjbGllbnQuZ2V0UmVxdWVzdEhlYWRlcnModXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWluIGNyZWRlbnRpYWxzIGZvciBhIHJlcXVlc3QsIHRoZW4gYXR0YWNoIHRoZSBhcHByb3ByaWF0ZSBoZWFkZXJzIHRvXG4gICAgICogdGhlIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0cyBBeGlvcyBvciBSZXF1ZXN0IG9wdGlvbnMgb24gd2hpY2ggdG8gYXR0YWNoIHRoZSBoZWFkZXJzXG4gICAgICovXG4gICAgYXN5bmMgYXV0aG9yaXplUmVxdWVzdChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBjb25zdCB1cmwgPSBvcHRzLnVybCB8fCBvcHRzLnVyaTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyh1cmwpO1xuICAgICAgICBvcHRzLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKG9wdHMuaGVhZGVycyB8fCB7fSwgaGVhZGVycyk7XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWNhbGx5IG9idGFpbiBhcHBsaWNhdGlvbiBkZWZhdWx0IGNyZWRlbnRpYWxzLCBhbmQgbWFrZSBhblxuICAgICAqIEhUVFAgcmVxdWVzdCB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0cyBBeGlvcyByZXF1ZXN0IG9wdGlvbnMgZm9yIHRoZSBIVFRQIHJlcXVlc3QuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyByZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5yZXF1ZXN0KG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGNvbXB1dGUgZW52aXJvbm1lbnQgaW4gd2hpY2ggdGhlIGNvZGUgaXMgcnVubmluZy5cbiAgICAgKi9cbiAgICBnZXRFbnYoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZW52RGV0ZWN0XzEuZ2V0RW52KSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhlIGN1cnJlbnQgcHJpdmF0ZSBrZXksIG9yIGdvIG91dFxuICAgICAqIHRvIHRoZSBJQU0gQVBJIHRvIHNpZ24gaXQuXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gYmUgc2lnbmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oZGF0YSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBjb25zdCBjcnlwdG8gPSAoMCwgY3J5cHRvXzEuY3JlYXRlQ3J5cHRvKSgpO1xuICAgICAgICBpZiAoY2xpZW50IGluc3RhbmNlb2Ygand0Y2xpZW50XzEuSldUICYmIGNsaWVudC5rZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ24gPSBhd2FpdCBjcnlwdG8uc2lnbihjbGllbnQua2V5LCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzaWduO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgdGhpcy5nZXRDcmVkZW50aWFscygpO1xuICAgICAgICBpZiAoIWNyZWRzLmNsaWVudF9lbWFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2lnbiBkYXRhIHdpdGhvdXQgYGNsaWVudF9lbWFpbGAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkJsb2IoY3J5cHRvLCBjcmVkcy5jbGllbnRfZW1haWwsIGRhdGEpO1xuICAgIH1cbiAgICBhc3luYyBzaWduQmxvYihjcnlwdG8sIGVtYWlsT3JVbmlxdWVJZCwgZGF0YSkge1xuICAgICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9pYW1jcmVkZW50aWFscy5nb29nbGVhcGlzLmNvbS92MS9wcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy8nICtcbiAgICAgICAgICAgIGAke2VtYWlsT3JVbmlxdWVJZH06c2lnbkJsb2JgO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogY3J5cHRvLmVuY29kZUJhc2U2NFN0cmluZ1V0ZjgoZGF0YSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnNpZ25lZEJsb2I7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVBdXRoID0gR29vZ2xlQXV0aDtcbi8qKlxuICogRXhwb3J0IERlZmF1bHRUcmFuc3BvcnRlciBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvZiB0aGUgY2xhc3MuXG4gKi9cbkdvb2dsZUF1dGguRGVmYXVsdFRyYW5zcG9ydGVyID0gdHJhbnNwb3J0ZXJzXzEuRGVmYXVsdFRyYW5zcG9ydGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z29vZ2xlYXV0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/googleauth.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/iam.js":
/*!*****************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/iam.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IAMAuth = void 0;\nclass IAMAuth {\n    /**\n     * IAM credentials.\n     *\n     * @param selector the iam authority selector\n     * @param token the token\n     * @constructor\n     */\n    constructor(selector, token) {\n        this.selector = selector;\n        this.token = token;\n        this.selector = selector;\n        this.token = token;\n    }\n    /**\n     * Acquire the HTTP headers required to make an authenticated request.\n     */\n    getRequestHeaders() {\n        return {\n            'x-goog-iam-authority-selector': this.selector,\n            'x-goog-iam-authorization-token': this.token,\n        };\n    }\n}\nexports.IAMAuth = IAMAuth;\n//# sourceMappingURL=iam.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvaWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvaWFtLmpzPzM2M2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSUFNQXV0aCA9IHZvaWQgMDtcbmNsYXNzIElBTUF1dGgge1xuICAgIC8qKlxuICAgICAqIElBTSBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciB0aGUgaWFtIGF1dGhvcml0eSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB0b2tlbiB0aGUgdG9rZW5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZWxlY3RvciwgdG9rZW4pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlIHRoZSBIVFRQIGhlYWRlcnMgcmVxdWlyZWQgdG8gbWFrZSBhbiBhdXRoZW50aWNhdGVkIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0UmVxdWVzdEhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAneC1nb29nLWlhbS1hdXRob3JpdHktc2VsZWN0b3InOiB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgJ3gtZ29vZy1pYW0tYXV0aG9yaXphdGlvbi10b2tlbic6IHRoaXMudG9rZW4sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5JQU1BdXRoID0gSUFNQXV0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlhbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/iam.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/identitypoolclient.js":
/*!********************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/identitypoolclient.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdentityPoolClient = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n// fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : (() => { }));\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : (() => { }));\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : (() => { }));\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiate an IdentityPoolClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid file-sourced or\n     * url-sourced credential or a workforce pool user project is provided\n     * with a non workforce audience.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        var _a, _b;\n        super(options, additionalOptions);\n        this.file = options.credential_source.file;\n        this.url = options.credential_source.url;\n        this.headers = options.credential_source.headers;\n        if (!this.file && !this.url) {\n            throw new Error('No valid Identity Pool \"credential_source\" provided');\n        }\n        // Text is the default format type.\n        this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || 'text';\n        this.formatSubjectTokenFieldName =\n            (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;\n        if (this.formatType !== 'json' && this.formatType !== 'text') {\n            throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n        }\n        if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\n            throw new Error('Missing subject_token_field_name for JSON credential_source format');\n        }\n    }\n    /**\n     * Triggered when a external subject token is needed to be exchanged for a GCP\n     * access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this either retrieves the local credential from a file location (k8s\n     * workload) or by sending a GET request to a local metadata server (Azure\n     * workloads).\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        if (this.file) {\n            return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\n        }\n        return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\n    }\n    /**\n     * Looks up the external subject token in the file path provided and\n     * resolves with that token.\n     * @param file The file path where the external credential is located.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @return A promise that resolves with the external subject token.\n     */\n    async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = await realpath(filePath);\n            if (!(await lstat(filePath)).isFile()) {\n                throw new Error();\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        let subjectToken;\n        const rawText = await readFile(filePath, { encoding: 'utf8' });\n        if (formatType === 'text') {\n            subjectToken = rawText;\n        }\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\n            const json = JSON.parse(rawText);\n            subjectToken = json[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error('Unable to parse the subject_token from the credential_source file');\n        }\n        return subjectToken;\n    }\n    /**\n     * Sends a GET request to the URL provided and resolves with the returned\n     * external subject token.\n     * @param url The URL to call to retrieve the subject token. This is typically\n     *   a local metadata server.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @param headers The optional additional headers to send with the request to\n     *   the metadata server url.\n     * @return A promise that resolves with the external subject token.\n     */\n    async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n        const opts = {\n            url,\n            method: 'GET',\n            headers,\n            responseType: formatType,\n        };\n        let subjectToken;\n        if (formatType === 'text') {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data;\n        }\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error('Unable to parse the subject_token from the credential_source URL');\n        }\n        return subjectToken;\n    }\n}\nexports.IdentityPoolClient = IdentityPoolClient;\n//# sourceMappingURL=identitypoolclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvaWRlbnRpdHlwb29sY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLDZCQUE2QixtQkFBTyxDQUFDLDRHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRyxxR0FBcUc7QUFDckcsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVUsdUNBQXVDLFlBQVk7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lkZW50aXR5cG9vbGNsaWVudC5qcz8yMTcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX2EsIF9iLCBfYztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSWRlbnRpdHlQb29sQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuLy8gZnMucmVhZGZpbGUgaXMgdW5kZWZpbmVkIGluIGJyb3dzZXIga2FybWEgdGVzdHMgY2F1c2luZ1xuLy8gYG5wbSBydW4gYnJvd3Nlci10ZXN0YCB0byBmYWlsIGFzIHRlc3Qub2F1dGgyLnRzIGltcG9ydHMgdGhpcyBmaWxlIHZpYVxuLy8gc3JjL2luZGV4LnRzLlxuLy8gRmFsbGJhY2sgdG8gdm9pZCBmdW5jdGlvbiB0byBhdm9pZCBwcm9taXNpZnkgdGhyb3dpbmcgYSBUeXBlRXJyb3IuXG5jb25zdCByZWFkRmlsZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSgoX2EgPSBmcy5yZWFkRmlsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCgpID0+IHsgfSkpO1xuY29uc3QgcmVhbHBhdGggPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoKF9iID0gZnMucmVhbHBhdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICgoKSA9PiB7IH0pKTtcbmNvbnN0IGxzdGF0ID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKChfYyA9IGZzLmxzdGF0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoKCkgPT4geyB9KSk7XG4vKipcbiAqIERlZmluZXMgdGhlIFVybC1zb3VyY2VkIGFuZCBmaWxlLXNvdXJjZWQgZXh0ZXJuYWwgYWNjb3VudCBjbGllbnRzIG1haW5seVxuICogdXNlZCBmb3IgSzhzIGFuZCBBenVyZSB3b3JrbG9hZHMuXG4gKi9cbmNsYXNzIElkZW50aXR5UG9vbENsaWVudCBleHRlbmRzIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGFuIElkZW50aXR5UG9vbENsaWVudCBpbnN0YW5jZSB1c2luZyB0aGUgcHJvdmlkZWQgSlNPTlxuICAgICAqIG9iamVjdCBsb2FkZWQgZnJvbSBhbiBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWxzIGZpbGUuXG4gICAgICogQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBjcmVkZW50aWFsIGlzIG5vdCBhIHZhbGlkIGZpbGUtc291cmNlZCBvclxuICAgICAqIHVybC1zb3VyY2VkIGNyZWRlbnRpYWwgb3IgYSB3b3JrZm9yY2UgcG9vbCB1c2VyIHByb2plY3QgaXMgcHJvdmlkZWRcbiAgICAgKiB3aXRoIGEgbm9uIHdvcmtmb3JjZSBhdWRpZW5jZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkXG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmZpbGUgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmZpbGU7XG4gICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS51cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuaGVhZGVycztcbiAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgIXRoaXMudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIElkZW50aXR5IFBvb2wgXCJjcmVkZW50aWFsX3NvdXJjZVwiIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGV4dCBpcyB0aGUgZGVmYXVsdCBmb3JtYXQgdHlwZS5cbiAgICAgICAgdGhpcy5mb3JtYXRUeXBlID0gKChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZm9ybWF0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgfHwgJ3RleHQnO1xuICAgICAgICB0aGlzLmZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSA9XG4gICAgICAgICAgICAoX2IgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmZvcm1hdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN1YmplY3RfdG9rZW5fZmllbGRfbmFtZTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0VHlwZSAhPT0gJ2pzb24nICYmIHRoaXMuZm9ybWF0VHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY3JlZGVudGlhbF9zb3VyY2UgZm9ybWF0IFwiJHt0aGlzLmZvcm1hdFR5cGV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb3JtYXRUeXBlID09PSAnanNvbicgJiYgIXRoaXMuZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc3ViamVjdF90b2tlbl9maWVsZF9uYW1lIGZvciBKU09OIGNyZWRlbnRpYWxfc291cmNlIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbiBpcyBuZWVkZWQgdG8gYmUgZXhjaGFuZ2VkIGZvciBhIEdDUFxuICAgICAqIGFjY2VzcyB0b2tlbiB2aWEgR0NQIFNUUyBlbmRwb2ludC5cbiAgICAgKiBUaGlzIHVzZXMgdGhlIGBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlYCBvYmplY3QgdG8gZmlndXJlIG91dCBob3dcbiAgICAgKiB0byByZXRyaWV2ZSB0aGUgdG9rZW4gdXNpbmcgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEluIHRoaXMgY2FzZSxcbiAgICAgKiB0aGlzIGVpdGhlciByZXRyaWV2ZXMgdGhlIGxvY2FsIGNyZWRlbnRpYWwgZnJvbSBhIGZpbGUgbG9jYXRpb24gKGs4c1xuICAgICAqIHdvcmtsb2FkKSBvciBieSBzZW5kaW5nIGEgR0VUIHJlcXVlc3QgdG8gYSBsb2NhbCBtZXRhZGF0YSBzZXJ2ZXIgKEF6dXJlXG4gICAgICogd29ya2xvYWRzKS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4dGVybmFsIHN1YmplY3QgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmV0cmlldmVTdWJqZWN0VG9rZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFRva2VuRnJvbUZpbGUodGhpcy5maWxlLCB0aGlzLmZvcm1hdFR5cGUsIHRoaXMuZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRUb2tlbkZyb21VcmwodGhpcy51cmwsIHRoaXMuZm9ybWF0VHlwZSwgdGhpcy5mb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUsIHRoaXMuaGVhZGVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIHRoZSBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGluIHRoZSBmaWxlIHBhdGggcHJvdmlkZWQgYW5kXG4gICAgICogcmVzb2x2ZXMgd2l0aCB0aGF0IHRva2VuLlxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHBhdGggd2hlcmUgdGhlIGV4dGVybmFsIGNyZWRlbnRpYWwgaXMgbG9jYXRlZC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0VHlwZSBUaGUgdG9rZW4gZmlsZSBvciBVUkwgcmVzcG9uc2UgdHlwZSAoSlNPTiBvciB0ZXh0KS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lIEZvciBKU09OIHJlc3BvbnNlIHR5cGVzLCB0aGlzIGlzIHRoZVxuICAgICAqICAgc3ViamVjdF90b2tlbiBmaWVsZCBuYW1lLiBGb3IgQXp1cmUsIHRoaXMgaXMgYWNjZXNzX3Rva2VuLiBGb3IgdGV4dFxuICAgICAqICAgcmVzcG9uc2UgdHlwZXMsIHRoaXMgaXMgaWdub3JlZC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4dGVybmFsIHN1YmplY3QgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VG9rZW5Gcm9tRmlsZShmaWxlUGF0aCwgZm9ybWF0VHlwZSwgZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBhIGZpbGUgYXQgdGhlIHBhdGguIGxzdGF0U3luYyB3aWxsIHRocm93IGlmIHRoZXJlIGlzXG4gICAgICAgIC8vIG5vdGhpbmcgdGhlcmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIHBhdGggdG8gYWN0dWFsIGZpbGUgaW4gY2FzZSBvZiBzeW1saW5rLiBFeHBlY3QgYSB0aHJvd24gZXJyb3JcbiAgICAgICAgICAgIC8vIGlmIG5vdCByZXNvbHZhYmxlLlxuICAgICAgICAgICAgZmlsZVBhdGggPSBhd2FpdCByZWFscGF0aChmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIShhd2FpdCBsc3RhdChmaWxlUGF0aCkpLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgVGhlIGZpbGUgYXQgJHtmaWxlUGF0aH0gZG9lcyBub3QgZXhpc3QsIG9yIGl0IGlzIG5vdCBhIGZpbGUuICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ViamVjdFRva2VuO1xuICAgICAgICBjb25zdCByYXdUZXh0ID0gYXdhaXQgcmVhZEZpbGUoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICAgICAgaWYgKGZvcm1hdFR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0gcmF3VGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAnanNvbicgJiYgZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShyYXdUZXh0KTtcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbiA9IGpzb25bZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YmplY3RUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgdGhlIHN1YmplY3RfdG9rZW4gZnJvbSB0aGUgY3JlZGVudGlhbF9zb3VyY2UgZmlsZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJqZWN0VG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgR0VUIHJlcXVlc3QgdG8gdGhlIFVSTCBwcm92aWRlZCBhbmQgcmVzb2x2ZXMgd2l0aCB0aGUgcmV0dXJuZWRcbiAgICAgKiBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byBjYWxsIHRvIHJldHJpZXZlIHRoZSBzdWJqZWN0IHRva2VuLiBUaGlzIGlzIHR5cGljYWxseVxuICAgICAqICAgYSBsb2NhbCBtZXRhZGF0YSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIGZvcm1hdFR5cGUgVGhlIHRva2VuIGZpbGUgb3IgVVJMIHJlc3BvbnNlIHR5cGUgKEpTT04gb3IgdGV4dCkuXG4gICAgICogQHBhcmFtIGZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSBGb3IgSlNPTiByZXNwb25zZSB0eXBlcywgdGhpcyBpcyB0aGVcbiAgICAgKiAgIHN1YmplY3RfdG9rZW4gZmllbGQgbmFtZS4gRm9yIEF6dXJlLCB0aGlzIGlzIGFjY2Vzc190b2tlbi4gRm9yIHRleHRcbiAgICAgKiAgIHJlc3BvbnNlIHR5cGVzLCB0aGlzIGlzIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIGhlYWRlcnMgVGhlIG9wdGlvbmFsIGFkZGl0aW9uYWwgaGVhZGVycyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QgdG9cbiAgICAgKiAgIHRoZSBtZXRhZGF0YSBzZXJ2ZXIgdXJsLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlbkZyb21VcmwodXJsLCBmb3JtYXRUeXBlLCBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBmb3JtYXRUeXBlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3ViamVjdFRva2VuO1xuICAgICAgICBpZiAoZm9ybWF0VHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbiA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9ybWF0VHlwZSA9PT0gJ2pzb24nICYmIGZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICBzdWJqZWN0VG9rZW4gPSByZXNwb25zZS5kYXRhW2Zvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdWJqZWN0VG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIHRoZSBzdWJqZWN0X3Rva2VuIGZyb20gdGhlIGNyZWRlbnRpYWxfc291cmNlIFVSTCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJqZWN0VG9rZW47XG4gICAgfVxufVxuZXhwb3J0cy5JZGVudGl0eVBvb2xDbGllbnQgPSBJZGVudGl0eVBvb2xDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGVudGl0eXBvb2xjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/identitypoolclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/idtokenclient.js":
/*!***************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/idtokenclient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdTokenClient = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(api)/../node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass IdTokenClient extends oauth2client_1.OAuth2Client {\n    /**\n     * Google ID Token client\n     *\n     * Retrieve access token from the metadata server.\n     * See: https://developers.google.com/compute/docs/authentication\n     */\n    constructor(options) {\n        super();\n        this.targetAudience = options.targetAudience;\n        this.idTokenProvider = options.idTokenProvider;\n    }\n    async getRequestMetadataAsync(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        if (!this.credentials.id_token ||\n            !this.credentials.expiry_date ||\n            this.isTokenExpiring()) {\n            const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);\n            this.credentials = {\n                id_token: idToken,\n                expiry_date: this.getIdTokenExpiryDate(idToken),\n            };\n        }\n        const headers = {\n            Authorization: 'Bearer ' + this.credentials.id_token,\n        };\n        return { headers };\n    }\n    getIdTokenExpiryDate(idToken) {\n        const payloadB64 = idToken.split('.')[1];\n        if (payloadB64) {\n            const payload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('ascii'));\n            return payload.exp * 1000;\n        }\n    }\n}\nexports.IdTokenClient = IdTokenClient;\n//# sourceMappingURL=idtokenclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvaWR0b2tlbmNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQix1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvaWR0b2tlbmNsaWVudC5qcz85MTkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklkVG9rZW5DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNsaWVudFwiKTtcbmNsYXNzIElkVG9rZW5DbGllbnQgZXh0ZW5kcyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBJRCBUb2tlbiBjbGllbnRcbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2ZXIuXG4gICAgICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jb21wdXRlL2RvY3MvYXV0aGVudGljYXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0QXVkaWVuY2UgPSBvcHRpb25zLnRhcmdldEF1ZGllbmNlO1xuICAgICAgICB0aGlzLmlkVG9rZW5Qcm92aWRlciA9IG9wdGlvbnMuaWRUb2tlblByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscy5pZF90b2tlbiB8fFxuICAgICAgICAgICAgIXRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgfHxcbiAgICAgICAgICAgIHRoaXMuaXNUb2tlbkV4cGlyaW5nKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLmlkVG9rZW5Qcm92aWRlci5mZXRjaElkVG9rZW4odGhpcy50YXJnZXRBdWRpZW5jZSk7XG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge1xuICAgICAgICAgICAgICAgIGlkX3Rva2VuOiBpZFRva2VuLFxuICAgICAgICAgICAgICAgIGV4cGlyeV9kYXRlOiB0aGlzLmdldElkVG9rZW5FeHBpcnlEYXRlKGlkVG9rZW4pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgdGhpcy5jcmVkZW50aWFscy5pZF90b2tlbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVycyB9O1xuICAgIH1cbiAgICBnZXRJZFRva2VuRXhwaXJ5RGF0ZShpZFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWRCNjQgPSBpZFRva2VuLnNwbGl0KCcuJylbMV07XG4gICAgICAgIGlmIChwYXlsb2FkQjY0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShwYXlsb2FkQjY0LCAnYmFzZTY0JykudG9TdHJpbmcoJ2FzY2lpJykpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQuZXhwICogMTAwMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSWRUb2tlbkNsaWVudCA9IElkVG9rZW5DbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZHRva2VuY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/idtokenclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/impersonated.js":
/*!**************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/impersonated.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(api)/../node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(api)/../node_modules/gaxios/build/src/index.js\");\nexports.IMPERSONATED_ACCOUNT_TYPE = 'impersonated_service_account';\nclass Impersonated extends oauth2client_1.OAuth2Client {\n    /**\n     * Impersonated service account credentials.\n     *\n     * Create a new access token by impersonating another service account.\n     *\n     * Impersonated Credentials allowing credentials issued to a user or\n     * service account to impersonate another. The source project using\n     * Impersonated Credentials must enable the \"IAMCredentials\" API.\n     * Also, the target service account must grant the orginating principal\n     * the \"Service Account Token Creator\" IAM role.\n     *\n     * @param {object} options - The configuration object.\n     * @param {object} [options.sourceClient] the source credential used as to\n     * acquire the impersonated credentials.\n     * @param {string} [options.targetPrincipal] the service account to\n     * impersonate.\n     * @param {string[]} [options.delegates] the chained list of delegates\n     * required to grant the final access_token. If set, the sequence of\n     * identities must have \"Service Account Token Creator\" capability granted to\n     * the preceding identity. For example, if set to [serviceAccountB,\n     * serviceAccountC], the sourceCredential must have the Token Creator role on\n     * serviceAccountB. serviceAccountB must have the Token Creator on\n     * serviceAccountC. Finally, C must have Token Creator on target_principal.\n     * If left unset, sourceCredential must have that role on targetPrincipal.\n     * @param {string[]} [options.targetScopes] scopes to request during the\n     * authorization grant.\n     * @param {number} [options.lifetime] number of seconds the delegated\n     * credential should be valid for up to 3600 seconds by default, or 43,200\n     * seconds by extending the token's lifetime, see:\n     * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth\n     * @param {string} [options.endpoint] api endpoint override.\n     */\n    constructor(options = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        super(options);\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: 'impersonated-placeholder',\n        };\n        this.sourceClient = (_a = options.sourceClient) !== null && _a !== void 0 ? _a : new oauth2client_1.OAuth2Client();\n        this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : '';\n        this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];\n        this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];\n        this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;\n        this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : 'https://iamcredentials.googleapis.com';\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */\n    async refreshToken(refreshToken) {\n        var _a, _b, _c, _d, _e, _f;\n        try {\n            await this.sourceClient.getAccessToken();\n            const name = 'projects/-/serviceAccounts/' + this.targetPrincipal;\n            const u = `${this.endpoint}/v1/${name}:generateAccessToken`;\n            const body = {\n                delegates: this.delegates,\n                scope: this.targetScopes,\n                lifetime: this.lifetime + 's',\n            };\n            const res = await this.sourceClient.request({\n                url: u,\n                data: body,\n                method: 'POST',\n            });\n            const tokenResponse = res.data;\n            this.credentials.access_token = tokenResponse.accessToken;\n            this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);\n            return {\n                tokens: this.credentials,\n                res,\n            };\n        }\n        catch (error) {\n            if (!(error instanceof Error))\n                throw error;\n            let status = 0;\n            let message = '';\n            if (error instanceof gaxios_1.GaxiosError) {\n                status = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;\n                message = (_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;\n            }\n            if (status && message) {\n                error.message = `${status}: unable to impersonate: ${message}`;\n                throw error;\n            }\n            else {\n                error.message = `unable to impersonate: ${error}`;\n                throw error;\n            }\n        }\n    }\n    /**\n     * Generates an OpenID Connect ID token for a service account.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}\n     *\n     * @param targetAudience the audience for the fetched ID token.\n     * @param options the for the request\n     * @return an OpenID Connect ID token\n     */\n    async fetchIdToken(targetAudience, options) {\n        var _a;\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:generateIdToken`;\n        const body = {\n            delegates: this.delegates,\n            audience: targetAudience,\n            includeEmail: (_a = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a !== void 0 ? _a : true,\n        };\n        const res = await this.sourceClient.request({\n            url: u,\n            data: body,\n            method: 'POST',\n        });\n        return res.data.token;\n    }\n}\nexports.Impersonated = Impersonated;\n//# sourceMappingURL=impersonated.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvaW1wZXJzb25hdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGlDQUFpQztBQUN4RCx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBZ0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsK0RBQVE7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWMsTUFBTSxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTywyQkFBMkIsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RSxxQkFBcUIsY0FBYyxNQUFNLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvaW1wZXJzb25hdGVkLmpzP2VhMDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkltcGVyc29uYXRlZCA9IGV4cG9ydHMuSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSA9IHZvaWQgMDtcbmNvbnN0IG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vb2F1dGgyY2xpZW50XCIpO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuZXhwb3J0cy5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFID0gJ2ltcGVyc29uYXRlZF9zZXJ2aWNlX2FjY291bnQnO1xuY2xhc3MgSW1wZXJzb25hdGVkIGV4dGVuZHMgb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbXBlcnNvbmF0ZWQgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFjY2VzcyB0b2tlbiBieSBpbXBlcnNvbmF0aW5nIGFub3RoZXIgc2VydmljZSBhY2NvdW50LlxuICAgICAqXG4gICAgICogSW1wZXJzb25hdGVkIENyZWRlbnRpYWxzIGFsbG93aW5nIGNyZWRlbnRpYWxzIGlzc3VlZCB0byBhIHVzZXIgb3JcbiAgICAgKiBzZXJ2aWNlIGFjY291bnQgdG8gaW1wZXJzb25hdGUgYW5vdGhlci4gVGhlIHNvdXJjZSBwcm9qZWN0IHVzaW5nXG4gICAgICogSW1wZXJzb25hdGVkIENyZWRlbnRpYWxzIG11c3QgZW5hYmxlIHRoZSBcIklBTUNyZWRlbnRpYWxzXCIgQVBJLlxuICAgICAqIEFsc28sIHRoZSB0YXJnZXQgc2VydmljZSBhY2NvdW50IG11c3QgZ3JhbnQgdGhlIG9yZ2luYXRpbmcgcHJpbmNpcGFsXG4gICAgICogdGhlIFwiU2VydmljZSBBY2NvdW50IFRva2VuIENyZWF0b3JcIiBJQU0gcm9sZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5zb3VyY2VDbGllbnRdIHRoZSBzb3VyY2UgY3JlZGVudGlhbCB1c2VkIGFzIHRvXG4gICAgICogYWNxdWlyZSB0aGUgaW1wZXJzb25hdGVkIGNyZWRlbnRpYWxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50YXJnZXRQcmluY2lwYWxdIHRoZSBzZXJ2aWNlIGFjY291bnQgdG9cbiAgICAgKiBpbXBlcnNvbmF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5kZWxlZ2F0ZXNdIHRoZSBjaGFpbmVkIGxpc3Qgb2YgZGVsZWdhdGVzXG4gICAgICogcmVxdWlyZWQgdG8gZ3JhbnQgdGhlIGZpbmFsIGFjY2Vzc190b2tlbi4gSWYgc2V0LCB0aGUgc2VxdWVuY2Ugb2ZcbiAgICAgKiBpZGVudGl0aWVzIG11c3QgaGF2ZSBcIlNlcnZpY2UgQWNjb3VudCBUb2tlbiBDcmVhdG9yXCIgY2FwYWJpbGl0eSBncmFudGVkIHRvXG4gICAgICogdGhlIHByZWNlZGluZyBpZGVudGl0eS4gRm9yIGV4YW1wbGUsIGlmIHNldCB0byBbc2VydmljZUFjY291bnRCLFxuICAgICAqIHNlcnZpY2VBY2NvdW50Q10sIHRoZSBzb3VyY2VDcmVkZW50aWFsIG11c3QgaGF2ZSB0aGUgVG9rZW4gQ3JlYXRvciByb2xlIG9uXG4gICAgICogc2VydmljZUFjY291bnRCLiBzZXJ2aWNlQWNjb3VudEIgbXVzdCBoYXZlIHRoZSBUb2tlbiBDcmVhdG9yIG9uXG4gICAgICogc2VydmljZUFjY291bnRDLiBGaW5hbGx5LCBDIG11c3QgaGF2ZSBUb2tlbiBDcmVhdG9yIG9uIHRhcmdldF9wcmluY2lwYWwuXG4gICAgICogSWYgbGVmdCB1bnNldCwgc291cmNlQ3JlZGVudGlhbCBtdXN0IGhhdmUgdGhhdCByb2xlIG9uIHRhcmdldFByaW5jaXBhbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy50YXJnZXRTY29wZXNdIHNjb3BlcyB0byByZXF1ZXN0IGR1cmluZyB0aGVcbiAgICAgKiBhdXRob3JpemF0aW9uIGdyYW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saWZldGltZV0gbnVtYmVyIG9mIHNlY29uZHMgdGhlIGRlbGVnYXRlZFxuICAgICAqIGNyZWRlbnRpYWwgc2hvdWxkIGJlIHZhbGlkIGZvciB1cCB0byAzNjAwIHNlY29uZHMgYnkgZGVmYXVsdCwgb3IgNDMsMjAwXG4gICAgICogc2Vjb25kcyBieSBleHRlbmRpbmcgdGhlIHRva2VuJ3MgbGlmZXRpbWUsIHNlZTpcbiAgICAgKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWFtL2RvY3MvY3JlYXRpbmctc2hvcnQtbGl2ZWQtc2VydmljZS1hY2NvdW50LWNyZWRlbnRpYWxzI3NhLWNyZWRlbnRpYWxzLW9hdXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuZHBvaW50XSBhcGkgZW5kcG9pbnQgb3ZlcnJpZGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHtcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiAxLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogJ2ltcGVyc29uYXRlZC1wbGFjZWhvbGRlcicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc291cmNlQ2xpZW50ID0gKF9hID0gb3B0aW9ucy5zb3VyY2VDbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQoKTtcbiAgICAgICAgdGhpcy50YXJnZXRQcmluY2lwYWwgPSAoX2IgPSBvcHRpb25zLnRhcmdldFByaW5jaXBhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVzID0gKF9jID0gb3B0aW9ucy5kZWxlZ2F0ZXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgICAgICB0aGlzLnRhcmdldFNjb3BlcyA9IChfZCA9IG9wdGlvbnMudGFyZ2V0U2NvcGVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXTtcbiAgICAgICAgdGhpcy5saWZldGltZSA9IChfZSA9IG9wdGlvbnMubGlmZXRpbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDM2MDA7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSAoX2YgPSBvcHRpb25zLmVuZHBvaW50KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAnaHR0cHM6Ly9pYW1jcmVkZW50aWFscy5nb29nbGVhcGlzLmNvbSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gVW51c2VkIHBhcmFtZXRlclxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNvdXJjZUNsaWVudC5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9ICdwcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy8nICsgdGhpcy50YXJnZXRQcmluY2lwYWw7XG4gICAgICAgICAgICBjb25zdCB1ID0gYCR7dGhpcy5lbmRwb2ludH0vdjEvJHtuYW1lfTpnZW5lcmF0ZUFjY2Vzc1Rva2VuYDtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGVzOiB0aGlzLmRlbGVnYXRlcyxcbiAgICAgICAgICAgICAgICBzY29wZTogdGhpcy50YXJnZXRTY29wZXMsXG4gICAgICAgICAgICAgICAgbGlmZXRpbWU6IHRoaXMubGlmZXRpbWUgKyAncycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zb3VyY2VDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1LFxuICAgICAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSByZXMuZGF0YTtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuID0gdG9rZW5SZXNwb25zZS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgPSBEYXRlLnBhcnNlKHRva2VuUmVzcG9uc2UuZXhwaXJlVGltZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5jcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBsZXQgc3RhdHVzID0gMDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvcikge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IChfYyA9IChfYiA9IChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lcnJvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0YXR1cztcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gKF9mID0gKF9lID0gKF9kID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGF0YSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmVycm9yKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgJHtzdGF0dXN9OiB1bmFibGUgdG8gaW1wZXJzb25hdGU6ICR7bWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGB1bmFibGUgdG8gaW1wZXJzb25hdGU6ICR7ZXJyb3J9YDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gT3BlbklEIENvbm5lY3QgSUQgdG9rZW4gZm9yIGEgc2VydmljZSBhY2NvdW50LlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pYW0vZG9jcy9yZWZlcmVuY2UvY3JlZGVudGlhbHMvcmVzdC92MS9wcm9qZWN0cy5zZXJ2aWNlQWNjb3VudHMvZ2VuZXJhdGVJZFRva2VuIFJlZmVyZW5jZSBEb2N1bWVudGF0aW9ufVxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldEF1ZGllbmNlIHRoZSBhdWRpZW5jZSBmb3IgdGhlIGZldGNoZWQgSUQgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEByZXR1cm4gYW4gT3BlbklEIENvbm5lY3QgSUQgdG9rZW5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaElkVG9rZW4odGFyZ2V0QXVkaWVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhd2FpdCB0aGlzLnNvdXJjZUNsaWVudC5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCBuYW1lID0gYHByb2plY3RzLy0vc2VydmljZUFjY291bnRzLyR7dGhpcy50YXJnZXRQcmluY2lwYWx9YDtcbiAgICAgICAgY29uc3QgdSA9IGAke3RoaXMuZW5kcG9pbnR9L3YxLyR7bmFtZX06Z2VuZXJhdGVJZFRva2VuYDtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGRlbGVnYXRlczogdGhpcy5kZWxlZ2F0ZXMsXG4gICAgICAgICAgICBhdWRpZW5jZTogdGFyZ2V0QXVkaWVuY2UsXG4gICAgICAgICAgICBpbmNsdWRlRW1haWw6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbmNsdWRlRW1haWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiB1LFxuICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuSW1wZXJzb25hdGVkID0gSW1wZXJzb25hdGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1wZXJzb25hdGVkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/impersonated.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/jwtaccess.js":
/*!***********************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/jwtaccess.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JWTAccess = void 0;\nconst jws = __webpack_require__(/*! jws */ \"(api)/../node_modules/jws/index.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"lru-cache\");\nconst DEFAULT_HEADER = {\n    alg: 'RS256',\n    typ: 'JWT',\n};\nclass JWTAccess {\n    /**\n     * JWTAccess service account credentials.\n     *\n     * Create a new access token by using the credential to create a new JWT token\n     * that's recognized as the access token.\n     *\n     * @param email the service account email address.\n     * @param key the private key that will be used to sign the token.\n     * @param keyId the ID of the private key used to sign the token.\n     */\n    constructor(email, key, keyId, eagerRefreshThresholdMillis) {\n        this.cache = new LRU({\n            max: 500,\n            maxAge: 60 * 60 * 1000,\n        });\n        this.email = email;\n        this.key = key;\n        this.keyId = keyId;\n        this.eagerRefreshThresholdMillis =\n            eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\n    }\n    /**\n     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\n     *\n     * @param url The URI being authorized.\n     * @param scopes The scope or scopes being authorized\n     * @returns A string that returns the cached key.\n     */\n    getCachedKey(url, scopes) {\n        let cacheKey = url;\n        if (scopes && Array.isArray(scopes) && scopes.length) {\n            cacheKey = url ? `${url}_${scopes.join('_')}` : `${scopes.join('_')}`;\n        }\n        else if (typeof scopes === 'string') {\n            cacheKey = url ? `${url}_${scopes}` : scopes;\n        }\n        if (!cacheKey) {\n            throw Error('Scopes or url must be provided');\n        }\n        return cacheKey;\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param url The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @returns An object that includes the authorization header.\n     */\n    getRequestHeaders(url, additionalClaims, scopes) {\n        // Return cached authorization headers, unless we are within\n        // eagerRefreshThresholdMillis ms of them expiring:\n        const key = this.getCachedKey(url, scopes);\n        const cachedToken = this.cache.get(key);\n        const now = Date.now();\n        if (cachedToken &&\n            cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\n            return cachedToken.headers;\n        }\n        const iat = Math.floor(Date.now() / 1000);\n        const exp = JWTAccess.getExpirationTime(iat);\n        let defaultClaims;\n        // Turn scopes into space-separated string\n        if (Array.isArray(scopes)) {\n            scopes = scopes.join(' ');\n        }\n        // If scopes are specified, sign with scopes\n        if (scopes) {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                scope: scopes,\n                exp,\n                iat,\n            };\n        }\n        else {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                aud: url,\n                exp,\n                iat,\n            };\n        }\n        // if additionalClaims are provided, ensure they do not collide with\n        // other required claims.\n        if (additionalClaims) {\n            for (const claim in defaultClaims) {\n                if (additionalClaims[claim]) {\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n                }\n            }\n        }\n        const header = this.keyId\n            ? { ...DEFAULT_HEADER, kid: this.keyId }\n            : DEFAULT_HEADER;\n        const payload = Object.assign(defaultClaims, additionalClaims);\n        // Sign the jwt and add it to the cache\n        const signedJWT = jws.sign({ header, payload, secret: this.key });\n        const headers = { Authorization: `Bearer ${signedJWT}` };\n        this.cache.set(key, {\n            expiration: exp * 1000,\n            headers,\n        });\n        return headers;\n    }\n    /**\n     * Returns an expiration time for the JWT token.\n     *\n     * @param iat The issued at time for the JWT.\n     * @returns An expiration time for the JWT.\n     */\n    static getExpirationTime(iat) {\n        const exp = iat + 3600; // 3600 seconds = 1 hour\n        return exp;\n    }\n    /**\n     * Create a JWTAccess credentials instance using the given input options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\n        }\n        if (!json.client_email) {\n            throw new Error('The incoming JSON object does not contain a client_email field');\n        }\n        if (!json.private_key) {\n            throw new Error('The incoming JSON object does not contain a private_key field');\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                reject(new Error('Must pass in a stream containing the service account auth settings.'));\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('data', chunk => (s += chunk))\n                .on('error', reject)\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                }\n                catch (err) {\n                    reject(err);\n                }\n            });\n        });\n    }\n}\nexports.JWTAccess = JWTAccess;\n//# sourceMappingURL=jwtaccess.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvand0YWNjZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLFlBQVksbUJBQU8sQ0FBQywrQ0FBSztBQUN6QixZQUFZLG1CQUFPLENBQUMsNEJBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSSxHQUFHLGlCQUFpQixPQUFPLGlCQUFpQjtBQUNoRjtBQUNBO0FBQ0EsZ0NBQWdDLElBQUksR0FBRyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1DQUFtQztBQUN4RSwwQkFBMEIseUJBQXlCLFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvand0YWNjZXNzLmpzP2U4MWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSldUQWNjZXNzID0gdm9pZCAwO1xuY29uc3QgandzID0gcmVxdWlyZShcImp3c1wiKTtcbmNvbnN0IExSVSA9IHJlcXVpcmUoXCJscnUtY2FjaGVcIik7XG5jb25zdCBERUZBVUxUX0hFQURFUiA9IHtcbiAgICBhbGc6ICdSUzI1NicsXG4gICAgdHlwOiAnSldUJyxcbn07XG5jbGFzcyBKV1RBY2Nlc3Mge1xuICAgIC8qKlxuICAgICAqIEpXVEFjY2VzcyBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgYWNjZXNzIHRva2VuIGJ5IHVzaW5nIHRoZSBjcmVkZW50aWFsIHRvIGNyZWF0ZSBhIG5ldyBKV1QgdG9rZW5cbiAgICAgKiB0aGF0J3MgcmVjb2duaXplZCBhcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYWlsIHRoZSBzZXJ2aWNlIGFjY291bnQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ga2V5IHRoZSBwcml2YXRlIGtleSB0aGF0IHdpbGwgYmUgdXNlZCB0byBzaWduIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ga2V5SWQgdGhlIElEIG9mIHRoZSBwcml2YXRlIGtleSB1c2VkIHRvIHNpZ24gdGhlIHRva2VuLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVtYWlsLCBrZXksIGtleUlkLCBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBMUlUoe1xuICAgICAgICAgICAgbWF4OiA1MDAsXG4gICAgICAgICAgICBtYXhBZ2U6IDYwICogNjAgKiAxMDAwLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWFpbCA9IGVtYWlsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGtleUlkO1xuICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9XG4gICAgICAgICAgICBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgIT09IG51bGwgJiYgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzICE9PSB2b2lkIDAgPyBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgOiA1ICogNjAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgd2UncmUgY2FjaGluZyBhIGtleSBhcHByb3ByaWF0ZWx5LCBnaXZpbmcgcHJlY2VkZW5jZSB0byBzY29wZXMgdnMuIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICogQHBhcmFtIHNjb3BlcyBUaGUgc2NvcGUgb3Igc2NvcGVzIGJlaW5nIGF1dGhvcml6ZWRcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyB0aGF0IHJldHVybnMgdGhlIGNhY2hlZCBrZXkuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkS2V5KHVybCwgc2NvcGVzKSB7XG4gICAgICAgIGxldCBjYWNoZUtleSA9IHVybDtcbiAgICAgICAgaWYgKHNjb3BlcyAmJiBBcnJheS5pc0FycmF5KHNjb3BlcykgJiYgc2NvcGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FjaGVLZXkgPSB1cmwgPyBgJHt1cmx9XyR7c2NvcGVzLmpvaW4oJ18nKX1gIDogYCR7c2NvcGVzLmpvaW4oJ18nKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY29wZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYWNoZUtleSA9IHVybCA/IGAke3VybH1fJHtzY29wZXN9YCA6IHNjb3BlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhY2hlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU2NvcGVzIG9yIHVybCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBub24tZXhwaXJlZCBhY2Nlc3MgdG9rZW4sIGFmdGVyIHJlZnJlc2hpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDbGFpbXMgQW4gb2JqZWN0IHdpdGggYSBzZXQgb2YgYWRkaXRpb25hbCBjbGFpbXMgdG9cbiAgICAgKiBpbmNsdWRlIGluIHRoZSBwYXlsb2FkLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlci5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SGVhZGVycyh1cmwsIGFkZGl0aW9uYWxDbGFpbXMsIHNjb3Blcykge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGF1dGhvcml6YXRpb24gaGVhZGVycywgdW5sZXNzIHdlIGFyZSB3aXRoaW5cbiAgICAgICAgLy8gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIG1zIG9mIHRoZW0gZXhwaXJpbmc6XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0Q2FjaGVkS2V5KHVybCwgc2NvcGVzKTtcbiAgICAgICAgY29uc3QgY2FjaGVkVG9rZW4gPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoY2FjaGVkVG9rZW4gJiZcbiAgICAgICAgICAgIGNhY2hlZFRva2VuLmV4cGlyYXRpb24gLSBub3cgPiB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRva2VuLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWF0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IGV4cCA9IEpXVEFjY2Vzcy5nZXRFeHBpcmF0aW9uVGltZShpYXQpO1xuICAgICAgICBsZXQgZGVmYXVsdENsYWltcztcbiAgICAgICAgLy8gVHVybiBzY29wZXMgaW50byBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjb3BlcykpIHtcbiAgICAgICAgICAgIHNjb3BlcyA9IHNjb3Blcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc2NvcGVzIGFyZSBzcGVjaWZpZWQsIHNpZ24gd2l0aCBzY29wZXNcbiAgICAgICAgaWYgKHNjb3Blcykge1xuICAgICAgICAgICAgZGVmYXVsdENsYWltcyA9IHtcbiAgICAgICAgICAgICAgICBpc3M6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgc3ViOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBzY29wZXMsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGlhdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2xhaW1zID0ge1xuICAgICAgICAgICAgICAgIGlzczogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgICAgICBzdWI6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgYXVkOiB1cmwsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGlhdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWRkaXRpb25hbENsYWltcyBhcmUgcHJvdmlkZWQsIGVuc3VyZSB0aGV5IGRvIG5vdCBjb2xsaWRlIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgcmVxdWlyZWQgY2xhaW1zLlxuICAgICAgICBpZiAoYWRkaXRpb25hbENsYWltcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjbGFpbSBpbiBkZWZhdWx0Q2xhaW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDbGFpbXNbY2xhaW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke2NsYWltfScgcHJvcGVydHkgaXMgbm90IGFsbG93ZWQgd2hlbiBwYXNzaW5nIGFkZGl0aW9uYWxDbGFpbXMuIFRoaXMgY2xhaW0gaXMgaW5jbHVkZWQgaW4gdGhlIEpXVCBieSBkZWZhdWx0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLmtleUlkXG4gICAgICAgICAgICA/IHsgLi4uREVGQVVMVF9IRUFERVIsIGtpZDogdGhpcy5rZXlJZCB9XG4gICAgICAgICAgICA6IERFRkFVTFRfSEVBREVSO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0Q2xhaW1zLCBhZGRpdGlvbmFsQ2xhaW1zKTtcbiAgICAgICAgLy8gU2lnbiB0aGUgand0IGFuZCBhZGQgaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IHNpZ25lZEpXVCA9IGp3cy5zaWduKHsgaGVhZGVyLCBwYXlsb2FkLCBzZWNyZXQ6IHRoaXMua2V5IH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7c2lnbmVkSldUfWAgfTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICBleHBpcmF0aW9uOiBleHAgKiAxMDAwLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpXVCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpYXQgVGhlIGlzc3VlZCBhdCB0aW1lIGZvciB0aGUgSldULlxuICAgICAqIEByZXR1cm5zIEFuIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpXVC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RXhwaXJhdGlvblRpbWUoaWF0KSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGlhdCArIDM2MDA7IC8vIDM2MDAgc2Vjb25kcyA9IDEgaG91clxuICAgICAgICByZXR1cm4gZXhwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBKV1RBY2Nlc3MgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJ2aWNlIGFjY291bnQgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2VtYWlsIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcHJpdmF0ZV9rZXkgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBqc29uIGtleSBmaWxlLlxuICAgICAgICB0aGlzLmVtYWlsID0ganNvbi5jbGllbnRfZW1haWw7XG4gICAgICAgIHRoaXMua2V5ID0ganNvbi5wcml2YXRlX2tleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGpzb24ucHJpdmF0ZV9rZXlfaWQ7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0ganNvbi5wcm9qZWN0X2lkO1xuICAgIH1cbiAgICBmcm9tU3RyZWFtKGlucHV0U3RyZWFtLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKS50aGVuKCgpID0+IGNhbGxiYWNrKCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbVxuICAgICAgICAgICAgICAgIC5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5KV1RBY2Nlc3MgPSBKV1RBY2Nlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qd3RhY2Nlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/jwtaccess.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/jwtclient.js":
/*!***********************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/jwtclient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JWT = void 0;\nconst gtoken_1 = __webpack_require__(/*! gtoken */ \"(api)/../node_modules/gtoken/build/src/index.js\");\nconst jwtaccess_1 = __webpack_require__(/*! ./jwtaccess */ \"(api)/../node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(api)/../node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass JWT extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {\n        const opts = optionsOrEmail && typeof optionsOrEmail === 'object'\n            ? optionsOrEmail\n            : { email: optionsOrEmail, keyFile, key, keyId, scopes, subject };\n        super({\n            eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,\n            forceRefreshOnFailure: opts.forceRefreshOnFailure,\n        });\n        this.email = opts.email;\n        this.keyFile = opts.keyFile;\n        this.key = opts.key;\n        this.keyId = opts.keyId;\n        this.scopes = opts.scopes;\n        this.subject = opts.subject;\n        this.additionalClaims = opts.additionalClaims;\n        this.credentials = { refresh_token: 'jwt-placeholder', expiry_date: 1 };\n    }\n    /**\n     * Creates a copy of the credential with the specified scopes.\n     * @param scopes List of requested scopes or a single scope.\n     * @return The cloned instance.\n     */\n    createScoped(scopes) {\n        return new JWT({\n            email: this.email,\n            keyFile: this.keyFile,\n            key: this.key,\n            keyId: this.keyId,\n            scopes,\n            subject: this.subject,\n            additionalClaims: this.additionalClaims,\n        });\n    }\n    /**\n     * Obtains the metadata to be sent with the request.\n     *\n     * @param url the URI being authorized.\n     */\n    async getRequestMetadataAsync(url) {\n        url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;\n        const useSelfSignedJWT = (!this.hasUserScopes() && url) ||\n            (this.useJWTAccessWithScope && this.hasAnyScopes());\n        if (!this.apiKey && useSelfSignedJWT) {\n            if (this.additionalClaims &&\n                this.additionalClaims.target_audience) {\n                const { tokens } = await this.refreshToken();\n                return {\n                    headers: this.addSharedMetadataHeaders({\n                        Authorization: `Bearer ${tokens.id_token}`,\n                    }),\n                };\n            }\n            else {\n                // no scopes have been set, but a uri has been provided. Use JWTAccess\n                // credentials.\n                if (!this.access) {\n                    this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);\n                }\n                let scopes;\n                if (this.hasUserScopes()) {\n                    scopes = this.scopes;\n                }\n                else if (!url) {\n                    scopes = this.defaultScopes;\n                }\n                const headers = await this.access.getRequestHeaders(url !== null && url !== void 0 ? url : undefined, this.additionalClaims, \n                // Scopes take precedent over audience for signing,\n                // so we only provide them if useJWTAccessWithScope is on\n                this.useJWTAccessWithScope ? scopes : undefined);\n                return { headers: this.addSharedMetadataHeaders(headers) };\n            }\n        }\n        else if (this.hasAnyScopes() || this.apiKey) {\n            return super.getRequestMetadataAsync(url);\n        }\n        else {\n            // If no audience, apiKey, or scopes are provided, we should not attempt\n            // to populate any headers:\n            return { headers: {} };\n        }\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */\n    async fetchIdToken(targetAudience) {\n        // Create a new gToken for fetching an ID token\n        const gtoken = new gtoken_1.GoogleToken({\n            iss: this.email,\n            sub: this.subject,\n            scope: this.scopes || this.defaultScopes,\n            keyFile: this.keyFile,\n            key: this.key,\n            additionalClaims: { target_audience: targetAudience },\n            transporter: this.transporter,\n        });\n        await gtoken.getToken({\n            forceRefresh: true,\n        });\n        if (!gtoken.idToken) {\n            throw new Error('Unknown error: Failed to fetch ID token');\n        }\n        return gtoken.idToken;\n    }\n    /**\n     * Determine if there are currently scopes available.\n     */\n    hasUserScopes() {\n        if (!this.scopes) {\n            return false;\n        }\n        return this.scopes.length > 0;\n    }\n    /**\n     * Are there any default or user scopes defined.\n     */\n    hasAnyScopes() {\n        if (this.scopes && this.scopes.length > 0)\n            return true;\n        if (this.defaultScopes && this.defaultScopes.length > 0)\n            return true;\n        return false;\n    }\n    authorize(callback) {\n        if (callback) {\n            this.authorizeAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.authorizeAsync();\n        }\n    }\n    async authorizeAsync() {\n        const result = await this.refreshToken();\n        if (!result) {\n            throw new Error('No result returned');\n        }\n        this.credentials = result.tokens;\n        this.credentials.refresh_token = 'jwt-placeholder';\n        this.key = this.gtoken.key;\n        this.email = this.gtoken.iss;\n        return result.tokens;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken ignored\n     * @private\n     */\n    async refreshTokenNoCache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const gtoken = this.createGToken();\n        const token = await gtoken.getToken({\n            forceRefresh: this.isTokenExpiring(),\n        });\n        const tokens = {\n            access_token: token.access_token,\n            token_type: 'Bearer',\n            expiry_date: gtoken.expiresAt,\n            id_token: gtoken.idToken,\n        };\n        this.emit('tokens', tokens);\n        return { res: null, tokens };\n    }\n    /**\n     * Create a gToken if it doesn't already exist.\n     */\n    createGToken() {\n        if (!this.gtoken) {\n            this.gtoken = new gtoken_1.GoogleToken({\n                iss: this.email,\n                sub: this.subject,\n                scope: this.scopes || this.defaultScopes,\n                keyFile: this.keyFile,\n                key: this.key,\n                additionalClaims: this.additionalClaims,\n                transporter: this.transporter,\n            });\n        }\n        return this.gtoken;\n    }\n    /**\n     * Create a JWT credentials instance using the given input options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\n        }\n        if (!json.client_email) {\n            throw new Error('The incoming JSON object does not contain a client_email field');\n        }\n        if (!json.private_key) {\n            throw new Error('The incoming JSON object does not contain a private_key field');\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n        this.quotaProjectId = json.quota_project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                throw new Error('Must pass in a stream containing the service account auth settings.');\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a JWT credentials instance using an API Key for authentication.\n     * @param apiKey The API Key in string form.\n     */\n    fromAPIKey(apiKey) {\n        if (typeof apiKey !== 'string') {\n            throw new Error('Must provide an API Key string.');\n        }\n        this.apiKey = apiKey;\n    }\n    /**\n     * Using the key or keyFile on the JWT client, obtain an object that contains\n     * the key and the client email.\n     */\n    async getCredentials() {\n        if (this.key) {\n            return { private_key: this.key, client_email: this.email };\n        }\n        else if (this.keyFile) {\n            const gtoken = this.createGToken();\n            const creds = await gtoken.getCredentials(this.keyFile);\n            return { private_key: creds.privateKey, client_email: creds.clientEmail };\n        }\n        throw new Error('A key or a keyFile must be provided to getCredentials.');\n    }\n}\nexports.JWT = JWT;\n//# sourceMappingURL=jwtclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvand0Y2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLGlCQUFpQixtQkFBTyxDQUFDLCtEQUFRO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLGdHQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2p3dGNsaWVudC5qcz81ZDgzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTMgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpXVCA9IHZvaWQgMDtcbmNvbnN0IGd0b2tlbl8xID0gcmVxdWlyZShcImd0b2tlblwiKTtcbmNvbnN0IGp3dGFjY2Vzc18xID0gcmVxdWlyZShcIi4vand0YWNjZXNzXCIpO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5jbGFzcyBKV1QgZXh0ZW5kcyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnNPckVtYWlsLCBrZXlGaWxlLCBrZXksIHNjb3Blcywgc3ViamVjdCwga2V5SWQpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IG9wdGlvbnNPckVtYWlsICYmIHR5cGVvZiBvcHRpb25zT3JFbWFpbCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gb3B0aW9uc09yRW1haWxcbiAgICAgICAgICAgIDogeyBlbWFpbDogb3B0aW9uc09yRW1haWwsIGtleUZpbGUsIGtleSwga2V5SWQsIHNjb3Blcywgc3ViamVjdCB9O1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXM6IG9wdHMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzLFxuICAgICAgICAgICAgZm9yY2VSZWZyZXNoT25GYWlsdXJlOiBvcHRzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1haWwgPSBvcHRzLmVtYWlsO1xuICAgICAgICB0aGlzLmtleUZpbGUgPSBvcHRzLmtleUZpbGU7XG4gICAgICAgIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gICAgICAgIHRoaXMua2V5SWQgPSBvcHRzLmtleUlkO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IG9wdHMuc2NvcGVzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBvcHRzLnN1YmplY3Q7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbENsYWltcyA9IG9wdHMuYWRkaXRpb25hbENsYWltcztcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHsgcmVmcmVzaF90b2tlbjogJ2p3dC1wbGFjZWhvbGRlcicsIGV4cGlyeV9kYXRlOiAxIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBjcmVkZW50aWFsIHdpdGggdGhlIHNwZWNpZmllZCBzY29wZXMuXG4gICAgICogQHBhcmFtIHNjb3BlcyBMaXN0IG9mIHJlcXVlc3RlZCBzY29wZXMgb3IgYSBzaW5nbGUgc2NvcGUuXG4gICAgICogQHJldHVybiBUaGUgY2xvbmVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNyZWF0ZVNjb3BlZChzY29wZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKV1Qoe1xuICAgICAgICAgICAgZW1haWw6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICBrZXlGaWxlOiB0aGlzLmtleUZpbGUsXG4gICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAga2V5SWQ6IHRoaXMua2V5SWQsXG4gICAgICAgICAgICBzY29wZXMsXG4gICAgICAgICAgICBzdWJqZWN0OiB0aGlzLnN1YmplY3QsXG4gICAgICAgICAgICBhZGRpdGlvbmFsQ2xhaW1zOiB0aGlzLmFkZGl0aW9uYWxDbGFpbXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBtZXRhZGF0YSB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIHRoZSBVUkkgYmVpbmcgYXV0aG9yaXplZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyh1cmwpIHtcbiAgICAgICAgdXJsID0gdGhpcy5kZWZhdWx0U2VydmljZVBhdGggPyBgaHR0cHM6Ly8ke3RoaXMuZGVmYXVsdFNlcnZpY2VQYXRofS9gIDogdXJsO1xuICAgICAgICBjb25zdCB1c2VTZWxmU2lnbmVkSldUID0gKCF0aGlzLmhhc1VzZXJTY29wZXMoKSAmJiB1cmwpIHx8XG4gICAgICAgICAgICAodGhpcy51c2VKV1RBY2Nlc3NXaXRoU2NvcGUgJiYgdGhpcy5oYXNBbnlTY29wZXMoKSk7XG4gICAgICAgIGlmICghdGhpcy5hcGlLZXkgJiYgdXNlU2VsZlNpZ25lZEpXVCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkaXRpb25hbENsYWltcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkaXRpb25hbENsYWltcy50YXJnZXRfYXVkaWVuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VucyB9ID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW5zLmlkX3Rva2VufWAsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBzY29wZXMgaGF2ZSBiZWVuIHNldCwgYnV0IGEgdXJpIGhhcyBiZWVuIHByb3ZpZGVkLiBVc2UgSldUQWNjZXNzXG4gICAgICAgICAgICAgICAgLy8gY3JlZGVudGlhbHMuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY2VzcyA9IG5ldyBqd3RhY2Nlc3NfMS5KV1RBY2Nlc3ModGhpcy5lbWFpbCwgdGhpcy5rZXksIHRoaXMua2V5SWQsIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNVc2VyU2NvcGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzID0gdGhpcy5kZWZhdWx0U2NvcGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgdGhpcy5hY2Nlc3MuZ2V0UmVxdWVzdEhlYWRlcnModXJsICE9PSBudWxsICYmIHVybCAhPT0gdm9pZCAwID8gdXJsIDogdW5kZWZpbmVkLCB0aGlzLmFkZGl0aW9uYWxDbGFpbXMsIFxuICAgICAgICAgICAgICAgIC8vIFNjb3BlcyB0YWtlIHByZWNlZGVudCBvdmVyIGF1ZGllbmNlIGZvciBzaWduaW5nLFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIG9ubHkgcHJvdmlkZSB0aGVtIGlmIHVzZUpXVEFjY2Vzc1dpdGhTY29wZSBpcyBvblxuICAgICAgICAgICAgICAgIHRoaXMudXNlSldUQWNjZXNzV2l0aFNjb3BlID8gc2NvcGVzIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzQW55U2NvcGVzKCkgfHwgdGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gYXVkaWVuY2UsIGFwaUtleSwgb3Igc2NvcGVzIGFyZSBwcm92aWRlZCwgd2Ugc2hvdWxkIG5vdCBhdHRlbXB0XG4gICAgICAgICAgICAvLyB0byBwb3B1bGF0ZSBhbnkgaGVhZGVyczpcbiAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHt9IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbiBJRCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0QXVkaWVuY2UgdGhlIGF1ZGllbmNlIGZvciB0aGUgZmV0Y2hlZCBJRCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaElkVG9rZW4odGFyZ2V0QXVkaWVuY2UpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGdUb2tlbiBmb3IgZmV0Y2hpbmcgYW4gSUQgdG9rZW5cbiAgICAgICAgY29uc3QgZ3Rva2VuID0gbmV3IGd0b2tlbl8xLkdvb2dsZVRva2VuKHtcbiAgICAgICAgICAgIGlzczogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgIHN1YjogdGhpcy5zdWJqZWN0LFxuICAgICAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGVzIHx8IHRoaXMuZGVmYXVsdFNjb3BlcyxcbiAgICAgICAgICAgIGtleUZpbGU6IHRoaXMua2V5RmlsZSxcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICBhZGRpdGlvbmFsQ2xhaW1zOiB7IHRhcmdldF9hdWRpZW5jZTogdGFyZ2V0QXVkaWVuY2UgfSxcbiAgICAgICAgICAgIHRyYW5zcG9ydGVyOiB0aGlzLnRyYW5zcG9ydGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgZ3Rva2VuLmdldFRva2VuKHtcbiAgICAgICAgICAgIGZvcmNlUmVmcmVzaDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZ3Rva2VuLmlkVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlcnJvcjogRmFpbGVkIHRvIGZldGNoIElEIHRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGd0b2tlbi5pZFRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlcmUgYXJlIGN1cnJlbnRseSBzY29wZXMgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGhhc1VzZXJTY29wZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5zY29wZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY29wZXMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXJlIHRoZXJlIGFueSBkZWZhdWx0IG9yIHVzZXIgc2NvcGVzIGRlZmluZWQuXG4gICAgICovXG4gICAgaGFzQW55U2NvcGVzKCkge1xuICAgICAgICBpZiAodGhpcy5zY29wZXMgJiYgdGhpcy5zY29wZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0U2NvcGVzICYmIHRoaXMuZGVmYXVsdFNjb3Blcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXV0aG9yaXplKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5hdXRob3JpemVBc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0aG9yaXplQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhdXRob3JpemVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzdWx0IHJldHVybmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHJlc3VsdC50b2tlbnM7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbiA9ICdqd3QtcGxhY2Vob2xkZXInO1xuICAgICAgICB0aGlzLmtleSA9IHRoaXMuZ3Rva2VuLmtleTtcbiAgICAgICAgdGhpcy5lbWFpbCA9IHRoaXMuZ3Rva2VuLmlzcztcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gaWdub3JlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuTm9DYWNoZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGNvbnN0IGd0b2tlbiA9IHRoaXMuY3JlYXRlR1Rva2VuKCk7XG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ3Rva2VuLmdldFRva2VuKHtcbiAgICAgICAgICAgIGZvcmNlUmVmcmVzaDogdGhpcy5pc1Rva2VuRXhwaXJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogdG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgdG9rZW5fdHlwZTogJ0JlYXJlcicsXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogZ3Rva2VuLmV4cGlyZXNBdCxcbiAgICAgICAgICAgIGlkX3Rva2VuOiBndG9rZW4uaWRUb2tlbixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KCd0b2tlbnMnLCB0b2tlbnMpO1xuICAgICAgICByZXR1cm4geyByZXM6IG51bGwsIHRva2VucyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBnVG9rZW4gaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgICAqL1xuICAgIGNyZWF0ZUdUb2tlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmd0b2tlbikge1xuICAgICAgICAgICAgdGhpcy5ndG9rZW4gPSBuZXcgZ3Rva2VuXzEuR29vZ2xlVG9rZW4oe1xuICAgICAgICAgICAgICAgIGlzczogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgICAgICBzdWI6IHRoaXMuc3ViamVjdCxcbiAgICAgICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZXMgfHwgdGhpcy5kZWZhdWx0U2NvcGVzLFxuICAgICAgICAgICAgICAgIGtleUZpbGU6IHRoaXMua2V5RmlsZSxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFpbXM6IHRoaXMuYWRkaXRpb25hbENsYWltcyxcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRlcjogdGhpcy50cmFuc3BvcnRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmd0b2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgSldUIGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIHRoZSBnaXZlbiBpbnB1dCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbnB1dCBvYmplY3QuXG4gICAgICovXG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyB0aGUgc2VydmljZSBhY2NvdW50IGF1dGggc2V0dGluZ3MuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLmNsaWVudF9lbWFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIGNsaWVudF9lbWFpbCBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5wcml2YXRlX2tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHByaXZhdGVfa2V5IGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcmVsZXZhbnQgaW5mb3JtYXRpb24gZnJvbSB0aGUganNvbiBrZXkgZmlsZS5cbiAgICAgICAgdGhpcy5lbWFpbCA9IGpzb24uY2xpZW50X2VtYWlsO1xuICAgICAgICB0aGlzLmtleSA9IGpzb24ucHJpdmF0ZV9rZXk7XG4gICAgICAgIHRoaXMua2V5SWQgPSBqc29uLnByaXZhdGVfa2V5X2lkO1xuICAgICAgICB0aGlzLnByb2plY3RJZCA9IGpzb24ucHJvamVjdF9pZDtcbiAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCA9IGpzb24ucXVvdGFfcHJvamVjdF9pZDtcbiAgICB9XG4gICAgZnJvbVN0cmVhbShpbnB1dFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSkudGhlbigoKSA9PiBjYWxsYmFjaygpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGlucHV0U3RyZWFtXG4gICAgICAgICAgICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC5vbignZGF0YScsIGNodW5rID0+IChzICs9IGNodW5rKSlcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgSldUIGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIGFuIEFQSSBLZXkgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBhcGlLZXkgVGhlIEFQSSBLZXkgaW4gc3RyaW5nIGZvcm0uXG4gICAgICovXG4gICAgZnJvbUFQSUtleShhcGlLZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhbiBBUEkgS2V5IHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgdGhlIGtleSBvciBrZXlGaWxlIG9uIHRoZSBKV1QgY2xpZW50LCBvYnRhaW4gYW4gb2JqZWN0IHRoYXQgY29udGFpbnNcbiAgICAgKiB0aGUga2V5IGFuZCB0aGUgY2xpZW50IGVtYWlsLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENyZWRlbnRpYWxzKCkge1xuICAgICAgICBpZiAodGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHByaXZhdGVfa2V5OiB0aGlzLmtleSwgY2xpZW50X2VtYWlsOiB0aGlzLmVtYWlsIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5rZXlGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBndG9rZW4gPSB0aGlzLmNyZWF0ZUdUb2tlbigpO1xuICAgICAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCBndG9rZW4uZ2V0Q3JlZGVudGlhbHModGhpcy5rZXlGaWxlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHByaXZhdGVfa2V5OiBjcmVkcy5wcml2YXRlS2V5LCBjbGllbnRfZW1haWw6IGNyZWRzLmNsaWVudEVtYWlsIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGtleSBvciBhIGtleUZpbGUgbXVzdCBiZSBwcm92aWRlZCB0byBnZXRDcmVkZW50aWFscy4nKTtcbiAgICB9XG59XG5leHBvcnRzLkpXVCA9IEpXVDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWp3dGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/jwtclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/loginticket.js":
/*!*************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/loginticket.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LoginTicket = void 0;\nclass LoginTicket {\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @param {string} env Envelope of the jwt\n     * @param {TokenPayload} pay Payload of the jwt\n     * @constructor\n     */\n    constructor(env, pay) {\n        this.envelope = env;\n        this.payload = pay;\n    }\n    getEnvelope() {\n        return this.envelope;\n    }\n    getPayload() {\n        return this.payload;\n    }\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @return The user ID\n     */\n    getUserId() {\n        const payload = this.getPayload();\n        if (payload && payload.sub) {\n            return payload.sub;\n        }\n        return null;\n    }\n    /**\n     * Returns attributes from the login ticket.  This can contain\n     * various information about the user session.\n     *\n     * @return The envelope and payload\n     */\n    getAttributes() {\n        return { envelope: this.getEnvelope(), payload: this.getPayload() };\n    }\n}\nexports.LoginTicket = LoginTicket;\n//# sourceMappingURL=loginticket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvbG9naW50aWNrZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2xvZ2ludGlja2V0LmpzP2ZhYTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9naW5UaWNrZXQgPSB2b2lkIDA7XG5jbGFzcyBMb2dpblRpY2tldCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2ltcGxlIGNsYXNzIHRvIGV4dHJhY3QgdXNlciBJRCBmcm9tIGFuIElEIFRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW52IEVudmVsb3BlIG9mIHRoZSBqd3RcbiAgICAgKiBAcGFyYW0ge1Rva2VuUGF5bG9hZH0gcGF5IFBheWxvYWQgb2YgdGhlIGp3dFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVudiwgcGF5KSB7XG4gICAgICAgIHRoaXMuZW52ZWxvcGUgPSBlbnY7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheTtcbiAgICB9XG4gICAgZ2V0RW52ZWxvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudmVsb3BlO1xuICAgIH1cbiAgICBnZXRQYXlsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXlsb2FkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaW1wbGUgY2xhc3MgdG8gZXh0cmFjdCB1c2VyIElEIGZyb20gYW4gSUQgVG9rZW5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIHVzZXIgSURcbiAgICAgKi9cbiAgICBnZXRVc2VySWQoKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmdldFBheWxvYWQoKTtcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLnN1YjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhdHRyaWJ1dGVzIGZyb20gdGhlIGxvZ2luIHRpY2tldC4gIFRoaXMgY2FuIGNvbnRhaW5cbiAgICAgKiB2YXJpb3VzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBlbnZlbG9wZSBhbmQgcGF5bG9hZFxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7IGVudmVsb3BlOiB0aGlzLmdldEVudmVsb3BlKCksIHBheWxvYWQ6IHRoaXMuZ2V0UGF5bG9hZCgpIH07XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dpblRpY2tldCA9IExvZ2luVGlja2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9naW50aWNrZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/loginticket.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/oauth2client.js":
/*!**************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/oauth2client.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(api)/../node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst formatEcdsa = __webpack_require__(/*! ecdsa-sig-formatter */ \"(api)/../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(api)/../node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst loginticket_1 = __webpack_require__(/*! ./loginticket */ \"(api)/../node_modules/google-auth-library/build/src/auth/loginticket.js\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\n        super();\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\n            ? optionsOrClientId\n            : { clientId: optionsOrClientId, clientSecret, redirectUri };\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.eagerRefreshThresholdMillis =\n            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n        this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n    generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n        }\n        opts.response_type = opts.response_type || 'code';\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (Array.isArray(opts.scope)) {\n            opts.scope = opts.scope.join(' ');\n        }\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n        return (rootUrl +\n            '?' +\n            querystring.stringify(opts));\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n     */\n    async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = (0, crypto_1.createCrypto)();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString\n            .replace(/\\+/g, '~')\n            .replace(/=/g, '_')\n            .replace(/\\//g, '-');\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge\n            .split('=')[0]\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_');\n        return { codeVerifier, codeChallenge };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === 'string' ? { code: codeOrOptions } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n        }\n        else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const values = {\n            code: options.code,\n            client_id: options.client_id || this._clientId,\n            client_secret: this._clientSecret,\n            redirect_uri: options.redirect_uri || this.redirectUri,\n            grant_type: 'authorization_code',\n            code_verifier: options.codeVerifier,\n        };\n        const res = await this.transporter.request({\n            method: 'POST',\n            url,\n            data: querystring.stringify(values),\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        });\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n    async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then(r => {\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, e => {\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        var _a;\n        if (!refreshToken) {\n            throw new Error('No refresh token is set.');\n        }\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: 'refresh_token',\n        };\n        let res;\n        try {\n            // request for new token\n            res = await this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(data),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            });\n        }\n        catch (e) {\n            if (e instanceof gaxios_1.GaxiosError &&\n                e.message === 'invalid_grant' &&\n                ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) &&\n                /ReAuth/i.test(e.response.data.error_description)) {\n                e.message = JSON.stringify(e.response.data);\n            }\n            throw e;\n        }\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n        }\n        else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return { credentials: this.credentials, res: r.res };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n        }\n        else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                if (this.refreshHandler) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                        return { token: this.credentials.access_token };\n                    }\n                }\n                else {\n                    throw new Error('No refresh token or refresh handler callback is set.');\n                }\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                throw new Error('Could not refresh access token.');\n            }\n            return { token: r.credentials.access_token, res: r.res };\n        }\n        else {\n            return { token: this.credentials.access_token };\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n    async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token &&\n            !thisCreds.refresh_token &&\n            !this.apiKey &&\n            !this.refreshHandler) {\n            throw new Error('No access, refresh token, API key or refresh handler callback is set.');\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || 'Bearer';\n            const headers = {\n                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token,\n            };\n            return { headers: this.addSharedMetadataHeaders(headers) };\n        }\n        // If refreshHandler exists, call processAndValidateRefreshHandler().\n        if (this.refreshHandler) {\n            const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                this.setCredentials(refreshedAccessToken);\n                const headers = {\n                    Authorization: 'Bearer ' + this.credentials.access_token,\n                };\n                return { headers: this.addSharedMetadataHeaders(headers) };\n            }\n        }\n        if (this.apiKey) {\n            return { headers: { 'X-Goog-Api-Key': this.apiKey } };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        }\n        catch (err) {\n            const e = err;\n            if (e.response &&\n                (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || 'Bearer';\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = {\n            Authorization: credentials.token_type + ' ' + tokens.access_token,\n        };\n        return { headers: this.addSharedMetadataHeaders(headers), res: r.res };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n    static getRevokeTokenUrl(token) {\n        const parameters = querystring.stringify({ token });\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: OAuth2Client.getRevokeTokenUrl(token),\n            method: 'POST',\n        };\n        if (callback) {\n            this.transporter\n                .request(opts)\n                .then(r => callback(null, r), callback);\n        }\n        else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n        }\n        else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        }\n        else {\n            throw new Error('No access token to revoke.');\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, retry = false) {\n        let r2;\n        try {\n            const r = await this.getRequestMetadataAsync(opts.url);\n            opts.headers = opts.headers || {};\n            if (r.headers && r.headers['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n            }\n            if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n            }\n            if (this.apiKey) {\n                opts.headers['X-Goog-Api-Key'] = this.apiKey;\n            }\n            r2 = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                // Or the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - No refresh_token was available\n                // - An access_token and a refreshHandler callback were available, but\n                //   either no expiry_date was available or the forceRefreshOnFailure\n                //   flag is set. The access_token fails on the first try because it's\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\n                //   to mitigate time-related errors.\n                const mayRequireRefresh = this.credentials &&\n                    this.credentials.access_token &&\n                    this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const mayRequireRefreshWithNoRefreshToken = this.credentials &&\n                    this.credentials.access_token &&\n                    !this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure) &&\n                    this.refreshHandler;\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                }\n                else if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    mayRequireRefreshWithNoRefreshToken) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                    }\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return r2;\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== 'function') {\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error('The verifyIdToken method requires an ID Token');\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n    async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                Authorization: `Bearer ${accessToken}`,\n            },\n            url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(' '),\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n        }\n        else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = (0, crypto_1.hasBrowserCrypto)()\n            ? CertificateFormat.JWK\n            : CertificateFormat.PEM;\n        if (this.certificateExpiry &&\n            nowTime < this.certificateExpiry.getTime() &&\n            this.certificateCacheFormat === format) {\n            return { certs: this.certificateCache, format };\n        }\n        let res;\n        let url;\n        switch (format) {\n            case CertificateFormat.PEM:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                break;\n            case CertificateFormat.JWK:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        const cacheControl = res ? res.headers['cache-control'] : undefined;\n        let cacheAge = -1;\n        if (cacheControl) {\n            const pattern = new RegExp('max-age=([0-9]*)');\n            const regexResult = pattern.exec(cacheControl);\n            if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch (format) {\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys) {\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry =\n            cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return { certs: certificates, format, res };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n        }\n        else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        let res;\n        const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        return { pubkeys: res.data, res };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = (0, crypto_1.createCrypto)();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split('.');\n        if (segments.length !== 3) {\n            throw new Error('Wrong number of segments in token: ' + jwt);\n        }\n        const signed = segments[0] + '.' + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            }\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token payload '${segments[0]}`;\n            }\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === 'ES256') {\n            signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error('Invalid token signature: ' + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error('No issue time in token: ' + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat))\n            throw new Error('iat field using invalid format');\n        const exp = Number(payload.exp);\n        if (isNaN(exp))\n            throw new Error('exp field using invalid format');\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error('Token used too early, ' +\n                now +\n                ' < ' +\n                earliest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error('Token used too late, ' +\n                now +\n                ' > ' +\n                latest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error('Invalid issuer, expected one of [' +\n                issuers +\n                '], but got ' +\n                payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            }\n            else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns a promise that resolves with AccessTokenResponse type if\n     * refreshHandler is defined.\n     * If not, nothing is returned.\n     */\n    async processAndValidateRefreshHandler() {\n        if (this.refreshHandler) {\n            const accessTokenResponse = await this.refreshHandler();\n            if (!accessTokenResponse.access_token) {\n                throw new Error('No access token is returned by the refreshHandler callback.');\n            }\n            return accessTokenResponse;\n        }\n        return;\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n    isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate\n            ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = [\n    'accounts.google.com',\n    'https://accounts.google.com',\n];\n//# sourceMappingURL=oauth2client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvb2F1dGgyY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsMkJBQTJCO0FBQzlFLGlCQUFpQixtQkFBTyxDQUFDLCtEQUFRO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxpR0FBcUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsOEZBQWtCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLDRGQUFjO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLDhGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3REFBd0QsMkJBQTJCLEtBQUs7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRCx5QkFBeUIsS0FBSztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhEQUE4RCxzQkFBc0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFxRDtBQUM1RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFxRDtBQUNoRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxVQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFELGtCQUFrQix1Q0FBdUMsR0FBRyxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFVBQVU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsWUFBWSxLQUFLLFlBQVk7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL29hdXRoMmNsaWVudC5qcz80ZTNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9BdXRoMkNsaWVudCA9IGV4cG9ydHMuQ2VydGlmaWNhdGVGb3JtYXQgPSBleHBvcnRzLkNvZGVDaGFsbGVuZ2VNZXRob2QgPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBmb3JtYXRFY2RzYSA9IHJlcXVpcmUoXCJlY2RzYS1zaWctZm9ybWF0dGVyXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2NyeXB0b1wiKTtcbmNvbnN0IGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGhjbGllbnRcIik7XG5jb25zdCBsb2dpbnRpY2tldF8xID0gcmVxdWlyZShcIi4vbG9naW50aWNrZXRcIik7XG52YXIgQ29kZUNoYWxsZW5nZU1ldGhvZDtcbihmdW5jdGlvbiAoQ29kZUNoYWxsZW5nZU1ldGhvZCkge1xuICAgIENvZGVDaGFsbGVuZ2VNZXRob2RbXCJQbGFpblwiXSA9IFwicGxhaW5cIjtcbiAgICBDb2RlQ2hhbGxlbmdlTWV0aG9kW1wiUzI1NlwiXSA9IFwiUzI1NlwiO1xufSkoQ29kZUNoYWxsZW5nZU1ldGhvZCA9IGV4cG9ydHMuQ29kZUNoYWxsZW5nZU1ldGhvZCB8fCAoZXhwb3J0cy5Db2RlQ2hhbGxlbmdlTWV0aG9kID0ge30pKTtcbnZhciBDZXJ0aWZpY2F0ZUZvcm1hdDtcbihmdW5jdGlvbiAoQ2VydGlmaWNhdGVGb3JtYXQpIHtcbiAgICBDZXJ0aWZpY2F0ZUZvcm1hdFtcIlBFTVwiXSA9IFwiUEVNXCI7XG4gICAgQ2VydGlmaWNhdGVGb3JtYXRbXCJKV0tcIl0gPSBcIkpXS1wiO1xufSkoQ2VydGlmaWNhdGVGb3JtYXQgPSBleHBvcnRzLkNlcnRpZmljYXRlRm9ybWF0IHx8IChleHBvcnRzLkNlcnRpZmljYXRlRm9ybWF0ID0ge30pKTtcbmNsYXNzIE9BdXRoMkNsaWVudCBleHRlbmRzIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zT3JDbGllbnRJZCwgY2xpZW50U2VjcmV0LCByZWRpcmVjdFVyaSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUV4cGlyeSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVDYWNoZUZvcm1hdCA9IENlcnRpZmljYXRlRm9ybWF0LlBFTTtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IG9wdGlvbnNPckNsaWVudElkICYmIHR5cGVvZiBvcHRpb25zT3JDbGllbnRJZCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gb3B0aW9uc09yQ2xpZW50SWRcbiAgICAgICAgICAgIDogeyBjbGllbnRJZDogb3B0aW9uc09yQ2xpZW50SWQsIGNsaWVudFNlY3JldCwgcmVkaXJlY3RVcmkgfTtcbiAgICAgICAgdGhpcy5fY2xpZW50SWQgPSBvcHRzLmNsaWVudElkO1xuICAgICAgICB0aGlzLl9jbGllbnRTZWNyZXQgPSBvcHRzLmNsaWVudFNlY3JldDtcbiAgICAgICAgdGhpcy5yZWRpcmVjdFVyaSA9IG9wdHMucmVkaXJlY3RVcmk7XG4gICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID1cbiAgICAgICAgICAgIG9wdHMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIHx8IDUgKiA2MCAqIDEwMDA7XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlID0gISFvcHRzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIFVSTCBmb3IgY29uc2VudCBwYWdlIGxhbmRpbmcuXG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIFVSTCB0byBjb25zZW50IHBhZ2UuXG4gICAgICovXG4gICAgZ2VuZXJhdGVBdXRoVXJsKG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAob3B0cy5jb2RlX2NoYWxsZW5nZV9tZXRob2QgJiYgIW9wdHMuY29kZV9jaGFsbGVuZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgYSBjb2RlX2NoYWxsZW5nZV9tZXRob2QgaXMgcHJvdmlkZWQsIGNvZGVfY2hhbGxlbmdlIG11c3QgYmUgaW5jbHVkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5yZXNwb25zZV90eXBlID0gb3B0cy5yZXNwb25zZV90eXBlIHx8ICdjb2RlJztcbiAgICAgICAgb3B0cy5jbGllbnRfaWQgPSBvcHRzLmNsaWVudF9pZCB8fCB0aGlzLl9jbGllbnRJZDtcbiAgICAgICAgb3B0cy5yZWRpcmVjdF91cmkgPSBvcHRzLnJlZGlyZWN0X3VyaSB8fCB0aGlzLnJlZGlyZWN0VXJpO1xuICAgICAgICAvLyBBbGxvdyBzY29wZXMgdG8gYmUgcGFzc2VkIGVpdGhlciBhcyBhcnJheSBvciBhIHN0cmluZ1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzLnNjb3BlKSkge1xuICAgICAgICAgICAgb3B0cy5zY29wZSA9IG9wdHMuc2NvcGUuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3RVcmwgPSBPQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9BVVRIX0JBU0VfVVJMXztcbiAgICAgICAgcmV0dXJuIChyb290VXJsICtcbiAgICAgICAgICAgICc/JyArXG4gICAgICAgICAgICBxdWVyeXN0cmluZy5zdHJpbmdpZnkob3B0cykpO1xuICAgIH1cbiAgICBnZW5lcmF0ZUNvZGVWZXJpZmllcigpIHtcbiAgICAgICAgLy8gVG8gbWFrZSB0aGUgY29kZSBjb21wYXRpYmxlIHdpdGggYnJvd3NlciBTdWJ0bGVDcnlwdG8gd2UgbmVlZCB0byBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlQ29kZVZlcmlmaWVyIGlzIHJlbW92ZWQsIHBsZWFzZSB1c2UgZ2VuZXJhdGVDb2RlVmVyaWZpZXJBc3luYyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIGNvZGVfdmVyaWZpZXIsIGFuZCBpdHNcbiAgICAgKiByZXN1bHRpbmcgU0hBMjU2LiBJZiB1c2VkLCB0aGlzIG11c3QgYmUgcGFpcmVkIHdpdGggYSBTMjU2XG4gICAgICogY29kZV9jaGFsbGVuZ2VfbWV0aG9kLlxuICAgICAqXG4gICAgICogRm9yIGEgZnVsbCBleGFtcGxlIHNlZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9nb29nbGUtYXV0aC1saWJyYXJ5LW5vZGVqcy9ibG9iL21haW4vc2FtcGxlcy9vYXV0aDItY29kZVZlcmlmaWVyLmpzXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVDb2RlVmVyaWZpZXJBc3luYygpIHtcbiAgICAgICAgLy8gYmFzZTY0IGVuY29kaW5nIHVzZXMgNiBiaXRzIHBlciBjaGFyYWN0ZXIsIGFuZCB3ZSB3YW50IHRvIGdlbmVyYXRlMTI4XG4gICAgICAgIC8vIGNoYXJhY3RlcnMuIDYqMTI4LzggPSA5Ni5cbiAgICAgICAgY29uc3QgY3J5cHRvID0gKDAsIGNyeXB0b18xLmNyZWF0ZUNyeXB0bykoKTtcbiAgICAgICAgY29uc3QgcmFuZG9tU3RyaW5nID0gY3J5cHRvLnJhbmRvbUJ5dGVzQmFzZTY0KDk2KTtcbiAgICAgICAgLy8gVGhlIHZhbGlkIGNoYXJhY3RlcnMgaW4gdGhlIGNvZGVfdmVyaWZpZXIgYXJlIFtBLVpdL1thLXpdL1swLTldL1xuICAgICAgICAvLyBcIi1cIi9cIi5cIi9cIl9cIi9cIn5cIi4gQmFzZTY0IGVuY29kZWQgc3RyaW5ncyBhcmUgcHJldHR5IGNsb3NlLCBzbyB3ZSdyZSBqdXN0XG4gICAgICAgIC8vIHN3YXBwaW5nIG91dCBhIGZldyBjaGFycy5cbiAgICAgICAgY29uc3QgY29kZVZlcmlmaWVyID0gcmFuZG9tU3RyaW5nXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICd+JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC89L2csICdfJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJy0nKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGJhc2U2NCBlbmNvZGVkIFNIQTI1NlxuICAgICAgICBjb25zdCB1bmVuY29kZWRDb2RlQ2hhbGxlbmdlID0gYXdhaXQgY3J5cHRvLnNoYTI1NkRpZ2VzdEJhc2U2NChjb2RlVmVyaWZpZXIpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBiYXNlNjRVcmxFbmNvZGluZyBpbnN0ZWFkIG9mIHN0YW5kYXJkIGJhc2U2NFxuICAgICAgICBjb25zdCBjb2RlQ2hhbGxlbmdlID0gdW5lbmNvZGVkQ29kZUNoYWxsZW5nZVxuICAgICAgICAgICAgLnNwbGl0KCc9JylbMF1cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuICAgICAgICByZXR1cm4geyBjb2RlVmVyaWZpZXIsIGNvZGVDaGFsbGVuZ2UgfTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oY29kZU9yT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBjb2RlT3JPcHRpb25zID09PSAnc3RyaW5nJyA/IHsgY29kZTogY29kZU9yT3B0aW9ucyB9IDogY29kZU9yT3B0aW9ucztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldFRva2VuQXN5bmMob3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIudG9rZW5zLCByLnJlcyksIGUgPT4gY2FsbGJhY2soZSwgbnVsbCwgZS5yZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Bc3luYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbkFzeW5jKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfVE9LRU5fVVJMXztcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgY29kZTogb3B0aW9ucy5jb2RlLFxuICAgICAgICAgICAgY2xpZW50X2lkOiBvcHRpb25zLmNsaWVudF9pZCB8fCB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuX2NsaWVudFNlY3JldCxcbiAgICAgICAgICAgIHJlZGlyZWN0X3VyaTogb3B0aW9ucy5yZWRpcmVjdF91cmkgfHwgdGhpcy5yZWRpcmVjdFVyaSxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgICAgY29kZV92ZXJpZmllcjogb3B0aW9ucy5jb2RlVmVyaWZpZXIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGRhdGE6IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh2YWx1ZXMpLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHJlcy5kYXRhO1xuICAgICAgICBpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEuZXhwaXJlc19pbikge1xuICAgICAgICAgICAgdG9rZW5zLmV4cGlyeV9kYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyByZXMuZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbnMuZXhwaXJlc19pbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHRva2VucywgcmVzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoX3Rva2VuIEV4aXN0aW5nIHJlZnJlc2ggdG9rZW4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW5Ob0NhY2hlKHJlZnJlc2hUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSByZXF1ZXN0IHRvIHJlZnJlc2ggdXNpbmcgdGhlIHNhbWUgdG9rZW4gaGFzIHN0YXJ0ZWQsXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSBwcm9taXNlLlxuICAgICAgICBpZiAodGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5oYXMocmVmcmVzaFRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMuZ2V0KHJlZnJlc2hUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucmVmcmVzaFRva2VuTm9DYWNoZShyZWZyZXNoVG9rZW4pLnRoZW4ociA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLmRlbGV0ZShyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5kZWxldGUocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLnNldChyZWZyZXNoVG9rZW4sIHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaFRva2VuTm9DYWNoZShyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWZyZXNoIHRva2VuIGlzIHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBPQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9UT0tFTl9VUkxfO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuX2NsaWVudFNlY3JldCxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgZm9yIG5ldyB0b2tlblxuICAgICAgICAgICAgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvciAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9PT0gJ2ludmFsaWRfZ3JhbnQnICYmXG4gICAgICAgICAgICAgICAgKChfYSA9IGUucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAmJlxuICAgICAgICAgICAgICAgIC9SZUF1dGgvaS50ZXN0KGUucmVzcG9uc2UuZGF0YS5lcnJvcl9kZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShlLnJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbnMgPSByZXMuZGF0YTtcbiAgICAgICAgLy8gVE9ETzogZGUtZHVwbGljYXRlIHRoaXMgY29kZSBmcm9tIGEgZmV3IHNwb3RzXG4gICAgICAgIGlmIChyZXMuZGF0YSAmJiByZXMuZGF0YS5leHBpcmVzX2luKSB7XG4gICAgICAgICAgICB0b2tlbnMuZXhwaXJ5X2RhdGUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHJlcy5kYXRhLmV4cGlyZXNfaW4gKiAxMDAwO1xuICAgICAgICAgICAgZGVsZXRlIHRva2Vucy5leHBpcmVzX2luO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywgdG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHsgdG9rZW5zLCByZXMgfTtcbiAgICB9XG4gICAgcmVmcmVzaEFjY2Vzc1Rva2VuKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLmNyZWRlbnRpYWxzLCByLnJlcyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbih0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSByLnRva2VucztcbiAgICAgICAgdG9rZW5zLnJlZnJlc2hfdG9rZW4gPSB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0b2tlbnM7XG4gICAgICAgIHJldHVybiB7IGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLCByZXM6IHIucmVzIH07XG4gICAgfVxuICAgIGdldEFjY2Vzc1Rva2VuKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRBY2Nlc3NUb2tlbkFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIudG9rZW4sIHIucmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlZnJlc2ggPSAhdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gfHwgdGhpcy5pc1Rva2VuRXhwaXJpbmcoKTtcbiAgICAgICAgaWYgKHNob3VsZFJlZnJlc2gpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmcmVzaEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcmVzaGVkQWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLnByb2Nlc3NBbmRWYWxpZGF0ZVJlZnJlc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gbnVsbCB8fCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmcmVzaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENyZWRlbnRpYWxzKHJlZnJlc2hlZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRva2VuOiB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlZnJlc2ggdG9rZW4gb3IgcmVmcmVzaCBoYW5kbGVyIGNhbGxiYWNrIGlzIHNldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgaWYgKCFyLmNyZWRlbnRpYWxzIHx8IChyLmNyZWRlbnRpYWxzICYmICFyLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWZyZXNoIGFjY2VzcyB0b2tlbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHRva2VuOiByLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiwgcmVzOiByLnJlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdG9rZW46IHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gYXV0aGVudGljYXRpb24gaW50ZXJmYWNlLiAgSXQgdGFrZXMgYW4gb3B0aW9uYWwgdXJsIHdoaWNoIHdoZW5cbiAgICAgKiBwcmVzZW50IGlzIHRoZSBlbmRwb2ludCBiZWluZyBhY2Nlc3NlZCwgYW5kIHJldHVybnMgYSBQcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgd2l0aCBhdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBJbiBPQXV0aDJDbGllbnQsIHRoZSByZXN1bHQgaGFzIHRoZSBmb3JtOlxuICAgICAqIHsgQXV0aG9yaXphdGlvbjogJ0JlYXJlciA8YWNjZXNzX3Rva2VuX3ZhbHVlPicgfVxuICAgICAqIEBwYXJhbSB1cmwgVGhlIG9wdGlvbmFsIHVybCBiZWluZyBhdXRob3JpemVkXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdEhlYWRlcnModXJsKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSAoYXdhaXQgdGhpcy5nZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyh1cmwpKS5oZWFkZXJzO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmMoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHVybCkge1xuICAgICAgICBjb25zdCB0aGlzQ3JlZHMgPSB0aGlzLmNyZWRlbnRpYWxzO1xuICAgICAgICBpZiAoIXRoaXNDcmVkcy5hY2Nlc3NfdG9rZW4gJiZcbiAgICAgICAgICAgICF0aGlzQ3JlZHMucmVmcmVzaF90b2tlbiAmJlxuICAgICAgICAgICAgIXRoaXMuYXBpS2V5ICYmXG4gICAgICAgICAgICAhdGhpcy5yZWZyZXNoSGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MsIHJlZnJlc2ggdG9rZW4sIEFQSSBrZXkgb3IgcmVmcmVzaCBoYW5kbGVyIGNhbGxiYWNrIGlzIHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc0NyZWRzLmFjY2Vzc190b2tlbiAmJiAhdGhpcy5pc1Rva2VuRXhwaXJpbmcoKSkge1xuICAgICAgICAgICAgdGhpc0NyZWRzLnRva2VuX3R5cGUgPSB0aGlzQ3JlZHMudG9rZW5fdHlwZSB8fCAnQmVhcmVyJztcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogdGhpc0NyZWRzLnRva2VuX3R5cGUgKyAnICcgKyB0aGlzQ3JlZHMuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcmVmcmVzaEhhbmRsZXIgZXhpc3RzLCBjYWxsIHByb2Nlc3NBbmRWYWxpZGF0ZVJlZnJlc2hIYW5kbGVyKCkuXG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMucHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgIGlmIChyZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gbnVsbCB8fCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmcmVzaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDcmVkZW50aWFscyhyZWZyZXNoZWRBY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogeyAnWC1Hb29nLUFwaS1LZXknOiB0aGlzLmFwaUtleSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHIgPSBudWxsO1xuICAgICAgICBsZXQgdG9rZW5zID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHIgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbih0aGlzQ3JlZHMucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICB0b2tlbnMgPSByLnRva2VucztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gZXJyO1xuICAgICAgICAgICAgaWYgKGUucmVzcG9uc2UgJiZcbiAgICAgICAgICAgICAgICAoZS5yZXNwb25zZS5zdGF0dXMgPT09IDQwMyB8fCBlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSkge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBDb3VsZCBub3QgcmVmcmVzaCBhY2Nlc3MgdG9rZW46ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gdGhpcy5jcmVkZW50aWFscztcbiAgICAgICAgY3JlZGVudGlhbHMudG9rZW5fdHlwZSA9IGNyZWRlbnRpYWxzLnRva2VuX3R5cGUgfHwgJ0JlYXJlcic7XG4gICAgICAgIHRva2Vucy5yZWZyZXNoX3Rva2VuID0gY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbjtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRva2VucztcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGNyZWRlbnRpYWxzLnRva2VuX3R5cGUgKyAnICcgKyB0b2tlbnMuYWNjZXNzX3Rva2VuLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKSwgcmVzOiByLnJlcyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gVVJMIHRvIHJldm9rZSB0aGUgZ2l2ZW4gdG9rZW4uXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBleGlzdGluZyB0b2tlbiB0byBiZSByZXZva2VkLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXZva2VUb2tlblVybCh0b2tlbikge1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHsgdG9rZW4gfSk7XG4gICAgICAgIHJldHVybiBgJHtPQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9SRVZPS0VfVVJMX30/JHtwYXJhbWV0ZXJzfWA7XG4gICAgfVxuICAgIHJldm9rZVRva2VuKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiBPQXV0aDJDbGllbnQuZ2V0UmV2b2tlVG9rZW5VcmwodG9rZW4pLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRlclxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KG9wdHMpXG4gICAgICAgICAgICAgICAgLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXZva2VDcmVkZW50aWFscyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmV2b2tlQ3JlZGVudGlhbHNBc3luYygpLnRoZW4ocmVzID0+IGNhbGxiYWNrKG51bGwsIHJlcyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldm9rZUNyZWRlbnRpYWxzQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXZva2VDcmVkZW50aWFsc0FzeW5jKCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge307XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2b2tlVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gdG8gcmV2b2tlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlLCBlLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RBc3luYyhvcHRzLCByZXRyeSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKG9wdHMudXJsKTtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyLmhlYWRlcnMgJiYgci5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9IHIuaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIuaGVhZGVycyAmJiByLmhlYWRlcnMuQXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gci5oZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ1gtR29vZy1BcGktS2V5J10gPSB0aGlzLmFwaUtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIyID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGZvciBtZXRhZGF0YSBpZiB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBBbiBhY2Nlc3NfdG9rZW4gYW5kIHJlZnJlc2hfdG9rZW4gd2VyZSBhdmFpbGFibGUsIGJ1dCBlaXRoZXIgbm9cbiAgICAgICAgICAgICAgICAvLyAgIGV4cGlyeV9kYXRlIHdhcyBhdmFpbGFibGUgb3IgdGhlIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSBmbGFnIGlzIHNldC5cbiAgICAgICAgICAgICAgICAvLyAgIFRoZSBhYnNlbnQgZXhwaXJ5X2RhdGUgY2FzZSBjYW4gaGFwcGVuIHdoZW4gZGV2ZWxvcGVycyBzdGFzaCB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGFjY2Vzc190b2tlbiBhbmQgcmVmcmVzaF90b2tlbiBmb3IgbGF0ZXIgdXNlLCBidXQgdGhlIGFjY2Vzc190b2tlblxuICAgICAgICAgICAgICAgIC8vICAgZmFpbHMgb24gdGhlIGZpcnN0IHRyeSBiZWNhdXNlIGl0J3MgZXhwaXJlZC4gU29tZSBkZXZlbG9wZXJzIG1heVxuICAgICAgICAgICAgICAgIC8vICAgY2hvb3NlIHRvIGVuYWJsZSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgdG8gbWl0aWdhdGUgdGltZS1yZWxhdGVkXG4gICAgICAgICAgICAgICAgLy8gICBlcnJvcnMuXG4gICAgICAgICAgICAgICAgLy8gT3IgdGhlIGZvbGxvd2luZyBjcml0ZXJpYSBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAvLyAtIFdlIGhhdmVuJ3QgYWxyZWFkeSByZXRyaWVkLiAgSXQgb25seSBtYWtlcyBzZW5zZSB0byByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlc3BvbnNlIHdhcyBhIDQwMSBvciBhIDQwM1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlcXVlc3QgZGlkbid0IHNlbmQgYSByZWFkYWJsZVN0cmVhbVxuICAgICAgICAgICAgICAgIC8vIC0gTm8gcmVmcmVzaF90b2tlbiB3YXMgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgLy8gLSBBbiBhY2Nlc3NfdG9rZW4gYW5kIGEgcmVmcmVzaEhhbmRsZXIgY2FsbGJhY2sgd2VyZSBhdmFpbGFibGUsIGJ1dFxuICAgICAgICAgICAgICAgIC8vICAgZWl0aGVyIG5vIGV4cGlyeV9kYXRlIHdhcyBhdmFpbGFibGUgb3IgdGhlIGZvcmNlUmVmcmVzaE9uRmFpbHVyZVxuICAgICAgICAgICAgICAgIC8vICAgZmxhZyBpcyBzZXQuIFRoZSBhY2Nlc3NfdG9rZW4gZmFpbHMgb24gdGhlIGZpcnN0IHRyeSBiZWNhdXNlIGl0J3NcbiAgICAgICAgICAgICAgICAvLyAgIGV4cGlyZWQuIFNvbWUgZGV2ZWxvcGVycyBtYXkgY2hvb3NlIHRvIGVuYWJsZSBmb3JjZVJlZnJlc2hPbkZhaWx1cmVcbiAgICAgICAgICAgICAgICAvLyAgIHRvIG1pdGlnYXRlIHRpbWUtcmVsYXRlZCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF5UmVxdWlyZVJlZnJlc2ggPSB0aGlzLmNyZWRlbnRpYWxzICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgfHwgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heVJlcXVpcmVSZWZyZXNoV2l0aE5vUmVmcmVzaFRva2VuID0gdGhpcy5jcmVkZW50aWFscyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5jcmVkZW50aWFscy5leHBpcnlfZGF0ZSB8fCB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSGFuZGxlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0gcmVzLmNvbmZpZy5kYXRhIGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXV0aEVyciA9IHN0YXR1c0NvZGUgPT09IDQwMSB8fCBzdGF0dXNDb2RlID09PSA0MDM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSAmJiBpc0F1dGhFcnIgJiYgIWlzUmVhZGFibGVTdHJlYW0gJiYgbWF5UmVxdWlyZVJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFyZXRyeSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhFcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5UmVxdWlyZVJlZnJlc2hXaXRoTm9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcmVzaGVkQWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLnByb2Nlc3NBbmRWYWxpZGF0ZVJlZnJlc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gbnVsbCB8fCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmcmVzaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENyZWRlbnRpYWxzKHJlZnJlc2hlZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjI7XG4gICAgfVxuICAgIHZlcmlmeUlkVG9rZW4ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VkIHRvIGFjY2VwdCB0d28gYXJndW1lbnRzIGluc3RlYWQgb2YgYW4gb3B0aW9ucyBvYmplY3QuXG4gICAgICAgIC8vIENoZWNrIHRoZSB0eXBlcyB0byBoZWxwIHVzZXJzIHVwZ3JhZGUgd2l0aCBsZXNzIHBhaW4uXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgY2FuIGJlIHJlbW92ZWQgYWZ0ZXIgYSAyLjAgcmVsZWFzZS5cbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbnMgb2JqZWN0IGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIHdoaWNoIGluY2x1ZGVzIHRoZSBpZFRva2VuLCBhdWRpZW5jZSwgYW5kIG1heEV4cGlyeS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5SWRUb2tlbkFzeW5jKG9wdGlvbnMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5SWRUb2tlbkFzeW5jKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeUlkVG9rZW5Bc3luYyhvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5pZFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2ZXJpZnlJZFRva2VuIG1ldGhvZCByZXF1aXJlcyBhbiBJRCBUb2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRGZWRlcmF0ZWRTaWdub25DZXJ0c0FzeW5jKCk7XG4gICAgICAgIGNvbnN0IGxvZ2luID0gYXdhaXQgdGhpcy52ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHNBc3luYyhvcHRpb25zLmlkVG9rZW4sIHJlc3BvbnNlLmNlcnRzLCBvcHRpb25zLmF1ZGllbmNlLCBPQXV0aDJDbGllbnQuSVNTVUVSU18sIG9wdGlvbnMubWF4RXhwaXJ5KTtcbiAgICAgICAgcmV0dXJuIGxvZ2luO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwcm92aXNpb25lZCBhY2Nlc3MgdG9rZW4uICBFc3BlY2lhbGx5IHVzZWZ1bFxuICAgICAqIGlmIHlvdSB3YW50IHRvIGNoZWNrIHRoZSBzY29wZXMgdGhhdCB3ZXJlIHByb3Zpc2lvbmVkIHRvIGEgZ2l2ZW4gdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gUmVxdWlyZWQuICBUaGUgQWNjZXNzIFRva2VuIGZvciB3aGljaCB5b3Ugd2FudCB0byBnZXRcbiAgICAgKiB1c2VyIGluZm8uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VG9rZW5JbmZvKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cmw6IE9BdXRoMkNsaWVudC5HT09HTEVfVE9LRU5fSU5GT19VUkwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmZvID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBkYXRhLmV4cGlyZXNfaW4gKiAxMDAwLFxuICAgICAgICAgICAgc2NvcGVzOiBkYXRhLnNjb3BlLnNwbGl0KCcgJyksXG4gICAgICAgIH0sIGRhdGEpO1xuICAgICAgICBkZWxldGUgaW5mby5leHBpcmVzX2luO1xuICAgICAgICBkZWxldGUgaW5mby5zY29wZTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIGdldEZlZGVyYXRlZFNpZ25vbkNlcnRzKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRGZWRlcmF0ZWRTaWdub25DZXJ0c0FzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIuY2VydHMsIHIucmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHNBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IG5vd1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKDAsIGNyeXB0b18xLmhhc0Jyb3dzZXJDcnlwdG8pKClcbiAgICAgICAgICAgID8gQ2VydGlmaWNhdGVGb3JtYXQuSldLXG4gICAgICAgICAgICA6IENlcnRpZmljYXRlRm9ybWF0LlBFTTtcbiAgICAgICAgaWYgKHRoaXMuY2VydGlmaWNhdGVFeHBpcnkgJiZcbiAgICAgICAgICAgIG5vd1RpbWUgPCB0aGlzLmNlcnRpZmljYXRlRXhwaXJ5LmdldFRpbWUoKSAmJlxuICAgICAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlRm9ybWF0ID09PSBmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNlcnRzOiB0aGlzLmNlcnRpZmljYXRlQ2FjaGUsIGZvcm1hdCB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIENlcnRpZmljYXRlRm9ybWF0LlBFTTpcbiAgICAgICAgICAgICAgICB1cmwgPSBPQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9GRURFUkFURURfU0lHTk9OX1BFTV9DRVJUU19VUkxfO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDZXJ0aWZpY2F0ZUZvcm1hdC5KV0s6XG4gICAgICAgICAgICAgICAgdXJsID0gT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfRkVERVJBVEVEX1NJR05PTl9KV0tfQ0VSVFNfVVJMXztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjZXJ0aWZpY2F0ZSBmb3JtYXQgJHtmb3JtYXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7IHVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBGYWlsZWQgdG8gcmV0cmlldmUgdmVyaWZpY2F0aW9uIGNlcnRpZmljYXRlczogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gcmVzID8gcmVzLmhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNhY2hlQWdlID0gLTE7XG4gICAgICAgIGlmIChjYWNoZUNvbnRyb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKCdtYXgtYWdlPShbMC05XSopJyk7XG4gICAgICAgICAgICBjb25zdCByZWdleFJlc3VsdCA9IHBhdHRlcm4uZXhlYyhjYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgaWYgKHJlZ2V4UmVzdWx0ICYmIHJlZ2V4UmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3VsdHMgd2l0aCBtYXgtYWdlIChpbiBzZWNvbmRzKVxuICAgICAgICAgICAgICAgIGNhY2hlQWdlID0gTnVtYmVyKHJlZ2V4UmVzdWx0WzFdKSAqIDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjZXJ0aWZpY2F0ZXMgPSB7fTtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgQ2VydGlmaWNhdGVGb3JtYXQuUEVNOlxuICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlcyA9IHJlcy5kYXRhO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDZXJ0aWZpY2F0ZUZvcm1hdC5KV0s6XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVzLmRhdGEua2V5cykge1xuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZXNba2V5LmtpZF0gPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNlcnRpZmljYXRlIGZvcm1hdCAke2Zvcm1hdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlRXhwaXJ5ID1cbiAgICAgICAgICAgIGNhY2hlQWdlID09PSAtMSA/IG51bGwgOiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgY2FjaGVBZ2UpO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlQ2FjaGUgPSBjZXJ0aWZpY2F0ZXM7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVDYWNoZUZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHsgY2VydHM6IGNlcnRpZmljYXRlcywgZm9ybWF0LCByZXMgfTtcbiAgICB9XG4gICAgZ2V0SWFwUHVibGljS2V5cyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0SWFwUHVibGljS2V5c0FzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIucHVia2V5cywgci5yZXMpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJYXBQdWJsaWNLZXlzQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRJYXBQdWJsaWNLZXlzQXN5bmMoKSB7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGNvbnN0IHVybCA9IE9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX0lBUF9QVUJMSUNfS0VZX1VSTF87XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3QoeyB1cmwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgRmFpbGVkIHRvIHJldHJpZXZlIHZlcmlmaWNhdGlvbiBjZXJ0aWZpY2F0ZXM6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHB1YmtleXM6IHJlcy5kYXRhLCByZXMgfTtcbiAgICB9XG4gICAgdmVyaWZ5U2lnbmVkSnd0V2l0aENlcnRzKCkge1xuICAgICAgICAvLyBUbyBtYWtlIHRoZSBjb2RlIGNvbXBhdGlibGUgd2l0aCBicm93c2VyIFN1YnRsZUNyeXB0byB3ZSBuZWVkIHRvIG1ha2VcbiAgICAgICAgLy8gdGhpcyBtZXRob2QgYXN5bmMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVyaWZ5U2lnbmVkSnd0V2l0aENlcnRzIGlzIHJlbW92ZWQsIHBsZWFzZSB1c2UgdmVyaWZ5U2lnbmVkSnd0V2l0aENlcnRzQXN5bmMgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoZSBpZCB0b2tlbiBpcyBzaWduZWQgd2l0aCB0aGUgY29ycmVjdCBjZXJ0aWZpY2F0ZVxuICAgICAqIGFuZCBpcyBmcm9tIHRoZSBjb3JyZWN0IGF1ZGllbmNlLlxuICAgICAqIEBwYXJhbSBqd3QgVGhlIGp3dCB0byB2ZXJpZnkgKFRoZSBJRCBUb2tlbiBpbiB0aGlzIGNhc2UpLlxuICAgICAqIEBwYXJhbSBjZXJ0cyBUaGUgYXJyYXkgb2YgY2VydHMgdG8gdGVzdCB0aGUgand0IGFnYWluc3QuXG4gICAgICogQHBhcmFtIHJlcXVpcmVkQXVkaWVuY2UgVGhlIGF1ZGllbmNlIHRvIHRlc3QgdGhlIGp3dCBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSBpc3N1ZXJzIFRoZSBhbGxvd2VkIGlzc3VlcnMgb2YgdGhlIGp3dCAoT3B0aW9uYWwpLlxuICAgICAqIEBwYXJhbSBtYXhFeHBpcnkgVGhlIG1heCBleHBpcnkgdGhlIGNlcnRpZmljYXRlIGNhbiBiZSAoT3B0aW9uYWwpLlxuICAgICAqIEByZXR1cm4gUmV0dXJucyBhIHByb21pc2UgcmVzb2x2aW5nIHRvIExvZ2luVGlja2V0IG9uIHZlcmlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyB2ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHNBc3luYyhqd3QsIGNlcnRzLCByZXF1aXJlZEF1ZGllbmNlLCBpc3N1ZXJzLCBtYXhFeHBpcnkpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvID0gKDAsIGNyeXB0b18xLmNyZWF0ZUNyeXB0bykoKTtcbiAgICAgICAgaWYgKCFtYXhFeHBpcnkpIHtcbiAgICAgICAgICAgIG1heEV4cGlyeSA9IE9BdXRoMkNsaWVudC5NQVhfVE9LRU5fTElGRVRJTUVfU0VDU187XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqd3Quc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdG9rZW46ICcgKyBqd3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IHNlZ21lbnRzWzBdICsgJy4nICsgc2VnbWVudHNbMV07XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSBzZWdtZW50c1syXTtcbiAgICAgICAgbGV0IGVudmVsb3BlO1xuICAgICAgICBsZXQgcGF5bG9hZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVudmVsb3BlID0gSlNPTi5wYXJzZShjcnlwdG8uZGVjb2RlQmFzZTY0U3RyaW5nVXRmOChzZWdtZW50c1swXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYENhbid0IHBhcnNlIHRva2VuIGVudmVsb3BlOiAke3NlZ21lbnRzWzBdfSc6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVudmVsb3BlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwYXJzZSB0b2tlbiBlbnZlbG9wZTogXCIgKyBzZWdtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNyeXB0by5kZWNvZGVCYXNlNjRTdHJpbmdVdGY4KHNlZ21lbnRzWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ2FuJ3QgcGFyc2UgdG9rZW4gcGF5bG9hZCAnJHtzZWdtZW50c1swXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGFyc2UgdG9rZW4gcGF5bG9hZDogXCIgKyBzZWdtZW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2VydHMsIGVudmVsb3BlLmtpZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHByZXNlbnQsIHRoZW4gdGhlcmUncyBubyByZWFzb24gdG8gYXR0ZW1wdCB2ZXJpZmljYXRpb25cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGVtIGZvdW5kIGZvciBlbnZlbG9wZTogJyArIEpTT04uc3RyaW5naWZ5KGVudmVsb3BlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VydCA9IGNlcnRzW2VudmVsb3BlLmtpZF07XG4gICAgICAgIGlmIChlbnZlbG9wZS5hbGcgPT09ICdFUzI1NicpIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGZvcm1hdEVjZHNhLmpvc2VUb0RlcihzaWduYXR1cmUsICdFUzI1NicpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGNyeXB0by52ZXJpZnkoY2VydCwgc2lnbmVkLCBzaWduYXR1cmUpO1xuICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4gc2lnbmF0dXJlOiAnICsgand0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBheWxvYWQuaWF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlzc3VlIHRpbWUgaW4gdG9rZW46ICcgKyBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXlsb2FkLmV4cCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBleHBpcmF0aW9uIHRpbWUgaW4gdG9rZW46ICcgKyBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWF0ID0gTnVtYmVyKHBheWxvYWQuaWF0KTtcbiAgICAgICAgaWYgKGlzTmFOKGlhdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lhdCBmaWVsZCB1c2luZyBpbnZhbGlkIGZvcm1hdCcpO1xuICAgICAgICBjb25zdCBleHAgPSBOdW1iZXIocGF5bG9hZC5leHApO1xuICAgICAgICBpZiAoaXNOYU4oZXhwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwIGZpZWxkIHVzaW5nIGludmFsaWQgZm9ybWF0Jyk7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICAgICAgaWYgKGV4cCA+PSBub3cgKyBtYXhFeHBpcnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwaXJhdGlvbiB0aW1lIHRvbyBmYXIgaW4gZnV0dXJlOiAnICsgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVhcmxpZXN0ID0gaWF0IC0gT0F1dGgyQ2xpZW50LkNMT0NLX1NLRVdfU0VDU187XG4gICAgICAgIGNvbnN0IGxhdGVzdCA9IGV4cCArIE9BdXRoMkNsaWVudC5DTE9DS19TS0VXX1NFQ1NfO1xuICAgICAgICBpZiAobm93IDwgZWFybGllc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gdXNlZCB0b28gZWFybHksICcgK1xuICAgICAgICAgICAgICAgIG5vdyArXG4gICAgICAgICAgICAgICAgJyA8ICcgK1xuICAgICAgICAgICAgICAgIGVhcmxpZXN0ICtcbiAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdyA+IGxhdGVzdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiB1c2VkIHRvbyBsYXRlLCAnICtcbiAgICAgICAgICAgICAgICBub3cgK1xuICAgICAgICAgICAgICAgICcgPiAnICtcbiAgICAgICAgICAgICAgICBsYXRlc3QgK1xuICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNzdWVycyAmJiBpc3N1ZXJzLmluZGV4T2YocGF5bG9hZC5pc3MpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlzc3VlciwgZXhwZWN0ZWQgb25lIG9mIFsnICtcbiAgICAgICAgICAgICAgICBpc3N1ZXJzICtcbiAgICAgICAgICAgICAgICAnXSwgYnV0IGdvdCAnICtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhlIGF1ZGllbmNlIG1hdGNoZXMgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZEF1ZGllbmNlICE9PSAndW5kZWZpbmVkJyAmJiByZXF1aXJlZEF1ZGllbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBhdWQgPSBwYXlsb2FkLmF1ZDtcbiAgICAgICAgICAgIGxldCBhdWRWZXJpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVpcmVkQXVkaWVuY2UgaXMgYW4gYXJyYXksIGNoZWNrIGlmIGl0IGNvbnRhaW5zIHRva2VuXG4gICAgICAgICAgICAvLyBhdWRpZW5jZVxuICAgICAgICAgICAgaWYgKHJlcXVpcmVkQXVkaWVuY2UuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXVkVmVyaWZpZWQgPSByZXF1aXJlZEF1ZGllbmNlLmluZGV4T2YoYXVkKSA+IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXVkVmVyaWZpZWQgPSBhdWQgPT09IHJlcXVpcmVkQXVkaWVuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF1ZFZlcmlmaWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZWNpcGllbnQsIHBheWxvYWQgYXVkaWVuY2UgIT0gcmVxdWlyZWRBdWRpZW5jZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbG9naW50aWNrZXRfMS5Mb2dpblRpY2tldChlbnZlbG9wZSwgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBBY2Nlc3NUb2tlblJlc3BvbnNlIHR5cGUgaWZcbiAgICAgKiByZWZyZXNoSGFuZGxlciBpcyBkZWZpbmVkLlxuICAgICAqIElmIG5vdCwgbm90aGluZyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9jZXNzQW5kVmFsaWRhdGVSZWZyZXNoSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlZnJlc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIHJlZnJlc2hIYW5kbGVyIGNhbGxiYWNrLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VuUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSB0b2tlbiBpcyBleHBpcmVkIG9yIHdpbGwgZXhwaXJlIHdpdGhpblxuICAgICAqIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc21pbGxpc2Vjb25kcy5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyBleHBpcnkgdGltZSwgYXNzdW1lcyB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQgb3IgZXhwaXJpbmcuXG4gICAgICovXG4gICAgaXNUb2tlbkV4cGlyaW5nKCkge1xuICAgICAgICBjb25zdCBleHBpcnlEYXRlID0gdGhpcy5jcmVkZW50aWFscy5leHBpcnlfZGF0ZTtcbiAgICAgICAgcmV0dXJuIGV4cGlyeURhdGVcbiAgICAgICAgICAgID8gZXhwaXJ5RGF0ZSA8PSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuT0F1dGgyQ2xpZW50ID0gT0F1dGgyQ2xpZW50O1xuT0F1dGgyQ2xpZW50LkdPT0dMRV9UT0tFTl9JTkZPX1VSTCA9ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS90b2tlbmluZm8nO1xuLyoqXG4gKiBUaGUgYmFzZSBVUkwgZm9yIGF1dGggZW5kcG9pbnRzLlxuICovXG5PQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9BVVRIX0JBU0VfVVJMXyA9ICdodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20vby9vYXV0aDIvdjIvYXV0aCc7XG4vKipcbiAqIFRoZSBiYXNlIGVuZHBvaW50IGZvciB0b2tlbiByZXRyaWV2YWwuXG4gKi9cbk9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX1RPS0VOX1VSTF8gPSAnaHR0cHM6Ly9vYXV0aDIuZ29vZ2xlYXBpcy5jb20vdG9rZW4nO1xuLyoqXG4gKiBUaGUgYmFzZSBlbmRwb2ludCB0byByZXZva2UgdG9rZW5zLlxuICovXG5PQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9SRVZPS0VfVVJMXyA9ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS9yZXZva2UnO1xuLyoqXG4gKiBHb29nbGUgU2lnbiBvbiBjZXJ0aWZpY2F0ZXMgaW4gUEVNIGZvcm1hdC5cbiAqL1xuT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfRkVERVJBVEVEX1NJR05PTl9QRU1fQ0VSVFNfVVJMXyA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9vYXV0aDIvdjEvY2VydHMnO1xuLyoqXG4gKiBHb29nbGUgU2lnbiBvbiBjZXJ0aWZpY2F0ZXMgaW4gSldLIGZvcm1hdC5cbiAqL1xuT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfRkVERVJBVEVEX1NJR05PTl9KV0tfQ0VSVFNfVVJMXyA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9vYXV0aDIvdjMvY2VydHMnO1xuLyoqXG4gKiBHb29nbGUgU2lnbiBvbiBjZXJ0aWZpY2F0ZXMgaW4gSldLIGZvcm1hdC5cbiAqL1xuT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfSUFQX1BVQkxJQ19LRVlfVVJMXyA9ICdodHRwczovL3d3dy5nc3RhdGljLmNvbS9pYXAvdmVyaWZ5L3B1YmxpY19rZXknO1xuLyoqXG4gKiBDbG9jayBza2V3IC0gZml2ZSBtaW51dGVzIGluIHNlY29uZHNcbiAqL1xuT0F1dGgyQ2xpZW50LkNMT0NLX1NLRVdfU0VDU18gPSAzMDA7XG4vKipcbiAqIE1heCBUb2tlbiBMaWZldGltZSBpcyBvbmUgZGF5IGluIHNlY29uZHNcbiAqL1xuT0F1dGgyQ2xpZW50Lk1BWF9UT0tFTl9MSUZFVElNRV9TRUNTXyA9IDg2NDAwO1xuLyoqXG4gKiBUaGUgYWxsb3dlZCBvYXV0aCB0b2tlbiBpc3N1ZXJzLlxuICovXG5PQXV0aDJDbGllbnQuSVNTVUVSU18gPSBbXG4gICAgJ2FjY291bnRzLmdvb2dsZS5jb20nLFxuICAgICdodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20nLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9hdXRoMmNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/oauth2client.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/oauth2common.js":
/*!**************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/oauth2common.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getErrorFromOAuthErrorResponse = exports.OAuthClientAuthHandler = void 0;\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(api)/../node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** List of HTTP methods that accept request bodies. */\nconst METHODS_SUPPORTING_REQUEST_BODY = ['PUT', 'POST', 'PATCH'];\n/**\n * Abstract class for handling client authentication in OAuth-based\n * operations.\n * When request-body client authentication is used, only application/json and\n * application/x-www-form-urlencoded content types for HTTP methods that support\n * request bodies are supported.\n */\nclass OAuthClientAuthHandler {\n    /**\n     * Instantiates an OAuth client authentication handler.\n     * @param clientAuthentication The client auth credentials.\n     */\n    constructor(clientAuthentication) {\n        this.clientAuthentication = clientAuthentication;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Applies client authentication on the OAuth request's headers or POST\n     * body but does not process the request.\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */\n    applyClientAuthenticationOptions(opts, bearerToken) {\n        // Inject authenticated header.\n        this.injectAuthenticatedHeaders(opts, bearerToken);\n        // Inject authenticated request body.\n        if (!bearerToken) {\n            this.injectAuthenticatedRequestBody(opts);\n        }\n    }\n    /**\n     * Applies client authentication on the request's header if either\n     * basic authentication or bearer token authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */\n    injectAuthenticatedHeaders(opts, bearerToken) {\n        var _a;\n        // Bearer token prioritized higher than basic Auth.\n        if (bearerToken) {\n            opts.headers = opts.headers || {};\n            Object.assign(opts.headers, {\n                Authorization: `Bearer ${bearerToken}}`,\n            });\n        }\n        else if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === 'basic') {\n            opts.headers = opts.headers || {};\n            const clientId = this.clientAuthentication.clientId;\n            const clientSecret = this.clientAuthentication.clientSecret || '';\n            const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);\n            Object.assign(opts.headers, {\n                Authorization: `Basic ${base64EncodedCreds}`,\n            });\n        }\n    }\n    /**\n     * Applies client authentication on the request's body if request-body\n     * client authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     */\n    injectAuthenticatedRequestBody(opts) {\n        var _a;\n        if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === 'request-body') {\n            const method = (opts.method || 'GET').toUpperCase();\n            // Inject authenticated request body.\n            if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {\n                // Get content-type.\n                let contentType;\n                const headers = opts.headers || {};\n                for (const key in headers) {\n                    if (key.toLowerCase() === 'content-type' && headers[key]) {\n                        contentType = headers[key].toLowerCase();\n                        break;\n                    }\n                }\n                if (contentType === 'application/x-www-form-urlencoded') {\n                    opts.data = opts.data || '';\n                    const data = querystring.parse(opts.data);\n                    Object.assign(data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || '',\n                    });\n                    opts.data = querystring.stringify(data);\n                }\n                else if (contentType === 'application/json') {\n                    opts.data = opts.data || {};\n                    Object.assign(opts.data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || '',\n                    });\n                }\n                else {\n                    throw new Error(`${contentType} content-types are not supported with ` +\n                        `${this.clientAuthentication.confidentialClientType} ` +\n                        'client authentication');\n                }\n            }\n            else {\n                throw new Error(`${method} HTTP method does not support ` +\n                    `${this.clientAuthentication.confidentialClientType} ` +\n                    'client authentication');\n            }\n        }\n    }\n}\nexports.OAuthClientAuthHandler = OAuthClientAuthHandler;\n/**\n * Converts an OAuth error response to a native JavaScript Error.\n * @param resp The OAuth error response to convert to a native Error object.\n * @param err The optional original error. If provided, the error properties\n *   will be copied to the new error.\n * @return The converted native Error object.\n */\nfunction getErrorFromOAuthErrorResponse(resp, err) {\n    // Error response.\n    const errorCode = resp.error;\n    const errorDescription = resp.error_description;\n    const errorUri = resp.error_uri;\n    let message = `Error code ${errorCode}`;\n    if (typeof errorDescription !== 'undefined') {\n        message += `: ${errorDescription}`;\n    }\n    if (typeof errorUri !== 'undefined') {\n        message += ` - ${errorUri}`;\n    }\n    const newError = new Error(message);\n    // Copy properties from original error to newly generated error.\n    if (err) {\n        const keys = Object.keys(err);\n        if (err.stack) {\n            // Copy error.stack if available.\n            keys.push('stack');\n        }\n        keys.forEach(key => {\n            // Do not overwrite the message field.\n            if (key !== 'message') {\n                Object.defineProperty(newError, key, {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    value: err[key],\n                    writable: false,\n                    enumerable: true,\n                });\n            }\n        });\n    }\n    return newError;\n}\nexports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;\n//# sourceMappingURL=oauth2common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvb2F1dGgyY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0NBQXNDLEdBQUcsOEJBQThCO0FBQ3ZFLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDhGQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3RELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVMsR0FBRyxhQUFhO0FBQ3RHO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRCwyQkFBMkIsa0RBQWtEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0MsdUJBQXVCLGtEQUFrRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL29hdXRoMmNvbW1vbi5qcz9hNDA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSA9IGV4cG9ydHMuT0F1dGhDbGllbnRBdXRoSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2NyeXB0b1wiKTtcbi8qKiBMaXN0IG9mIEhUVFAgbWV0aG9kcyB0aGF0IGFjY2VwdCByZXF1ZXN0IGJvZGllcy4gKi9cbmNvbnN0IE1FVEhPRFNfU1VQUE9SVElOR19SRVFVRVNUX0JPRFkgPSBbJ1BVVCcsICdQT1NUJywgJ1BBVENIJ107XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZvciBoYW5kbGluZyBjbGllbnQgYXV0aGVudGljYXRpb24gaW4gT0F1dGgtYmFzZWRcbiAqIG9wZXJhdGlvbnMuXG4gKiBXaGVuIHJlcXVlc3QtYm9keSBjbGllbnQgYXV0aGVudGljYXRpb24gaXMgdXNlZCwgb25seSBhcHBsaWNhdGlvbi9qc29uIGFuZFxuICogYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIGNvbnRlbnQgdHlwZXMgZm9yIEhUVFAgbWV0aG9kcyB0aGF0IHN1cHBvcnRcbiAqIHJlcXVlc3QgYm9kaWVzIGFyZSBzdXBwb3J0ZWQuXG4gKi9cbmNsYXNzIE9BdXRoQ2xpZW50QXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBPQXV0aCBjbGllbnQgYXV0aGVudGljYXRpb24gaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gY2xpZW50QXV0aGVudGljYXRpb24gVGhlIGNsaWVudCBhdXRoIGNyZWRlbnRpYWxzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudEF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24gPSBjbGllbnRBdXRoZW50aWNhdGlvbjtcbiAgICAgICAgdGhpcy5jcnlwdG8gPSAoMCwgY3J5cHRvXzEuY3JlYXRlQ3J5cHRvKSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGNsaWVudCBhdXRoZW50aWNhdGlvbiBvbiB0aGUgT0F1dGggcmVxdWVzdCdzIGhlYWRlcnMgb3IgUE9TVFxuICAgICAqIGJvZHkgYnV0IGRvZXMgbm90IHByb2Nlc3MgdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEdheGlvc09wdGlvbnMgd2hvc2UgaGVhZGVycyBvciBkYXRhIGFyZSB0byBiZSBtb2RpZmllZFxuICAgICAqICAgZGVwZW5kaW5nIG9uIHRoZSBjbGllbnQgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIHRvIGJlIHVzZWQuXG4gICAgICogQHBhcmFtIGJlYXJlclRva2VuIFRoZSBvcHRpb25hbCBiZWFyZXIgdG9rZW4gdG8gdXNlIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiAgIFdoZW4gdGhpcyBpcyB1c2VkLCBubyBjbGllbnQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgYXJlIG5lZWRlZC5cbiAgICAgKi9cbiAgICBhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyhvcHRzLCBiZWFyZXJUb2tlbikge1xuICAgICAgICAvLyBJbmplY3QgYXV0aGVudGljYXRlZCBoZWFkZXIuXG4gICAgICAgIHRoaXMuaW5qZWN0QXV0aGVudGljYXRlZEhlYWRlcnMob3B0cywgYmVhcmVyVG9rZW4pO1xuICAgICAgICAvLyBJbmplY3QgYXV0aGVudGljYXRlZCByZXF1ZXN0IGJvZHkuXG4gICAgICAgIGlmICghYmVhcmVyVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0QXV0aGVudGljYXRlZFJlcXVlc3RCb2R5KG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG9uIHRoZSByZXF1ZXN0J3MgaGVhZGVyIGlmIGVpdGhlclxuICAgICAqIGJhc2ljIGF1dGhlbnRpY2F0aW9uIG9yIGJlYXJlciB0b2tlbiBhdXRoZW50aWNhdGlvbiBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBHYXhpb3NPcHRpb25zIHdob3NlIGhlYWRlcnMgb3IgZGF0YSBhcmUgdG8gYmUgbW9kaWZpZWRcbiAgICAgKiAgIGRlcGVuZGluZyBvbiB0aGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSB0byBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSBiZWFyZXJUb2tlbiBUaGUgb3B0aW9uYWwgYmVhcmVyIHRva2VuIHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb24uXG4gICAgICogICBXaGVuIHRoaXMgaXMgdXNlZCwgbm8gY2xpZW50IGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGFyZSBuZWVkZWQuXG4gICAgICovXG4gICAgaW5qZWN0QXV0aGVudGljYXRlZEhlYWRlcnMob3B0cywgYmVhcmVyVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBCZWFyZXIgdG9rZW4gcHJpb3JpdGl6ZWQgaGlnaGVyIHRoYW4gYmFzaWMgQXV0aC5cbiAgICAgICAgaWYgKGJlYXJlclRva2VuKSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtiZWFyZXJUb2tlbn19YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2EgPSB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlkZW50aWFsQ2xpZW50VHlwZSkgPT09ICdiYXNpYycpIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jbGllbnRJZDtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFNlY3JldCA9IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50U2VjcmV0IHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgYmFzZTY0RW5jb2RlZENyZWRzID0gdGhpcy5jcnlwdG8uZW5jb2RlQmFzZTY0U3RyaW5nVXRmOChgJHtjbGllbnRJZH06JHtjbGllbnRTZWNyZXR9YCk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCYXNpYyAke2Jhc2U2NEVuY29kZWRDcmVkc31gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBjbGllbnQgYXV0aGVudGljYXRpb24gb24gdGhlIHJlcXVlc3QncyBib2R5IGlmIHJlcXVlc3QtYm9keVxuICAgICAqIGNsaWVudCBhdXRoZW50aWNhdGlvbiBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBHYXhpb3NPcHRpb25zIHdob3NlIGhlYWRlcnMgb3IgZGF0YSBhcmUgdG8gYmUgbW9kaWZpZWRcbiAgICAgKiAgIGRlcGVuZGluZyBvbiB0aGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSB0byBiZSB1c2VkLlxuICAgICAqL1xuICAgIGluamVjdEF1dGhlbnRpY2F0ZWRSZXF1ZXN0Qm9keShvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlkZW50aWFsQ2xpZW50VHlwZSkgPT09ICdyZXF1ZXN0LWJvZHknKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSAob3B0cy5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAvLyBJbmplY3QgYXV0aGVudGljYXRlZCByZXF1ZXN0IGJvZHkuXG4gICAgICAgICAgICBpZiAoTUVUSE9EU19TVVBQT1JUSU5HX1JFUVVFU1RfQk9EWS5pbmRleE9mKG1ldGhvZCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGNvbnRlbnQtdHlwZS5cbiAgICAgICAgICAgICAgICBsZXQgY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScgJiYgaGVhZGVyc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGhlYWRlcnNba2V5XS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmRhdGEgPSBvcHRzLmRhdGEgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBxdWVyeXN0cmluZy5wYXJzZShvcHRzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50U2VjcmV0IHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kYXRhID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZGF0YSA9IG9wdHMuZGF0YSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLmRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50U2VjcmV0IHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZW50VHlwZX0gY29udGVudC10eXBlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jb25maWRlbnRpYWxDbGllbnRUeXBlfSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGllbnQgYXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWV0aG9kfSBIVFRQIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNvbmZpZGVudGlhbENsaWVudFR5cGV9IGAgK1xuICAgICAgICAgICAgICAgICAgICAnY2xpZW50IGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIgPSBPQXV0aENsaWVudEF1dGhIYW5kbGVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBPQXV0aCBlcnJvciByZXNwb25zZSB0byBhIG5hdGl2ZSBKYXZhU2NyaXB0IEVycm9yLlxuICogQHBhcmFtIHJlc3AgVGhlIE9BdXRoIGVycm9yIHJlc3BvbnNlIHRvIGNvbnZlcnQgdG8gYSBuYXRpdmUgRXJyb3Igb2JqZWN0LlxuICogQHBhcmFtIGVyciBUaGUgb3B0aW9uYWwgb3JpZ2luYWwgZXJyb3IuIElmIHByb3ZpZGVkLCB0aGUgZXJyb3IgcHJvcGVydGllc1xuICogICB3aWxsIGJlIGNvcGllZCB0byB0aGUgbmV3IGVycm9yLlxuICogQHJldHVybiBUaGUgY29udmVydGVkIG5hdGl2ZSBFcnJvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZShyZXNwLCBlcnIpIHtcbiAgICAvLyBFcnJvciByZXNwb25zZS5cbiAgICBjb25zdCBlcnJvckNvZGUgPSByZXNwLmVycm9yO1xuICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSByZXNwLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgIGNvbnN0IGVycm9yVXJpID0gcmVzcC5lcnJvcl91cmk7XG4gICAgbGV0IG1lc3NhZ2UgPSBgRXJyb3IgY29kZSAke2Vycm9yQ29kZX1gO1xuICAgIGlmICh0eXBlb2YgZXJyb3JEZXNjcmlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgOiAke2Vycm9yRGVzY3JpcHRpb259YDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlcnJvclVyaSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgIC0gJHtlcnJvclVyaX1gO1xuICAgIH1cbiAgICBjb25zdCBuZXdFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSBvcmlnaW5hbCBlcnJvciB0byBuZXdseSBnZW5lcmF0ZWQgZXJyb3IuXG4gICAgaWYgKGVycikge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXJyKTtcbiAgICAgICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgICAgICAgLy8gQ29weSBlcnJvci5zdGFjayBpZiBhdmFpbGFibGUuXG4gICAgICAgICAgICBrZXlzLnB1c2goJ3N0YWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIHRoZSBtZXNzYWdlIGZpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld0Vycm9yLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVycltrZXldLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RXJyb3I7XG59XG5leHBvcnRzLmdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSA9IGdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9hdXRoMmNvbW1vbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/oauth2common.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PluggableAuthClient = exports.ExecutableError = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(api)/../node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst pluggable_auth_handler_1 = __webpack_require__(/*! ./pluggable-auth-handler */ \"(api)/../node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\");\n/**\n * Error thrown from the executable run by PluggableAuthClient.\n */\nclass ExecutableError extends Error {\n    constructor(message, code) {\n        super(`The executable failed with exit code: ${code} and error message: ${message}.`);\n        this.code = code;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableError = ExecutableError;\n/**\n * The default executable timeout when none is provided, in milliseconds.\n */\nconst DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1000;\n/**\n * The minimum allowed executable timeout in milliseconds.\n */\nconst MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1000;\n/**\n * The maximum allowed executable timeout in milliseconds.\n */\nconst MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1000;\n/**\n * The environment variable to check to see if executable can be run.\n * Value must be set to '1' for the executable to run.\n */\nconst GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = 'GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES';\n/**\n * The maximum currently supported executable version.\n */\nconst MAXIMUM_EXECUTABLE_VERSION = 1;\n/**\n * PluggableAuthClient enables the exchange of workload identity pool external credentials for\n * Google access tokens by retrieving 3rd party tokens through a user supplied executable. These\n * scripts/executables are completely independent of the Google Cloud Auth libraries. These\n * credentials plug into ADC and will call the specified executable to retrieve the 3rd party token\n * to be exchanged for a Google access token.\n *\n * <p>To use these credentials, the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment variable\n * must be set to '1'. This is for security reasons.\n *\n * <p>Both OIDC and SAML are supported. The executable must adhere to a specific response format\n * defined below.\n *\n * <p>The executable must print out the 3rd party token to STDOUT in JSON format. When an\n * output_file is specified in the credential configuration, the executable must also handle writing the\n * JSON response to this file.\n *\n * <pre>\n * OIDC response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n *   \"id_token\": \"HEADER.PAYLOAD.SIGNATURE\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * SAML2 response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:saml2\",\n *   \"saml_response\": \"...\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * Error response sample:\n * {\n *   \"version\": 1,\n *   \"success\": false,\n *   \"code\": \"401\",\n *   \"message\": \"Error message.\"\n * }\n * </pre>\n *\n * <p>The \"expiration_time\" field in the JSON response is only required for successful\n * responses when an output file was specified in the credential configuration\n *\n * <p>The auth libraries will populate certain environment variables that will be accessible by the\n * executable, such as: GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE, GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE,\n * GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE, GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL, and\n * GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE.\n *\n * <p>Please see this repositories README for a complete executable request/response specification.\n */\nclass PluggableAuthClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates a PluggableAuthClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid pluggable auth credential.\n     * @param options The external account options object typically loaded from\n     *   the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super(options, additionalOptions);\n        if (!options.credential_source.executable) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        this.command = options.credential_source.executable.command;\n        if (!this.command) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        // Check if the provided timeout exists and if it is valid.\n        if (options.credential_source.executable.timeout_millis === undefined) {\n            this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;\n        }\n        else {\n            this.timeoutMillis = options.credential_source.executable.timeout_millis;\n            if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS ||\n                this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {\n                throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ` +\n                    `${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);\n            }\n        }\n        this.outputFile = options.credential_source.executable.output_file;\n        this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({\n            command: this.command,\n            timeoutMillis: this.timeoutMillis,\n            outputFile: this.outputFile,\n        });\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this calls a user provided executable which returns the subject token.\n     * The logic is summarized as:\n     * 1. Validated that the executable is allowed to run. The\n     *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to\n     *    1 for security reasons.\n     * 2. If an output file is specified by the user, check the file location\n     *    for a response. If the file exists and contains a valid response,\n     *    return the subject token from the file.\n     * 3. Call the provided executable and return response.\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        // Check if the executable is allowed to run.\n        if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== '1') {\n            throw new Error('Pluggable Auth executables need to be explicitly allowed to run by ' +\n                'setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment ' +\n                'Variable to 1.');\n        }\n        let executableResponse = undefined;\n        // Try to get cached executable response from output file.\n        if (this.outputFile) {\n            executableResponse = await this.handler.retrieveCachedResponse();\n        }\n        // If no response from output file, call the executable.\n        if (!executableResponse) {\n            // Set up environment map with required values for the executable.\n            const envMap = new Map();\n            envMap.set('GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE', this.audience);\n            envMap.set('GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE', this.subjectTokenType);\n            // Always set to 0 because interactive mode is not supported.\n            envMap.set('GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE', '0');\n            if (this.outputFile) {\n                envMap.set('GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE', this.outputFile);\n            }\n            const serviceAccountEmail = this.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                envMap.set('GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL', serviceAccountEmail);\n            }\n            executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);\n        }\n        if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {\n            throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);\n        }\n        // Check that response was successful.\n        if (!executableResponse.success) {\n            throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);\n        }\n        // Check that response contains expiration time if output file was specified.\n        if (this.outputFile) {\n            if (!executableResponse.expirationTime) {\n                throw new executable_response_1.InvalidExpirationTimeFieldError('The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.');\n            }\n        }\n        // Check that response is not expired.\n        if (executableResponse.isExpired()) {\n            throw new Error('Executable response is expired.');\n        }\n        // Return subject token from response.\n        return executableResponse.subjectToken;\n    }\n}\nexports.PluggableAuthClient = PluggableAuthClient;\n//# sourceMappingURL=pluggable-auth-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvcGx1Z2dhYmxlLWF1dGgtY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsdUJBQXVCO0FBQ3JELDZCQUE2QixtQkFBTyxDQUFDLDRHQUFzQjtBQUMzRCw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBdUI7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsb0hBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsTUFBTSxxQkFBcUIsUUFBUTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1DQUFtQztBQUM5Rix1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsMkJBQTJCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1jbGllbnQuanM/MmMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QbHVnZ2FibGVBdXRoQ2xpZW50ID0gZXhwb3J0cy5FeGVjdXRhYmxlRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbmNvbnN0IGV4ZWN1dGFibGVfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGFibGUtcmVzcG9uc2VcIik7XG5jb25zdCBwbHVnZ2FibGVfYXV0aF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyXCIpO1xuLyoqXG4gKiBFcnJvciB0aHJvd24gZnJvbSB0aGUgZXhlY3V0YWJsZSBydW4gYnkgUGx1Z2dhYmxlQXV0aENsaWVudC5cbiAqL1xuY2xhc3MgRXhlY3V0YWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoYFRoZSBleGVjdXRhYmxlIGZhaWxlZCB3aXRoIGV4aXQgY29kZTogJHtjb2RlfSBhbmQgZXJyb3IgbWVzc2FnZTogJHttZXNzYWdlfS5gKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkV4ZWN1dGFibGVFcnJvciA9IEV4ZWN1dGFibGVFcnJvcjtcbi8qKlxuICogVGhlIGRlZmF1bHQgZXhlY3V0YWJsZSB0aW1lb3V0IHdoZW4gbm9uZSBpcyBwcm92aWRlZCwgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBERUZBVUxUX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgPSAzMCAqIDEwMDA7XG4vKipcbiAqIFRoZSBtaW5pbXVtIGFsbG93ZWQgZXhlY3V0YWJsZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuY29uc3QgTUlOSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTID0gNSAqIDEwMDA7XG4vKipcbiAqIFRoZSBtYXhpbXVtIGFsbG93ZWQgZXhlY3V0YWJsZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuY29uc3QgTUFYSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTID0gMTIwICogMTAwMDtcbi8qKlxuICogVGhlIGVudmlyb25tZW50IHZhcmlhYmxlIHRvIGNoZWNrIHRvIHNlZSBpZiBleGVjdXRhYmxlIGNhbiBiZSBydW4uXG4gKiBWYWx1ZSBtdXN0IGJlIHNldCB0byAnMScgZm9yIHRoZSBleGVjdXRhYmxlIHRvIHJ1bi5cbiAqL1xuY29uc3QgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMgPSAnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMnO1xuLyoqXG4gKiBUaGUgbWF4aW11bSBjdXJyZW50bHkgc3VwcG9ydGVkIGV4ZWN1dGFibGUgdmVyc2lvbi5cbiAqL1xuY29uc3QgTUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT04gPSAxO1xuLyoqXG4gKiBQbHVnZ2FibGVBdXRoQ2xpZW50IGVuYWJsZXMgdGhlIGV4Y2hhbmdlIG9mIHdvcmtsb2FkIGlkZW50aXR5IHBvb2wgZXh0ZXJuYWwgY3JlZGVudGlhbHMgZm9yXG4gKiBHb29nbGUgYWNjZXNzIHRva2VucyBieSByZXRyaWV2aW5nIDNyZCBwYXJ0eSB0b2tlbnMgdGhyb3VnaCBhIHVzZXIgc3VwcGxpZWQgZXhlY3V0YWJsZS4gVGhlc2VcbiAqIHNjcmlwdHMvZXhlY3V0YWJsZXMgYXJlIGNvbXBsZXRlbHkgaW5kZXBlbmRlbnQgb2YgdGhlIEdvb2dsZSBDbG91ZCBBdXRoIGxpYnJhcmllcy4gVGhlc2VcbiAqIGNyZWRlbnRpYWxzIHBsdWcgaW50byBBREMgYW5kIHdpbGwgY2FsbCB0aGUgc3BlY2lmaWVkIGV4ZWN1dGFibGUgdG8gcmV0cmlldmUgdGhlIDNyZCBwYXJ0eSB0b2tlblxuICogdG8gYmUgZXhjaGFuZ2VkIGZvciBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gKlxuICogPHA+VG8gdXNlIHRoZXNlIGNyZWRlbnRpYWxzLCB0aGUgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIG11c3QgYmUgc2V0IHRvICcxJy4gVGhpcyBpcyBmb3Igc2VjdXJpdHkgcmVhc29ucy5cbiAqXG4gKiA8cD5Cb3RoIE9JREMgYW5kIFNBTUwgYXJlIHN1cHBvcnRlZC4gVGhlIGV4ZWN1dGFibGUgbXVzdCBhZGhlcmUgdG8gYSBzcGVjaWZpYyByZXNwb25zZSBmb3JtYXRcbiAqIGRlZmluZWQgYmVsb3cuXG4gKlxuICogPHA+VGhlIGV4ZWN1dGFibGUgbXVzdCBwcmludCBvdXQgdGhlIDNyZCBwYXJ0eSB0b2tlbiB0byBTVERPVVQgaW4gSlNPTiBmb3JtYXQuIFdoZW4gYW5cbiAqIG91dHB1dF9maWxlIGlzIHNwZWNpZmllZCBpbiB0aGUgY3JlZGVudGlhbCBjb25maWd1cmF0aW9uLCB0aGUgZXhlY3V0YWJsZSBtdXN0IGFsc28gaGFuZGxlIHdyaXRpbmcgdGhlXG4gKiBKU09OIHJlc3BvbnNlIHRvIHRoaXMgZmlsZS5cbiAqXG4gKiA8cHJlPlxuICogT0lEQyByZXNwb25zZSBzYW1wbGU6XG4gKiB7XG4gKiAgIFwidmVyc2lvblwiOiAxLFxuICogICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAqICAgXCJ0b2tlbl90eXBlXCI6IFwidXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6aWRfdG9rZW5cIixcbiAqICAgXCJpZF90b2tlblwiOiBcIkhFQURFUi5QQVlMT0FELlNJR05BVFVSRVwiLFxuICogICBcImV4cGlyYXRpb25fdGltZVwiOiAxNjIwNDMzMzQxXG4gKiB9XG4gKlxuICogU0FNTDIgcmVzcG9uc2Ugc2FtcGxlOlxuICoge1xuICogICBcInZlcnNpb25cIjogMSxcbiAqICAgXCJzdWNjZXNzXCI6IHRydWUsXG4gKiAgIFwidG9rZW5fdHlwZVwiOiBcInVybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOnNhbWwyXCIsXG4gKiAgIFwic2FtbF9yZXNwb25zZVwiOiBcIi4uLlwiLFxuICogICBcImV4cGlyYXRpb25fdGltZVwiOiAxNjIwNDMzMzQxXG4gKiB9XG4gKlxuICogRXJyb3IgcmVzcG9uc2Ugc2FtcGxlOlxuICoge1xuICogICBcInZlcnNpb25cIjogMSxcbiAqICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICogICBcImNvZGVcIjogXCI0MDFcIixcbiAqICAgXCJtZXNzYWdlXCI6IFwiRXJyb3IgbWVzc2FnZS5cIlxuICogfVxuICogPC9wcmU+XG4gKlxuICogPHA+VGhlIFwiZXhwaXJhdGlvbl90aW1lXCIgZmllbGQgaW4gdGhlIEpTT04gcmVzcG9uc2UgaXMgb25seSByZXF1aXJlZCBmb3Igc3VjY2Vzc2Z1bFxuICogcmVzcG9uc2VzIHdoZW4gYW4gb3V0cHV0IGZpbGUgd2FzIHNwZWNpZmllZCBpbiB0aGUgY3JlZGVudGlhbCBjb25maWd1cmF0aW9uXG4gKlxuICogPHA+VGhlIGF1dGggbGlicmFyaWVzIHdpbGwgcG9wdWxhdGUgY2VydGFpbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCB3aWxsIGJlIGFjY2Vzc2libGUgYnkgdGhlXG4gKiBleGVjdXRhYmxlLCBzdWNoIGFzOiBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BVURJRU5DRSwgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfVE9LRU5fVFlQRSxcbiAqIEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lOVEVSQUNUSVZFLCBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9JTVBFUlNPTkFURURfRU1BSUwsIGFuZFxuICogR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfT1VUUFVUX0ZJTEUuXG4gKlxuICogPHA+UGxlYXNlIHNlZSB0aGlzIHJlcG9zaXRvcmllcyBSRUFETUUgZm9yIGEgY29tcGxldGUgZXhlY3V0YWJsZSByZXF1ZXN0L3Jlc3BvbnNlIHNwZWNpZmljYXRpb24uXG4gKi9cbmNsYXNzIFBsdWdnYWJsZUF1dGhDbGllbnQgZXh0ZW5kcyBiYXNlZXh0ZXJuYWxjbGllbnRfMS5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSBQbHVnZ2FibGVBdXRoQ2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IGEgdmFsaWQgcGx1Z2dhYmxlIGF1dGggY3JlZGVudGlhbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkIGZyb21cbiAgICAgKiAgIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBQbHVnZ2FibGUgQXV0aCBcImNyZWRlbnRpYWxfc291cmNlXCIgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21tYW5kID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5leGVjdXRhYmxlLmNvbW1hbmQ7XG4gICAgICAgIGlmICghdGhpcy5jb21tYW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIFBsdWdnYWJsZSBBdXRoIFwiY3JlZGVudGlhbF9zb3VyY2VcIiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcHJvdmlkZWQgdGltZW91dCBleGlzdHMgYW5kIGlmIGl0IGlzIHZhbGlkLlxuICAgICAgICBpZiAob3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5leGVjdXRhYmxlLnRpbWVvdXRfbWlsbGlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dE1pbGxpcyA9IERFRkFVTFRfRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dE1pbGxpcyA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZS50aW1lb3V0X21pbGxpcztcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXRNaWxsaXMgPCBNSU5JTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRNaWxsaXMgPiBNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRpbWVvdXQgbXVzdCBiZSBiZXR3ZWVuICR7TUlOSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTfSBhbmQgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke01BWElNVU1fRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJU30gbWlsbGlzZWNvbmRzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RmlsZSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZS5vdXRwdXRfZmlsZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbmV3IHBsdWdnYWJsZV9hdXRoX2hhbmRsZXJfMS5QbHVnZ2FibGVBdXRoSGFuZGxlcih7XG4gICAgICAgICAgICBjb21tYW5kOiB0aGlzLmNvbW1hbmQsXG4gICAgICAgICAgICB0aW1lb3V0TWlsbGlzOiB0aGlzLnRpbWVvdXRNaWxsaXMsXG4gICAgICAgICAgICBvdXRwdXRGaWxlOiB0aGlzLm91dHB1dEZpbGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhbiBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGlzIG5lZWRlZCB0byBiZSBleGNoYW5nZWQgZm9yIGFcbiAgICAgKiBHQ1AgYWNjZXNzIHRva2VuIHZpYSBHQ1AgU1RTIGVuZHBvaW50LlxuICAgICAqIFRoaXMgdXNlcyB0aGUgYG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2VgIG9iamVjdCB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAqIHRvIHJldHJpZXZlIHRoZSB0b2tlbiB1c2luZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gdGhpcyBjYXNlLFxuICAgICAqIHRoaXMgY2FsbHMgYSB1c2VyIHByb3ZpZGVkIGV4ZWN1dGFibGUgd2hpY2ggcmV0dXJucyB0aGUgc3ViamVjdCB0b2tlbi5cbiAgICAgKiBUaGUgbG9naWMgaXMgc3VtbWFyaXplZCBhczpcbiAgICAgKiAxLiBWYWxpZGF0ZWQgdGhhdCB0aGUgZXhlY3V0YWJsZSBpcyBhbGxvd2VkIHRvIHJ1bi4gVGhlXG4gICAgICogICAgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMgZW52aXJvbm1lbnQgbXVzdCBiZSBzZXQgdG9cbiAgICAgKiAgICAxIGZvciBzZWN1cml0eSByZWFzb25zLlxuICAgICAqIDIuIElmIGFuIG91dHB1dCBmaWxlIGlzIHNwZWNpZmllZCBieSB0aGUgdXNlciwgY2hlY2sgdGhlIGZpbGUgbG9jYXRpb25cbiAgICAgKiAgICBmb3IgYSByZXNwb25zZS4gSWYgdGhlIGZpbGUgZXhpc3RzIGFuZCBjb250YWlucyBhIHZhbGlkIHJlc3BvbnNlLFxuICAgICAqICAgIHJldHVybiB0aGUgc3ViamVjdCB0b2tlbiBmcm9tIHRoZSBmaWxlLlxuICAgICAqIDMuIENhbGwgdGhlIHByb3ZpZGVkIGV4ZWN1dGFibGUgYW5kIHJldHVybiByZXNwb25zZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4dGVybmFsIHN1YmplY3QgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmV0cmlldmVTdWJqZWN0VG9rZW4oKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBleGVjdXRhYmxlIGlzIGFsbG93ZWQgdG8gcnVuLlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnZbR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVNdICE9PSAnMScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGx1Z2dhYmxlIEF1dGggZXhlY3V0YWJsZXMgbmVlZCB0byBiZSBleHBsaWNpdGx5IGFsbG93ZWQgdG8gcnVuIGJ5ICcgK1xuICAgICAgICAgICAgICAgICdzZXR0aW5nIHRoZSBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgICAgICAgICAnVmFyaWFibGUgdG8gMS4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXhlY3V0YWJsZVJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IGNhY2hlZCBleGVjdXRhYmxlIHJlc3BvbnNlIGZyb20gb3V0cHV0IGZpbGUuXG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbGUpIHtcbiAgICAgICAgICAgIGV4ZWN1dGFibGVSZXNwb25zZSA9IGF3YWl0IHRoaXMuaGFuZGxlci5yZXRyaWV2ZUNhY2hlZFJlc3BvbnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gcmVzcG9uc2UgZnJvbSBvdXRwdXQgZmlsZSwgY2FsbCB0aGUgZXhlY3V0YWJsZS5cbiAgICAgICAgaWYgKCFleGVjdXRhYmxlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCBlbnZpcm9ubWVudCBtYXAgd2l0aCByZXF1aXJlZCB2YWx1ZXMgZm9yIHRoZSBleGVjdXRhYmxlLlxuICAgICAgICAgICAgY29uc3QgZW52TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZW52TWFwLnNldCgnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQVVESUVOQ0UnLCB0aGlzLmF1ZGllbmNlKTtcbiAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX1RPS0VOX1RZUEUnLCB0aGlzLnN1YmplY3RUb2tlblR5cGUpO1xuICAgICAgICAgICAgLy8gQWx3YXlzIHNldCB0byAwIGJlY2F1c2UgaW50ZXJhY3RpdmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAgICAgZW52TWFwLnNldCgnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfSU5URVJBQ1RJVkUnLCAnMCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsZSkge1xuICAgICAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX09VVFBVVF9GSUxFJywgdGhpcy5vdXRwdXRGaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50RW1haWwgPSB0aGlzLmdldFNlcnZpY2VBY2NvdW50RW1haWwoKTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQWNjb3VudEVtYWlsKSB7XG4gICAgICAgICAgICAgICAgZW52TWFwLnNldCgnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfSU1QRVJTT05BVEVEX0VNQUlMJywgc2VydmljZUFjY291bnRFbWFpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGVjdXRhYmxlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmhhbmRsZXIucmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlKGVudk1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4ZWN1dGFibGVSZXNwb25zZS52ZXJzaW9uID4gTUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyc2lvbiBvZiBleGVjdXRhYmxlIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLCBtYXhpbXVtIHN1cHBvcnRlZCB2ZXJzaW9uIGlzICR7TUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT059LmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICAgIGlmICghZXhlY3V0YWJsZVJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGVjdXRhYmxlRXJyb3IoZXhlY3V0YWJsZVJlc3BvbnNlLmVycm9yTWVzc2FnZSwgZXhlY3V0YWJsZVJlc3BvbnNlLmVycm9yQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSBjb250YWlucyBleHBpcmF0aW9uIHRpbWUgaWYgb3V0cHV0IGZpbGUgd2FzIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsZSkge1xuICAgICAgICAgICAgaWYgKCFleGVjdXRhYmxlUmVzcG9uc2UuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IoJ1RoZSBleGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiB0aGUgYGV4cGlyYXRpb25fdGltZWAgZmllbGQgZm9yIHN1Y2Nlc3NmdWwgcmVzcG9uc2VzIHdoZW4gYW4gb3V0cHV0X2ZpbGUgaGFzIGJlZW4gc3BlY2lmaWVkIGluIHRoZSBjb25maWd1cmF0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2UgaXMgbm90IGV4cGlyZWQuXG4gICAgICAgIGlmIChleGVjdXRhYmxlUmVzcG9uc2UuaXNFeHBpcmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhlY3V0YWJsZSByZXNwb25zZSBpcyBleHBpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBzdWJqZWN0IHRva2VuIGZyb20gcmVzcG9uc2UuXG4gICAgICAgIHJldHVybiBleGVjdXRhYmxlUmVzcG9uc2Uuc3ViamVjdFRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aENsaWVudCA9IFBsdWdnYWJsZUF1dGhDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnZ2FibGUtYXV0aC1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js":
/*!************************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PluggableAuthHandler = void 0;\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(api)/../node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(api)/../node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\nclass PluggableAuthHandler {\n    /**\n     * Instantiates a PluggableAuthHandler instance using the provided\n     * PluggableAuthHandlerOptions object.\n     */\n    constructor(options) {\n        if (!options.command) {\n            throw new Error('No command provided.');\n        }\n        this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n        this.timeoutMillis = options.timeoutMillis;\n        if (!this.timeoutMillis) {\n            throw new Error('No timeoutMillis provided.');\n        }\n        this.outputFile = options.outputFile;\n    }\n    /**\n     * Calls user provided executable to get a 3rd party subject token and\n     * returns the response.\n     * @param envMap a Map of additional Environment Variables required for\n     *   the executable.\n     * @return A promise that resolves with the executable response.\n     */\n    retrieveResponseFromExecutable(envMap) {\n        return new Promise((resolve, reject) => {\n            // Spawn process to run executable using added environment variables.\n            const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n                env: { ...process.env, ...Object.fromEntries(envMap) },\n            });\n            let output = '';\n            // Append stdout to output as executable runs.\n            child.stdout.on('data', (data) => {\n                output += data;\n            });\n            // Append stderr as executable runs.\n            child.stderr.on('data', (err) => {\n                output += err;\n            });\n            // Set up a timeout to end the child process and throw an error.\n            const timeout = setTimeout(() => {\n                // Kill child process and remove listeners so 'close' event doesn't get\n                // read after child process is killed.\n                child.removeAllListeners();\n                child.kill();\n                return reject(new Error('The executable failed to finish within the timeout specified.'));\n            }, this.timeoutMillis);\n            child.on('close', (code) => {\n                // Cancel timeout if executable closes before timeout is reached.\n                clearTimeout(timeout);\n                if (code === 0) {\n                    // If the executable completed successfully, try to return the parsed response.\n                    try {\n                        const responseJson = JSON.parse(output);\n                        const response = new executable_response_1.ExecutableResponse(responseJson);\n                        return resolve(response);\n                    }\n                    catch (error) {\n                        if (error instanceof executable_response_1.ExecutableResponseError) {\n                            return reject(error);\n                        }\n                        return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n                    }\n                }\n                else {\n                    return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n                }\n            });\n        });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */\n    async retrieveCachedResponse() {\n        if (!this.outputFile || this.outputFile.length === 0) {\n            return undefined;\n        }\n        let filePath;\n        try {\n            filePath = await fs.promises.realpath(this.outputFile);\n        }\n        catch (_a) {\n            // If file path cannot be resolved, return undefined.\n            return undefined;\n        }\n        if (!(await fs.promises.lstat(filePath)).isFile()) {\n            // If path does not lead to file, return undefined.\n            return undefined;\n        }\n        const responseString = await fs.promises.readFile(filePath, {\n            encoding: 'utf8',\n        });\n        if (responseString === '') {\n            return undefined;\n        }\n        try {\n            const responseJson = JSON.parse(responseString);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            // Check if response is successful and unexpired.\n            if (response.isValid()) {\n                return new executable_response_1.ExecutableResponse(responseJson);\n            }\n            return undefined;\n        }\n        catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n                throw error;\n            }\n            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n        }\n    }\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */\n    static parseCommand(command) {\n        // Split the command into components by splitting on spaces,\n        // unless spaces are contained in quotation marks.\n        const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n        if (!components) {\n            throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n        }\n        // Remove quotation marks from the beginning and end of each component if they are present.\n        for (let i = 0; i < components.length; i++) {\n            if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n                components[i] = components[i].slice(1, -1);\n            }\n        }\n        return components;\n    }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;\n//# sourceMappingURL=pluggable-auth-handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvcGx1Z2dhYmxlLWF1dGgtaGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QixnQ0FBZ0MsbUJBQU8sQ0FBQyxrSEFBeUI7QUFDakUsOEJBQThCLG1CQUFPLENBQUMsOEdBQXVCO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLG9DQUFlO0FBQzVDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUErQztBQUN0RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksT0FBTztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILGVBQWU7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyLmpzPzFjYjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWNsaWVudFwiKTtcbmNvbnN0IGV4ZWN1dGFibGVfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGFibGUtcmVzcG9uc2VcIik7XG5jb25zdCBjaGlsZFByb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuLyoqXG4gKiBBIGhhbmRsZXIgdXNlZCB0byByZXRyaWV2ZSAzcmQgcGFydHkgdG9rZW4gcmVzcG9uc2VzIGZyb20gdXNlciBkZWZpbmVkXG4gKiBleGVjdXRhYmxlcyBhbmQgY2FjaGVkIGZpbGUgb3V0cHV0IGZvciB0aGUgUGx1Z2dhYmxlQXV0aENsaWVudCBjbGFzcy5cbiAqL1xuY2xhc3MgUGx1Z2dhYmxlQXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIFBsdWdnYWJsZUF1dGhIYW5kbGVyIGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZFxuICAgICAqIFBsdWdnYWJsZUF1dGhIYW5kbGVyT3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuY29tbWFuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb21tYW5kIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWFuZENvbXBvbmVudHMgPSBQbHVnZ2FibGVBdXRoSGFuZGxlci5wYXJzZUNvbW1hbmQob3B0aW9ucy5jb21tYW5kKTtcbiAgICAgICAgdGhpcy50aW1lb3V0TWlsbGlzID0gb3B0aW9ucy50aW1lb3V0TWlsbGlzO1xuICAgICAgICBpZiAoIXRoaXMudGltZW91dE1pbGxpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0aW1lb3V0TWlsbGlzIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RmlsZSA9IG9wdGlvbnMub3V0cHV0RmlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdXNlciBwcm92aWRlZCBleGVjdXRhYmxlIHRvIGdldCBhIDNyZCBwYXJ0eSBzdWJqZWN0IHRva2VuIGFuZFxuICAgICAqIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBlbnZNYXAgYSBNYXAgb2YgYWRkaXRpb25hbCBFbnZpcm9ubWVudCBWYXJpYWJsZXMgcmVxdWlyZWQgZm9yXG4gICAgICogICB0aGUgZXhlY3V0YWJsZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4ZWN1dGFibGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgcmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlKGVudk1hcCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gU3Bhd24gcHJvY2VzcyB0byBydW4gZXhlY3V0YWJsZSB1c2luZyBhZGRlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkUHJvY2Vzcy5zcGF3bih0aGlzLmNvbW1hbmRDb21wb25lbnRzWzBdLCB0aGlzLmNvbW1hbmRDb21wb25lbnRzLnNsaWNlKDEpLCB7XG4gICAgICAgICAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCAuLi5PYmplY3QuZnJvbUVudHJpZXMoZW52TWFwKSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICAvLyBBcHBlbmQgc3Rkb3V0IHRvIG91dHB1dCBhcyBleGVjdXRhYmxlIHJ1bnMuXG4gICAgICAgICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBcHBlbmQgc3RkZXJyIGFzIGV4ZWN1dGFibGUgcnVucy5cbiAgICAgICAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgYSB0aW1lb3V0IHRvIGVuZCB0aGUgY2hpbGQgcHJvY2VzcyBhbmQgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gS2lsbCBjaGlsZCBwcm9jZXNzIGFuZCByZW1vdmUgbGlzdGVuZXJzIHNvICdjbG9zZScgZXZlbnQgZG9lc24ndCBnZXRcbiAgICAgICAgICAgICAgICAvLyByZWFkIGFmdGVyIGNoaWxkIHByb2Nlc3MgaXMga2lsbGVkLlxuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignVGhlIGV4ZWN1dGFibGUgZmFpbGVkIHRvIGZpbmlzaCB3aXRoaW4gdGhlIHRpbWVvdXQgc3BlY2lmaWVkLicpKTtcbiAgICAgICAgICAgIH0sIHRoaXMudGltZW91dE1pbGxpcyk7XG4gICAgICAgICAgICBjaGlsZC5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENhbmNlbCB0aW1lb3V0IGlmIGV4ZWN1dGFibGUgY2xvc2VzIGJlZm9yZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBleGVjdXRhYmxlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIHRyeSB0byByZXR1cm4gdGhlIHBhcnNlZCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2UocmVzcG9uc2VKc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKGBUaGUgZXhlY3V0YWJsZSByZXR1cm5lZCBhbiBpbnZhbGlkIHJlc3BvbnNlOiAke291dHB1dH1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xLkV4ZWN1dGFibGVFcnJvcihvdXRwdXQsIGNvZGUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHVzZXIgcHJvdmlkZWQgb3V0cHV0IGZpbGUgZm9yIHJlc3BvbnNlIGZyb20gcHJldmlvdXMgcnVuIG9mXG4gICAgICogZXhlY3V0YWJsZSBhbmQgcmV0dXJuIHRoZSByZXNwb25zZSBpZiBpdCBleGlzdHMsIGlzIGZvcm1hdHRlZCBjb3JyZWN0bHksIGFuZCBpcyBub3QgZXhwaXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZUNhY2hlZFJlc3BvbnNlKCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0RmlsZSB8fCB0aGlzLm91dHB1dEZpbGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWxlUGF0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGVQYXRoID0gYXdhaXQgZnMucHJvbWlzZXMucmVhbHBhdGgodGhpcy5vdXRwdXRGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIElmIGZpbGUgcGF0aCBjYW5ub3QgYmUgcmVzb2x2ZWQsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IGZzLnByb21pc2VzLmxzdGF0KGZpbGVQYXRoKSkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIC8vIElmIHBhdGggZG9lcyBub3QgbGVhZCB0byBmaWxlLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZVN0cmluZyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGZpbGVQYXRoLCB7XG4gICAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlU3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VKc29uID0gSlNPTi5wYXJzZShyZXNwb25zZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZXNwb25zZSBpcyBzdWNjZXNzZnVsIGFuZCB1bmV4cGlyZWQuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKGBUaGUgb3V0cHV0IGZpbGUgY29udGFpbmVkIGFuIGludmFsaWQgcmVzcG9uc2U6ICR7cmVzcG9uc2VTdHJpbmd9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGdpdmVuIGNvbW1hbmQgc3RyaW5nIGludG8gY29tcG9uZW50IGFycmF5LCBzcGxpdHRpbmcgb24gc3BhY2VzIHVubGVzc1xuICAgICAqIHNwYWNlcyBhcmUgYmV0d2VlbiBxdW90YXRpb24gbWFya3MuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBjb21tYW5kIGludG8gY29tcG9uZW50cyBieSBzcGxpdHRpbmcgb24gc3BhY2VzLFxuICAgICAgICAvLyB1bmxlc3Mgc3BhY2VzIGFyZSBjb250YWluZWQgaW4gcXVvdGF0aW9uIG1hcmtzLlxuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gY29tbWFuZC5tYXRjaCgvKD86W15cXHNcIl0rfFwiW15cIl0qXCIpKy9nKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIGNvbW1hbmQ6IFwiJHtjb21tYW5kfVwiIGNvdWxkIG5vdCBiZSBwYXJzZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHF1b3RhdGlvbiBtYXJrcyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBlYWNoIGNvbXBvbmVudCBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzW2ldWzBdID09PSAnXCInICYmIGNvbXBvbmVudHNbaV0uc2xpY2UoLTEpID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXSA9IGNvbXBvbmVudHNbaV0uc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aEhhbmRsZXIgPSBQbHVnZ2FibGVBdXRoSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdnYWJsZS1hdXRoLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/refreshclient.js":
/*!***************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/refreshclient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(api)/../node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nexports.USER_REFRESH_ACCOUNT_TYPE = 'authorized_user';\nclass UserRefreshClient extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure) {\n        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\n            ? optionsOrClientId\n            : {\n                clientId: optionsOrClientId,\n                clientSecret,\n                refreshToken,\n                eagerRefreshThresholdMillis,\n                forceRefreshOnFailure,\n            };\n        super({\n            clientId: opts.clientId,\n            clientSecret: opts.clientSecret,\n            eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,\n            forceRefreshOnFailure: opts.forceRefreshOnFailure,\n        });\n        this._refreshToken = opts.refreshToken;\n        this.credentials.refresh_token = opts.refreshToken;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken An ignored refreshToken..\n     * @param callback Optional callback.\n     */\n    async refreshTokenNoCache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        return super.refreshTokenNoCache(this._refreshToken);\n    }\n    /**\n     * Create a UserRefreshClient credentials instance using the given input\n     * options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the user refresh token');\n        }\n        if (json.type !== 'authorized_user') {\n            throw new Error('The incoming JSON object does not have the \"authorized_user\" type');\n        }\n        if (!json.client_id) {\n            throw new Error('The incoming JSON object does not contain a client_id field');\n        }\n        if (!json.client_secret) {\n            throw new Error('The incoming JSON object does not contain a client_secret field');\n        }\n        if (!json.refresh_token) {\n            throw new Error('The incoming JSON object does not contain a refresh_token field');\n        }\n        this._clientId = json.client_id;\n        this._clientSecret = json.client_secret;\n        this._refreshToken = json.refresh_token;\n        this.credentials.refresh_token = json.refresh_token;\n        this.quotaProjectId = json.quota_project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    async fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                return reject(new Error('Must pass in a stream containing the user refresh token.'));\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    return resolve();\n                }\n                catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n}\nexports.UserRefreshClient = UserRefreshClient;\n//# sourceMappingURL=refreshclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvcmVmcmVzaGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLGlDQUFpQztBQUM3RCx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBZ0I7QUFDL0MsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9yZWZyZXNoY2xpZW50LmpzP2YyMWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXNlclJlZnJlc2hDbGllbnQgPSBleHBvcnRzLlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUgPSB2b2lkIDA7XG5jb25zdCBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNsaWVudFwiKTtcbmV4cG9ydHMuVVNFUl9SRUZSRVNIX0FDQ09VTlRfVFlQRSA9ICdhdXRob3JpemVkX3VzZXInO1xuY2xhc3MgVXNlclJlZnJlc2hDbGllbnQgZXh0ZW5kcyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnNPckNsaWVudElkLCBjbGllbnRTZWNyZXQsIHJlZnJlc2hUb2tlbiwgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzLCBmb3JjZVJlZnJlc2hPbkZhaWx1cmUpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IG9wdGlvbnNPckNsaWVudElkICYmIHR5cGVvZiBvcHRpb25zT3JDbGllbnRJZCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gb3B0aW9uc09yQ2xpZW50SWRcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNsaWVudElkOiBvcHRpb25zT3JDbGllbnRJZCxcbiAgICAgICAgICAgICAgICBjbGllbnRTZWNyZXQsXG4gICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgICAgIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyxcbiAgICAgICAgICAgICAgICBmb3JjZVJlZnJlc2hPbkZhaWx1cmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjbGllbnRJZDogb3B0cy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudFNlY3JldDogb3B0cy5jbGllbnRTZWNyZXQsXG4gICAgICAgICAgICBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXM6IG9wdHMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzLFxuICAgICAgICAgICAgZm9yY2VSZWZyZXNoT25GYWlsdXJlOiBvcHRzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IG9wdHMucmVmcmVzaFRva2VuO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gPSBvcHRzLnJlZnJlc2hUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBbiBpZ25vcmVkIHJlZnJlc2hUb2tlbi4uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hUb2tlbk5vQ2FjaGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHJlZnJlc2hUb2tlbikge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVmcmVzaFRva2VuTm9DYWNoZSh0aGlzLl9yZWZyZXNoVG9rZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBVc2VyUmVmcmVzaENsaWVudCBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyB0aGUgZ2l2ZW4gaW5wdXRcbiAgICAgKiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbnB1dCBvYmplY3QuXG4gICAgICovXG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyB0aGUgdXNlciByZWZyZXNoIHRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24udHlwZSAhPT0gJ2F1dGhvcml6ZWRfdXNlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGhhdmUgdGhlIFwiYXV0aG9yaXplZF91c2VyXCIgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5jbGllbnRfaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBjbGllbnRfaWQgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIGNsaWVudF9zZWNyZXQgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHJlZnJlc2hfdG9rZW4gZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGllbnRJZCA9IGpzb24uY2xpZW50X2lkO1xuICAgICAgICB0aGlzLl9jbGllbnRTZWNyZXQgPSBqc29uLmNsaWVudF9zZWNyZXQ7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IGpzb24ucmVmcmVzaF90b2tlbjtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuID0ganNvbi5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0ganNvbi5xdW90YV9wcm9qZWN0X2lkO1xuICAgIH1cbiAgICBmcm9tU3RyZWFtKGlucHV0U3RyZWFtLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKS50aGVuKCgpID0+IGNhbGxiYWNrKCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIHN0cmVhbSBjb250YWluaW5nIHRoZSB1c2VyIHJlZnJlc2ggdG9rZW4uJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGlucHV0U3RyZWFtXG4gICAgICAgICAgICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC5vbignZGF0YScsIGNodW5rID0+IChzICs9IGNodW5rKSlcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVXNlclJlZnJlc2hDbGllbnQgPSBVc2VyUmVmcmVzaENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZnJlc2hjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/refreshclient.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/auth/stscredentials.js":
/*!****************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/auth/stscredentials.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StsCredentials = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(api)/../node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(api)/../node_modules/google-auth-library/build/src/transporters.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(api)/../node_modules/google-auth-library/build/src/auth/oauth2common.js\");\n/**\n * Implements the OAuth 2.0 token exchange based on\n * https://tools.ietf.org/html/rfc8693\n */\nclass StsCredentials extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an STS credentials instance.\n     * @param tokenExchangeEndpoint The token exchange endpoint.\n     * @param clientAuthentication The client authentication credentials if\n     *   available.\n     */\n    constructor(tokenExchangeEndpoint, clientAuthentication) {\n        super(clientAuthentication);\n        this.tokenExchangeEndpoint = tokenExchangeEndpoint;\n        this.transporter = new transporters_1.DefaultTransporter();\n    }\n    /**\n     * Exchanges the provided token for another type of token based on the\n     * rfc8693 spec.\n     * @param stsCredentialsOptions The token exchange options used to populate\n     *   the token exchange request.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @param options Optional additional GCP-specific non-spec defined options\n     *   to send with the request.\n     *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`\n     * @return A promise that resolves with the token exchange response containing\n     *   the requested token and its expiration time.\n     */\n    async exchangeToken(stsCredentialsOptions, additionalHeaders, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options) {\n        var _a, _b, _c;\n        const values = {\n            grant_type: stsCredentialsOptions.grantType,\n            resource: stsCredentialsOptions.resource,\n            audience: stsCredentialsOptions.audience,\n            scope: (_a = stsCredentialsOptions.scope) === null || _a === void 0 ? void 0 : _a.join(' '),\n            requested_token_type: stsCredentialsOptions.requestedTokenType,\n            subject_token: stsCredentialsOptions.subjectToken,\n            subject_token_type: stsCredentialsOptions.subjectTokenType,\n            actor_token: (_b = stsCredentialsOptions.actingParty) === null || _b === void 0 ? void 0 : _b.actorToken,\n            actor_token_type: (_c = stsCredentialsOptions.actingParty) === null || _c === void 0 ? void 0 : _c.actorTokenType,\n            // Non-standard GCP-specific options.\n            options: options && JSON.stringify(options),\n        };\n        // Remove undefined fields.\n        Object.keys(values).forEach(key => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof values[key] === 'undefined') {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                delete values[key];\n            }\n        });\n        const headers = {\n            'Content-Type': 'application/x-www-form-urlencoded',\n        };\n        // Inject additional STS headers if available.\n        Object.assign(headers, additionalHeaders || {});\n        const opts = {\n            url: this.tokenExchangeEndpoint,\n            method: 'POST',\n            headers,\n            data: querystring.stringify(values),\n            responseType: 'json',\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const stsSuccessfulResponse = response.data;\n            stsSuccessfulResponse.res = response;\n            return stsSuccessfulResponse;\n        }\n        catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, \n                // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\nexports.StsCredentials = StsCredentials;\n//# sourceMappingURL=stscredentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvc3RzY3JlZGVudGlhbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsaUJBQWlCLG1CQUFPLENBQUMsK0RBQVE7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMsNEZBQWlCO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLGdHQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBOEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGluZS11c2VyLXRvLXNoZWV0cy8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9zdHNjcmVkZW50aWFscy5qcz9lNTUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0c0NyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCB0cmFuc3BvcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRlcnNcIik7XG5jb25zdCBvYXV0aDJjb21tb25fMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNvbW1vblwiKTtcbi8qKlxuICogSW1wbGVtZW50cyB0aGUgT0F1dGggMi4wIHRva2VuIGV4Y2hhbmdlIGJhc2VkIG9uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODY5M1xuICovXG5jbGFzcyBTdHNDcmVkZW50aWFscyBleHRlbmRzIG9hdXRoMmNvbW1vbl8xLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIFNUUyBjcmVkZW50aWFscyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gdG9rZW5FeGNoYW5nZUVuZHBvaW50IFRoZSB0b2tlbiBleGNoYW5nZSBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0gY2xpZW50QXV0aGVudGljYXRpb24gVGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBpZlxuICAgICAqICAgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuRXhjaGFuZ2VFbmRwb2ludCwgY2xpZW50QXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgc3VwZXIoY2xpZW50QXV0aGVudGljYXRpb24pO1xuICAgICAgICB0aGlzLnRva2VuRXhjaGFuZ2VFbmRwb2ludCA9IHRva2VuRXhjaGFuZ2VFbmRwb2ludDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRlciA9IG5ldyB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjaGFuZ2VzIHRoZSBwcm92aWRlZCB0b2tlbiBmb3IgYW5vdGhlciB0eXBlIG9mIHRva2VuIGJhc2VkIG9uIHRoZVxuICAgICAqIHJmYzg2OTMgc3BlYy5cbiAgICAgKiBAcGFyYW0gc3RzQ3JlZGVudGlhbHNPcHRpb25zIFRoZSB0b2tlbiBleGNoYW5nZSBvcHRpb25zIHVzZWQgdG8gcG9wdWxhdGVcbiAgICAgKiAgIHRoZSB0b2tlbiBleGNoYW5nZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsSGVhZGVycyBPcHRpb25hbCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gcGFzcyBhbG9uZyB0aGVcbiAgICAgKiAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgYWRkaXRpb25hbCBHQ1Atc3BlY2lmaWMgbm9uLXNwZWMgZGVmaW5lZCBvcHRpb25zXG4gICAgICogICB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICogICBFeGFtcGxlOiBgJm9wdGlvbnM9JHtlbmNvZGVVcmlDb21wb25lbnQoSlNPTi5zdHJpbmdpZmllZChvcHRpb25zKSl9YFxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdG9rZW4gZXhjaGFuZ2UgcmVzcG9uc2UgY29udGFpbmluZ1xuICAgICAqICAgdGhlIHJlcXVlc3RlZCB0b2tlbiBhbmQgaXRzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZVRva2VuKHN0c0NyZWRlbnRpYWxzT3B0aW9ucywgYWRkaXRpb25hbEhlYWRlcnMsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgZ3JhbnRfdHlwZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLmdyYW50VHlwZSxcbiAgICAgICAgICAgIHJlc291cmNlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMucmVzb3VyY2UsXG4gICAgICAgICAgICBhdWRpZW5jZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLmF1ZGllbmNlLFxuICAgICAgICAgICAgc2NvcGU6IChfYSA9IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5zY29wZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHJlcXVlc3RlZF90b2tlbl90eXBlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMucmVxdWVzdGVkVG9rZW5UeXBlLFxuICAgICAgICAgICAgc3ViamVjdF90b2tlbjogc3RzQ3JlZGVudGlhbHNPcHRpb25zLnN1YmplY3RUb2tlbixcbiAgICAgICAgICAgIHN1YmplY3RfdG9rZW5fdHlwZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLnN1YmplY3RUb2tlblR5cGUsXG4gICAgICAgICAgICBhY3Rvcl90b2tlbjogKF9iID0gc3RzQ3JlZGVudGlhbHNPcHRpb25zLmFjdGluZ1BhcnR5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0b3JUb2tlbixcbiAgICAgICAgICAgIGFjdG9yX3Rva2VuX3R5cGU6IChfYyA9IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5hY3RpbmdQYXJ0eSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjdG9yVG9rZW5UeXBlLFxuICAgICAgICAgICAgLy8gTm9uLXN0YW5kYXJkIEdDUC1zcGVjaWZpYyBvcHRpb25zLlxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyAmJiBKU09OLnN0cmluZ2lmeShvcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCBmaWVsZHMuXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICB9O1xuICAgICAgICAvLyBJbmplY3QgYWRkaXRpb25hbCBTVFMgaGVhZGVycyBpZiBhdmFpbGFibGUuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLnRva2VuRXhjaGFuZ2VFbmRwb2ludCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGRhdGE6IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh2YWx1ZXMpLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFwcGx5IE9BdXRoIGNsaWVudCBhdXRoZW50aWNhdGlvbi5cbiAgICAgICAgdGhpcy5hcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyhvcHRzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgICAgICAgIGNvbnN0IHN0c1N1Y2Nlc3NmdWxSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICBzdHNTdWNjZXNzZnVsUmVzcG9uc2UucmVzID0gcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gc3RzU3VjY2Vzc2Z1bFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGVycm9yIHRvIE9BdXRoRXJyb3IuXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvciAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBvYXV0aDJjb21tb25fMS5nZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UpKGVycm9yLnJlc3BvbnNlLmRhdGEsIFxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIG90aGVyIGZpZWxkcyBmcm9tIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgICAgICAgICAgICAgICBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGNvdWxkIGZhaWwgYmVmb3JlIHRoZSBzZXJ2ZXIgcmVzcG9uZHMuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3RzQ3JlZGVudGlhbHMgPSBTdHNDcmVkZW50aWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0c2NyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/auth/stscredentials.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/crypto/browser/crypto.js":
/*!******************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/crypto/browser/crypto.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserCrypto = void 0;\n// This file implements crypto functions we need using in-browser\n// SubtleCrypto interface `window.crypto.subtle`.\nconst base64js = __webpack_require__(/*! base64-js */ \"(api)/../node_modules/base64-js/index.js\");\n// Not all browsers support `TextEncoder`. The following `require` will\n// provide a fast UTF8-only replacement for those browsers that don't support\n// text encoding natively.\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nif (typeof process === 'undefined' && typeof TextEncoder === 'undefined') {\n    __webpack_require__(/*! fast-text-encoding */ \"fast-text-encoding\");\n}\nconst crypto_1 = __webpack_require__(/*! ../crypto */ \"(api)/../node_modules/google-auth-library/build/src/crypto/crypto.js\");\nclass BrowserCrypto {\n    constructor() {\n        if (typeof window === 'undefined' ||\n            window.crypto === undefined ||\n            window.crypto.subtle === undefined) {\n            throw new Error(\"SubtleCrypto not found. Make sure it's an https:// website.\");\n        }\n    }\n    async sha256DigestBase64(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest('SHA-256', inputBuffer);\n        return base64js.fromByteArray(new Uint8Array(outputBuffer));\n    }\n    randomBytesBase64(count) {\n        const array = new Uint8Array(count);\n        window.crypto.getRandomValues(array);\n        return base64js.fromByteArray(array);\n    }\n    static padBase64(base64) {\n        // base64js requires padding, so let's add some '='\n        while (base64.length % 4 !== 0) {\n            base64 += '=';\n        }\n        return base64;\n    }\n    async verify(pubkey, data, signature) {\n        const algo = {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: { name: 'SHA-256' },\n        };\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const dataArray = new TextEncoder().encode(data);\n        const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));\n        const cryptoKey = await window.crypto.subtle.importKey('jwk', pubkey, algo, true, ['verify']);\n        // SubtleCrypto's verify method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);\n        return result;\n    }\n    async sign(privateKey, data) {\n        const algo = {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: { name: 'SHA-256' },\n        };\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const dataArray = new TextEncoder().encode(data);\n        const cryptoKey = await window.crypto.subtle.importKey('jwk', privateKey, algo, true, ['sign']);\n        // SubtleCrypto's sign method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);\n        return base64js.fromByteArray(new Uint8Array(result));\n    }\n    decodeBase64StringUtf8(base64) {\n        const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const result = new TextDecoder().decode(uint8array);\n        return result;\n    }\n    encodeBase64StringUtf8(text) {\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const uint8array = new TextEncoder().encode(text);\n        const result = base64js.fromByteArray(uint8array);\n        return result;\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */\n    async sha256DigestHex(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest('SHA-256', inputBuffer);\n        return (0, crypto_1.fromArrayBufferToHex)(outputBuffer);\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */\n    async signWithHmacSha256(key, msg) {\n        // Convert key, if provided in ArrayBuffer format, to string.\n        const rawKey = typeof key === 'string'\n            ? key\n            : String.fromCharCode(...new Uint16Array(key));\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const enc = new TextEncoder();\n        const cryptoKey = await window.crypto.subtle.importKey('raw', enc.encode(rawKey), {\n            name: 'HMAC',\n            hash: {\n                name: 'SHA-256',\n            },\n        }, false, ['sign']);\n        return window.crypto.subtle.sign('HMAC', cryptoKey, enc.encode(msg));\n    }\n}\nexports.BrowserCrypto = BrowserCrypto;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2NyeXB0by9icm93c2VyL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywyREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBTyxDQUFDLDhDQUFvQjtBQUNoQztBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vYnJvd3Nlci9jcnlwdG8uanM/NTM1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2VyQ3J5cHRvID0gdm9pZCAwO1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgY3J5cHRvIGZ1bmN0aW9ucyB3ZSBuZWVkIHVzaW5nIGluLWJyb3dzZXJcbi8vIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UgYHdpbmRvdy5jcnlwdG8uc3VidGxlYC5cbmNvbnN0IGJhc2U2NGpzID0gcmVxdWlyZShcImJhc2U2NC1qc1wiKTtcbi8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBgVGV4dEVuY29kZXJgLiBUaGUgZm9sbG93aW5nIGByZXF1aXJlYCB3aWxsXG4vLyBwcm92aWRlIGEgZmFzdCBVVEY4LW9ubHkgcmVwbGFjZW1lbnQgZm9yIHRob3NlIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuLy8gdGV4dCBlbmNvZGluZyBuYXRpdmVseS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFRleHRFbmNvZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJlcXVpcmUoJ2Zhc3QtdGV4dC1lbmNvZGluZycpO1xufVxuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvXCIpO1xuY2xhc3MgQnJvd3NlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgd2luZG93LmNyeXB0byA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB3aW5kb3cuY3J5cHRvLnN1YnRsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJ0bGVDcnlwdG8gbm90IGZvdW5kLiBNYWtlIHN1cmUgaXQncyBhbiBodHRwczovLyB3ZWJzaXRlLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaGEyNTZEaWdlc3RCYXNlNjQoc3RyKSB7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0byBkaWdlc3QoKSBtZXRob2QgaXMgYXN5bmMsIHNvIHdlIG11c3QgbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYyBhcyB3ZWxsLlxuICAgICAgICAvLyBUbyBjYWxjdWxhdGUgU0hBMjU2IGRpZ2VzdCB1c2luZyBTdWJ0bGVDcnlwdG8sIHdlIGZpcnN0XG4gICAgICAgIC8vIG5lZWQgdG8gY29udmVydCBhbiBpbnB1dCBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXI6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgaW5wdXRCdWZmZXIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbiAgICAgICAgLy8gUmVzdWx0IGlzIEFycmF5QnVmZmVyIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGlucHV0QnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGpzLmZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkob3V0cHV0QnVmZmVyKSk7XG4gICAgfVxuICAgIHJhbmRvbUJ5dGVzQmFzZTY0KGNvdW50KSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xuICAgICAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgICAgIHJldHVybiBiYXNlNjRqcy5mcm9tQnl0ZUFycmF5KGFycmF5KTtcbiAgICB9XG4gICAgc3RhdGljIHBhZEJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgLy8gYmFzZTY0anMgcmVxdWlyZXMgcGFkZGluZywgc28gbGV0J3MgYWRkIHNvbWUgJz0nXG4gICAgICAgIHdoaWxlIChiYXNlNjQubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICAgICAgYmFzZTY0ICs9ICc9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH1cbiAgICBhc3luYyB2ZXJpZnkocHVia2V5LCBkYXRhLCBzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc3QgYWxnbyA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlQXJyYXkgPSBiYXNlNjRqcy50b0J5dGVBcnJheShCcm93c2VyQ3J5cHRvLnBhZEJhc2U2NChzaWduYXR1cmUpKTtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBwdWJrZXksIGFsZ28sIHRydWUsIFsndmVyaWZ5J10pO1xuICAgICAgICAvLyBTdWJ0bGVDcnlwdG8ncyB2ZXJpZnkgbWV0aG9kIGlzIGFzeW5jIHNvIHdlIG11c3QgbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYyBhcyB3ZWxsLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS52ZXJpZnkoYWxnbywgY3J5cHRvS2V5LCBzaWduYXR1cmVBcnJheSwgZGF0YUFycmF5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgc2lnbihwcml2YXRlS2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGFsZ28gPSB7XG4gICAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgICAgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSk7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleSgnandrJywgcHJpdmF0ZUtleSwgYWxnbywgdHJ1ZSwgWydzaWduJ10pO1xuICAgICAgICAvLyBTdWJ0bGVDcnlwdG8ncyBzaWduIG1ldGhvZCBpcyBhc3luYyBzbyB3ZSBtdXN0IG1ha2VcbiAgICAgICAgLy8gdGhpcyBtZXRob2QgYXN5bmMgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuc2lnbihhbGdvLCBjcnlwdG9LZXksIGRhdGFBcnJheSk7XG4gICAgICAgIHJldHVybiBiYXNlNjRqcy5mcm9tQnl0ZUFycmF5KG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuICAgIH1cbiAgICBkZWNvZGVCYXNlNjRTdHJpbmdVdGY4KGJhc2U2NCkge1xuICAgICAgICBjb25zdCB1aW50OGFycmF5ID0gYmFzZTY0anMudG9CeXRlQXJyYXkoQnJvd3NlckNyeXB0by5wYWRCYXNlNjQoYmFzZTY0KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnQ4YXJyYXkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGVCYXNlNjRTdHJpbmdVdGY4KHRleHQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCB1aW50OGFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBiYXNlNjRqcy5mcm9tQnl0ZUFycmF5KHVpbnQ4YXJyYXkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHN0ciBUaGUgcGxhaW4gdGV4dCBzdHJpbmcgdG8gaGFzaC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIFNIQS0yNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWRcbiAgICAgKiAgIHN0cmluZyBpbiBoZXhhZGVjaW1hbCBlbmNvZGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBzaGEyNTZEaWdlc3RIZXgoc3RyKSB7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0byBkaWdlc3QoKSBtZXRob2QgaXMgYXN5bmMsIHNvIHdlIG11c3QgbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYyBhcyB3ZWxsLlxuICAgICAgICAvLyBUbyBjYWxjdWxhdGUgU0hBMjU2IGRpZ2VzdCB1c2luZyBTdWJ0bGVDcnlwdG8sIHdlIGZpcnN0XG4gICAgICAgIC8vIG5lZWQgdG8gY29udmVydCBhbiBpbnB1dCBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXI6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgaW5wdXRCdWZmZXIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbiAgICAgICAgLy8gUmVzdWx0IGlzIEFycmF5QnVmZmVyIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGlucHV0QnVmZmVyKTtcbiAgICAgICAgcmV0dXJuICgwLCBjcnlwdG9fMS5mcm9tQXJyYXlCdWZmZXJUb0hleCkob3V0cHV0QnVmZmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIEhNQUMgaGFzaCBvZiBhIG1lc3NhZ2UgdXNpbmcgdGhlIHByb3ZpZGVkIGNyeXB0byBrZXkgYW5kIHRoZVxuICAgICAqIFNIQS0yNTYgYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIHNlY3JldCBjcnlwdG8ga2V5IGluIHV0Zi04IG9yIEFycmF5QnVmZmVyIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gbXNnIFRoZSBwbGFpbiB0ZXh0IG1lc3NhZ2UuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBITUFDLVNIQTI1NiBoYXNoIGluIEFycmF5QnVmZmVyXG4gICAgICogICBmb3JtYXQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbldpdGhIbWFjU2hhMjU2KGtleSwgbXNnKSB7XG4gICAgICAgIC8vIENvbnZlcnQga2V5LCBpZiBwcm92aWRlZCBpbiBBcnJheUJ1ZmZlciBmb3JtYXQsIHRvIHN0cmluZy5cbiAgICAgICAgY29uc3QgcmF3S2V5ID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQxNkFycmF5KGtleSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGVuYy5lbmNvZGUocmF3S2V5KSwge1xuICAgICAgICAgICAgbmFtZTogJ0hNQUMnLFxuICAgICAgICAgICAgaGFzaDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTSEEtMjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGZhbHNlLCBbJ3NpZ24nXSk7XG4gICAgICAgIHJldHVybiB3aW5kb3cuY3J5cHRvLnN1YnRsZS5zaWduKCdITUFDJywgY3J5cHRvS2V5LCBlbmMuZW5jb2RlKG1zZykpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvd3NlckNyeXB0byA9IEJyb3dzZXJDcnlwdG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/crypto/browser/crypto.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/crypto/crypto.js":
/*!**********************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/crypto/crypto.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromArrayBufferToHex = exports.hasBrowserCrypto = exports.createCrypto = void 0;\nconst crypto_1 = __webpack_require__(/*! ./browser/crypto */ \"(api)/../node_modules/google-auth-library/build/src/crypto/browser/crypto.js\");\nconst crypto_2 = __webpack_require__(/*! ./node/crypto */ \"(api)/../node_modules/google-auth-library/build/src/crypto/node/crypto.js\");\nfunction createCrypto() {\n    if (hasBrowserCrypto()) {\n        return new crypto_1.BrowserCrypto();\n    }\n    return new crypto_2.NodeCrypto();\n}\nexports.createCrypto = createCrypto;\nfunction hasBrowserCrypto() {\n    return (typeof window !== 'undefined' &&\n        typeof window.crypto !== 'undefined' &&\n        typeof window.crypto.subtle !== 'undefined');\n}\nexports.hasBrowserCrypto = hasBrowserCrypto;\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param arrayBuffer The ArrayBuffer to convert to hexadecimal string.\n * @return The hexadecimal encoding of the ArrayBuffer.\n */\nfunction fromArrayBufferToHex(arrayBuffer) {\n    // Convert buffer to byte array.\n    const byteArray = Array.from(new Uint8Array(arrayBuffer));\n    // Convert bytes to hex string.\n    return byteArray\n        .map(byte => {\n        return byte.toString(16).padStart(2, '0');\n    })\n        .join('');\n}\nexports.fromArrayBufferToHex = fromArrayBufferToHex;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2NyeXB0by9jcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQjtBQUM5RSxpQkFBaUIsbUJBQU8sQ0FBQyxzR0FBa0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vY3J5cHRvLmpzP2FiNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnJvbUFycmF5QnVmZmVyVG9IZXggPSBleHBvcnRzLmhhc0Jyb3dzZXJDcnlwdG8gPSBleHBvcnRzLmNyZWF0ZUNyeXB0byA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4vYnJvd3Nlci9jcnlwdG9cIik7XG5jb25zdCBjcnlwdG9fMiA9IHJlcXVpcmUoXCIuL25vZGUvY3J5cHRvXCIpO1xuZnVuY3Rpb24gY3JlYXRlQ3J5cHRvKCkge1xuICAgIGlmIChoYXNCcm93c2VyQ3J5cHRvKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjcnlwdG9fMS5Ccm93c2VyQ3J5cHRvKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgY3J5cHRvXzIuTm9kZUNyeXB0bygpO1xufVxuZXhwb3J0cy5jcmVhdGVDcnlwdG8gPSBjcmVhdGVDcnlwdG87XG5mdW5jdGlvbiBoYXNCcm93c2VyQ3J5cHRvKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5jcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcpO1xufVxuZXhwb3J0cy5oYXNCcm93c2VyQ3J5cHRvID0gaGFzQnJvd3NlckNyeXB0bztcbi8qKlxuICogQ29udmVydHMgYW4gQXJyYXlCdWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcGFyYW0gYXJyYXlCdWZmZXIgVGhlIEFycmF5QnVmZmVyIHRvIGNvbnZlcnQgdG8gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybiBUaGUgaGV4YWRlY2ltYWwgZW5jb2Rpbmcgb2YgdGhlIEFycmF5QnVmZmVyLlxuICovXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXJUb0hleChhcnJheUJ1ZmZlcikge1xuICAgIC8vIENvbnZlcnQgYnVmZmVyIHRvIGJ5dGUgYXJyYXkuXG4gICAgY29uc3QgYnl0ZUFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgIC8vIENvbnZlcnQgYnl0ZXMgdG8gaGV4IHN0cmluZy5cbiAgICByZXR1cm4gYnl0ZUFycmF5XG4gICAgICAgIC5tYXAoYnl0ZSA9PiB7XG4gICAgICAgIHJldHVybiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmV4cG9ydHMuZnJvbUFycmF5QnVmZmVyVG9IZXggPSBmcm9tQXJyYXlCdWZmZXJUb0hleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/crypto/crypto.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/crypto/node/crypto.js":
/*!***************************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/crypto/node/crypto.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NodeCrypto = void 0;\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nclass NodeCrypto {\n    async sha256DigestBase64(str) {\n        return crypto.createHash('sha256').update(str).digest('base64');\n    }\n    randomBytesBase64(count) {\n        return crypto.randomBytes(count).toString('base64');\n    }\n    async verify(pubkey, data, signature) {\n        const verifier = crypto.createVerify('sha256');\n        verifier.update(data);\n        verifier.end();\n        return verifier.verify(pubkey, signature, 'base64');\n    }\n    async sign(privateKey, data) {\n        const signer = crypto.createSign('RSA-SHA256');\n        signer.update(data);\n        signer.end();\n        return signer.sign(privateKey, 'base64');\n    }\n    decodeBase64StringUtf8(base64) {\n        return Buffer.from(base64, 'base64').toString('utf-8');\n    }\n    encodeBase64StringUtf8(text) {\n        return Buffer.from(text, 'utf-8').toString('base64');\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */\n    async sha256DigestHex(str) {\n        return crypto.createHash('sha256').update(str).digest('hex');\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */\n    async signWithHmacSha256(key, msg) {\n        const cryptoKey = typeof key === 'string' ? key : toBuffer(key);\n        return toArrayBuffer(crypto.createHmac('sha256', cryptoKey).update(msg).digest());\n    }\n}\nexports.NodeCrypto = NodeCrypto;\n/**\n * Converts a Node.js Buffer to an ArrayBuffer.\n * https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer\n * @param buffer The Buffer input to covert.\n * @return The ArrayBuffer representation of the input.\n */\nfunction toArrayBuffer(buffer) {\n    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n/**\n * Converts an ArrayBuffer to a Node.js Buffer.\n * @param arrayBuffer The ArrayBuffer input to covert.\n * @return The Buffer representation of the input.\n */\nfunction toBuffer(arrayBuffer) {\n    return Buffer.from(arrayBuffer);\n}\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2NyeXB0by9ub2RlL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vbm9kZS9jcnlwdG8uanM/NDI4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob2RlQ3J5cHRvID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNsYXNzIE5vZGVDcnlwdG8ge1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEJhc2U2NChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc3RyKS5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgICByYW5kb21CeXRlc0Jhc2U2NChjb3VudCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGNvdW50KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeShwdWJrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCB2ZXJpZmllciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoJ3NoYTI1NicpO1xuICAgICAgICB2ZXJpZmllci51cGRhdGUoZGF0YSk7XG4gICAgICAgIHZlcmlmaWVyLmVuZCgpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHB1YmtleSwgc2lnbmF0dXJlLCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24ocHJpdmF0ZUtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbignUlNBLVNIQTI1NicpO1xuICAgICAgICBzaWduZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBzaWduZXIuZW5kKCk7XG4gICAgICAgIHJldHVybiBzaWduZXIuc2lnbihwcml2YXRlS2V5LCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGRlY29kZUJhc2U2NFN0cmluZ1V0ZjgoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0ZXh0LCAndXRmLTgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBwbGFpbiB0ZXh0IHN0cmluZyB0byBoYXNoLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZFxuICAgICAqICAgc3RyaW5nIGluIGhleGFkZWNpbWFsIGVuY29kaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEhleChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc3RyKS5kaWdlc3QoJ2hleCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgSE1BQyBoYXNoIG9mIGEgbWVzc2FnZSB1c2luZyB0aGUgcHJvdmlkZWQgY3J5cHRvIGtleSBhbmQgdGhlXG4gICAgICogU0hBLTI1NiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIGtleSBUaGUgc2VjcmV0IGNyeXB0byBrZXkgaW4gdXRmLTggb3IgQXJyYXlCdWZmZXIgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIHBsYWluIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEhNQUMtU0hBMjU2IGhhc2ggaW4gQXJyYXlCdWZmZXJcbiAgICAgKiAgIGZvcm1hdC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduV2l0aEhtYWNTaGEyNTYoa2V5LCBtc2cpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyBrZXkgOiB0b0J1ZmZlcihrZXkpO1xuICAgICAgICByZXR1cm4gdG9BcnJheUJ1ZmZlcihjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2JywgY3J5cHRvS2V5KS51cGRhdGUobXNnKS5kaWdlc3QoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob2RlQ3J5cHRvID0gTm9kZUNyeXB0bztcbi8qKlxuICogQ29udmVydHMgYSBOb2RlLmpzIEJ1ZmZlciB0byBhbiBBcnJheUJ1ZmZlci5cbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg2MDkyODkvY29udmVydC1hLWJpbmFyeS1ub2RlanMtYnVmZmVyLXRvLWphdmFzY3JpcHQtYXJyYXlidWZmZXJcbiAqIEBwYXJhbSBidWZmZXIgVGhlIEJ1ZmZlciBpbnB1dCB0byBjb3ZlcnQuXG4gKiBAcmV0dXJuIFRoZSBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIE5vZGUuanMgQnVmZmVyLlxuICogQHBhcmFtIGFycmF5QnVmZmVyIFRoZSBBcnJheUJ1ZmZlciBpbnB1dCB0byBjb3ZlcnQuXG4gKiBAcmV0dXJuIFRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlucHV0LlxuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/crypto/node/crypto.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.AuthClient = void 0;\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst googleauth_1 = __webpack_require__(/*! ./auth/googleauth */ \"(api)/../node_modules/google-auth-library/build/src/auth/googleauth.js\");\nObject.defineProperty(exports, \"GoogleAuth\", ({ enumerable: true, get: function () { return googleauth_1.GoogleAuth; } }));\nvar authclient_1 = __webpack_require__(/*! ./auth/authclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/authclient.js\");\nObject.defineProperty(exports, \"AuthClient\", ({ enumerable: true, get: function () { return authclient_1.AuthClient; } }));\nvar computeclient_1 = __webpack_require__(/*! ./auth/computeclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/computeclient.js\");\nObject.defineProperty(exports, \"Compute\", ({ enumerable: true, get: function () { return computeclient_1.Compute; } }));\nvar envDetect_1 = __webpack_require__(/*! ./auth/envDetect */ \"(api)/../node_modules/google-auth-library/build/src/auth/envDetect.js\");\nObject.defineProperty(exports, \"GCPEnv\", ({ enumerable: true, get: function () { return envDetect_1.GCPEnv; } }));\nvar iam_1 = __webpack_require__(/*! ./auth/iam */ \"(api)/../node_modules/google-auth-library/build/src/auth/iam.js\");\nObject.defineProperty(exports, \"IAMAuth\", ({ enumerable: true, get: function () { return iam_1.IAMAuth; } }));\nvar idtokenclient_1 = __webpack_require__(/*! ./auth/idtokenclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nObject.defineProperty(exports, \"IdTokenClient\", ({ enumerable: true, get: function () { return idtokenclient_1.IdTokenClient; } }));\nvar jwtaccess_1 = __webpack_require__(/*! ./auth/jwtaccess */ \"(api)/../node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nObject.defineProperty(exports, \"JWTAccess\", ({ enumerable: true, get: function () { return jwtaccess_1.JWTAccess; } }));\nvar jwtclient_1 = __webpack_require__(/*! ./auth/jwtclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nObject.defineProperty(exports, \"JWT\", ({ enumerable: true, get: function () { return jwtclient_1.JWT; } }));\nvar impersonated_1 = __webpack_require__(/*! ./auth/impersonated */ \"(api)/../node_modules/google-auth-library/build/src/auth/impersonated.js\");\nObject.defineProperty(exports, \"Impersonated\", ({ enumerable: true, get: function () { return impersonated_1.Impersonated; } }));\nvar oauth2client_1 = __webpack_require__(/*! ./auth/oauth2client */ \"(api)/../node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nObject.defineProperty(exports, \"CodeChallengeMethod\", ({ enumerable: true, get: function () { return oauth2client_1.CodeChallengeMethod; } }));\nObject.defineProperty(exports, \"OAuth2Client\", ({ enumerable: true, get: function () { return oauth2client_1.OAuth2Client; } }));\nvar loginticket_1 = __webpack_require__(/*! ./auth/loginticket */ \"(api)/../node_modules/google-auth-library/build/src/auth/loginticket.js\");\nObject.defineProperty(exports, \"LoginTicket\", ({ enumerable: true, get: function () { return loginticket_1.LoginTicket; } }));\nvar refreshclient_1 = __webpack_require__(/*! ./auth/refreshclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nObject.defineProperty(exports, \"UserRefreshClient\", ({ enumerable: true, get: function () { return refreshclient_1.UserRefreshClient; } }));\nvar awsclient_1 = __webpack_require__(/*! ./auth/awsclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/awsclient.js\");\nObject.defineProperty(exports, \"AwsClient\", ({ enumerable: true, get: function () { return awsclient_1.AwsClient; } }));\nvar identitypoolclient_1 = __webpack_require__(/*! ./auth/identitypoolclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nObject.defineProperty(exports, \"IdentityPoolClient\", ({ enumerable: true, get: function () { return identitypoolclient_1.IdentityPoolClient; } }));\nvar externalclient_1 = __webpack_require__(/*! ./auth/externalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/externalclient.js\");\nObject.defineProperty(exports, \"ExternalAccountClient\", ({ enumerable: true, get: function () { return externalclient_1.ExternalAccountClient; } }));\nvar baseexternalclient_1 = __webpack_require__(/*! ./auth/baseexternalclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nObject.defineProperty(exports, \"BaseExternalAccountClient\", ({ enumerable: true, get: function () { return baseexternalclient_1.BaseExternalAccountClient; } }));\nvar downscopedclient_1 = __webpack_require__(/*! ./auth/downscopedclient */ \"(api)/../node_modules/google-auth-library/build/src/auth/downscopedclient.js\");\nObject.defineProperty(exports, \"DownscopedClient\", ({ enumerable: true, get: function () { return downscopedclient_1.DownscopedClient; } }));\nvar pluggable_auth_client_1 = __webpack_require__(/*! ./auth/pluggable-auth-client */ \"(api)/../node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nObject.defineProperty(exports, \"PluggableAuthClient\", ({ enumerable: true, get: function () { return pluggable_auth_client_1.PluggableAuthClient; } }));\nvar transporters_1 = __webpack_require__(/*! ./transporters */ \"(api)/../node_modules/google-auth-library/build/src/transporters.js\");\nObject.defineProperty(exports, \"DefaultTransporter\", ({ enumerable: true, get: function () { return transporters_1.DefaultTransporter; } }));\nconst auth = new googleauth_1.GoogleAuth();\nexports.auth = auth;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLFlBQVksR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyxpQ0FBaUMsR0FBRyw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyxXQUFXLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsa0JBQWtCO0FBQzllO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsaUdBQW1CO0FBQ2hELDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SCxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBbUI7QUFDOUMsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILHNCQUFzQixtQkFBTyxDQUFDLHVHQUFzQjtBQUNwRCwyQ0FBMEMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDckgsa0JBQWtCLG1CQUFPLENBQUMsK0ZBQWtCO0FBQzVDLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyxZQUFZLG1CQUFPLENBQUMsbUZBQVk7QUFDaEMsMkNBQTBDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQzNHLHNCQUFzQixtQkFBTyxDQUFDLHVHQUFzQjtBQUNwRCxpREFBZ0QsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDakksa0JBQWtCLG1CQUFPLENBQUMsK0ZBQWtCO0FBQzVDLDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxrQkFBa0IsbUJBQU8sQ0FBQywrRkFBa0I7QUFDNUMsdUNBQXNDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQ3pHLHFCQUFxQixtQkFBTyxDQUFDLHFHQUFxQjtBQUNsRCxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgscUJBQXFCLG1CQUFPLENBQUMscUdBQXFCO0FBQ2xELHVEQUFzRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUM1SSxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgsb0JBQW9CLG1CQUFPLENBQUMsbUdBQW9CO0FBQ2hELCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCxzQkFBc0IsbUJBQU8sQ0FBQyx1R0FBc0I7QUFDcEQscURBQW9ELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQ3pJLGtCQUFrQixtQkFBTyxDQUFDLCtGQUFrQjtBQUM1Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsMkJBQTJCLG1CQUFPLENBQUMsaUhBQTJCO0FBQzlELHNEQUFxRCxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQztBQUNoSix1QkFBdUIsbUJBQU8sQ0FBQyx5R0FBdUI7QUFDdEQseURBQXdELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQ2xKLDJCQUEyQixtQkFBTyxDQUFDLGlIQUEyQjtBQUM5RCw2REFBNEQsRUFBRSxxQ0FBcUMsMERBQTBELEVBQUM7QUFDOUoseUJBQXlCLG1CQUFPLENBQUMsNkdBQXlCO0FBQzFELG9EQUFtRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMxSSw4QkFBOEIsbUJBQU8sQ0FBQyx1SEFBOEI7QUFDcEUsdURBQXNELEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQ3JKLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFnQjtBQUM3QyxzREFBcUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDMUk7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9pbmRleC5qcz9mMzNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hb29nbGVBdXRoID0gZXhwb3J0cy5hdXRoID0gZXhwb3J0cy5EZWZhdWx0VHJhbnNwb3J0ZXIgPSBleHBvcnRzLlBsdWdnYWJsZUF1dGhDbGllbnQgPSBleHBvcnRzLkRvd25zY29wZWRDbGllbnQgPSBleHBvcnRzLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgPSBleHBvcnRzLkV4dGVybmFsQWNjb3VudENsaWVudCA9IGV4cG9ydHMuSWRlbnRpdHlQb29sQ2xpZW50ID0gZXhwb3J0cy5Bd3NDbGllbnQgPSBleHBvcnRzLlVzZXJSZWZyZXNoQ2xpZW50ID0gZXhwb3J0cy5Mb2dpblRpY2tldCA9IGV4cG9ydHMuT0F1dGgyQ2xpZW50ID0gZXhwb3J0cy5Db2RlQ2hhbGxlbmdlTWV0aG9kID0gZXhwb3J0cy5JbXBlcnNvbmF0ZWQgPSBleHBvcnRzLkpXVCA9IGV4cG9ydHMuSldUQWNjZXNzID0gZXhwb3J0cy5JZFRva2VuQ2xpZW50ID0gZXhwb3J0cy5JQU1BdXRoID0gZXhwb3J0cy5HQ1BFbnYgPSBleHBvcnRzLkNvbXB1dGUgPSBleHBvcnRzLkF1dGhDbGllbnQgPSB2b2lkIDA7XG4vLyBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNvbnN0IGdvb2dsZWF1dGhfMSA9IHJlcXVpcmUoXCIuL2F1dGgvZ29vZ2xlYXV0aFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdvb2dsZUF1dGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdvb2dsZWF1dGhfMS5Hb29nbGVBdXRoOyB9IH0pO1xudmFyIGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYXV0aGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF1dGhDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50OyB9IH0pO1xudmFyIGNvbXB1dGVjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvY29tcHV0ZWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbXB1dGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXB1dGVjbGllbnRfMS5Db21wdXRlOyB9IH0pO1xudmFyIGVudkRldGVjdF8xID0gcmVxdWlyZShcIi4vYXV0aC9lbnZEZXRlY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHQ1BFbnZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudkRldGVjdF8xLkdDUEVudjsgfSB9KTtcbnZhciBpYW1fMSA9IHJlcXVpcmUoXCIuL2F1dGgvaWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSUFNQXV0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWFtXzEuSUFNQXV0aDsgfSB9KTtcbnZhciBpZHRva2VuY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2lkdG9rZW5jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJZFRva2VuQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpZHRva2VuY2xpZW50XzEuSWRUb2tlbkNsaWVudDsgfSB9KTtcbnZhciBqd3RhY2Nlc3NfMSA9IHJlcXVpcmUoXCIuL2F1dGgvand0YWNjZXNzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSldUQWNjZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqd3RhY2Nlc3NfMS5KV1RBY2Nlc3M7IH0gfSk7XG52YXIgand0Y2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2p3dGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpXVFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gand0Y2xpZW50XzEuSldUOyB9IH0pO1xudmFyIGltcGVyc29uYXRlZF8xID0gcmVxdWlyZShcIi4vYXV0aC9pbXBlcnNvbmF0ZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBlcnNvbmF0ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGltcGVyc29uYXRlZF8xLkltcGVyc29uYXRlZDsgfSB9KTtcbnZhciBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvb2F1dGgyY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUNoYWxsZW5nZU1ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2F1dGgyY2xpZW50XzEuQ29kZUNoYWxsZW5nZU1ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9BdXRoMkNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50OyB9IH0pO1xudmFyIGxvZ2ludGlja2V0XzEgPSByZXF1aXJlKFwiLi9hdXRoL2xvZ2ludGlja2V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9naW5UaWNrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2ludGlja2V0XzEuTG9naW5UaWNrZXQ7IH0gfSk7XG52YXIgcmVmcmVzaGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9yZWZyZXNoY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXNlclJlZnJlc2hDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZnJlc2hjbGllbnRfMS5Vc2VyUmVmcmVzaENsaWVudDsgfSB9KTtcbnZhciBhd3NjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYXdzY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXdzQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhd3NjbGllbnRfMS5Bd3NDbGllbnQ7IH0gfSk7XG52YXIgaWRlbnRpdHlwb29sY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2lkZW50aXR5cG9vbGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklkZW50aXR5UG9vbENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWRlbnRpdHlwb29sY2xpZW50XzEuSWRlbnRpdHlQb29sQ2xpZW50OyB9IH0pO1xudmFyIGV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2V4dGVybmFsY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXh0ZXJuYWxBY2NvdW50Q2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleHRlcm5hbGNsaWVudF8xLkV4dGVybmFsQWNjb3VudENsaWVudDsgfSB9KTtcbnZhciBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudDsgfSB9KTtcbnZhciBkb3duc2NvcGVkY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2Rvd25zY29wZWRjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb3duc2NvcGVkQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3duc2NvcGVkY2xpZW50XzEuRG93bnNjb3BlZENsaWVudDsgfSB9KTtcbnZhciBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvcGx1Z2dhYmxlLWF1dGgtY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGx1Z2dhYmxlQXV0aENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEuUGx1Z2dhYmxlQXV0aENsaWVudDsgfSB9KTtcbnZhciB0cmFuc3BvcnRlcnNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmF1bHRUcmFuc3BvcnRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNwb3J0ZXJzXzEuRGVmYXVsdFRyYW5zcG9ydGVyOyB9IH0pO1xuY29uc3QgYXV0aCA9IG5ldyBnb29nbGVhdXRoXzEuR29vZ2xlQXV0aCgpO1xuZXhwb3J0cy5hdXRoID0gYXV0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/index.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/options.js":
/*!****************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/options.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validate = void 0;\n// Accepts an options object passed from the user to the API.  In the\n// previous version of the API, it referred to a `Request` options object.\n// Now it refers to an Axiox Request Config object.  This is here to help\n// ensure users don't pass invalid options when they upgrade from 0.x to 1.x.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validate(options) {\n    const vpairs = [\n        { invalid: 'uri', expected: 'url' },\n        { invalid: 'json', expected: 'data' },\n        { invalid: 'qs', expected: 'params' },\n    ];\n    for (const pair of vpairs) {\n        if (options[pair.invalid]) {\n            const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;\n            throw new Error(e);\n        }\n    }\n}\nexports.validate = validate;\n//# sourceMappingURL=options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL29wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQyxVQUFVLG1DQUFtQztBQUM3QyxVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYSxxREFBcUQsY0FBYztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbmUtdXNlci10by1zaGVldHMvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL29wdGlvbnMuanM/ZGY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZvaWQgMDtcbi8vIEFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3QgcGFzc2VkIGZyb20gdGhlIHVzZXIgdG8gdGhlIEFQSS4gIEluIHRoZVxuLy8gcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgQVBJLCBpdCByZWZlcnJlZCB0byBhIGBSZXF1ZXN0YCBvcHRpb25zIG9iamVjdC5cbi8vIE5vdyBpdCByZWZlcnMgdG8gYW4gQXhpb3ggUmVxdWVzdCBDb25maWcgb2JqZWN0LiAgVGhpcyBpcyBoZXJlIHRvIGhlbHBcbi8vIGVuc3VyZSB1c2VycyBkb24ndCBwYXNzIGludmFsaWQgb3B0aW9ucyB3aGVuIHRoZXkgdXBncmFkZSBmcm9tIDAueCB0byAxLnguXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHZwYWlycyA9IFtcbiAgICAgICAgeyBpbnZhbGlkOiAndXJpJywgZXhwZWN0ZWQ6ICd1cmwnIH0sXG4gICAgICAgIHsgaW52YWxpZDogJ2pzb24nLCBleHBlY3RlZDogJ2RhdGEnIH0sXG4gICAgICAgIHsgaW52YWxpZDogJ3FzJywgZXhwZWN0ZWQ6ICdwYXJhbXMnIH0sXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgdnBhaXJzKSB7XG4gICAgICAgIGlmIChvcHRpb25zW3BhaXIuaW52YWxpZF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBgJyR7cGFpci5pbnZhbGlkfScgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb24uIFBsZWFzZSB1c2UgJyR7cGFpci5leHBlY3RlZH0nIGluc3RlYWQuIFRoaXMgbGlicmFyeSBpcyB1c2luZyBBeGlvcyBmb3IgcmVxdWVzdHMuIFBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zIHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIHZhbGlkIHJlcXVlc3Qgb3B0aW9ucy5gO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/options.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/build/src/transporters.js":
/*!*********************************************************************!*\
  !*** ../node_modules/google-auth-library/build/src/transporters.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DefaultTransporter = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(api)/../node_modules/gaxios/build/src/index.js\");\nconst options_1 = __webpack_require__(/*! ./options */ \"(api)/../node_modules/google-auth-library/build/src/options.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(api)/../node_modules/google-auth-library/package.json\");\nconst PRODUCT_NAME = 'google-api-nodejs-client';\nclass DefaultTransporter {\n    /**\n     * Configures request options before making a request.\n     * @param opts GaxiosOptions options.\n     * @return Configured options.\n     */\n    configure(opts = {}) {\n        opts.headers = opts.headers || {};\n        if (typeof window === 'undefined') {\n            // set transporter user agent if not in browser\n            const uaValue = opts.headers['User-Agent'];\n            if (!uaValue) {\n                opts.headers['User-Agent'] = DefaultTransporter.USER_AGENT;\n            }\n            else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n                opts.headers['User-Agent'] = `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n            }\n            // track google-auth-library-nodejs version:\n            if (!opts.headers['x-goog-api-client']) {\n                const nodeVersion = process.version.replace(/^v/, '');\n                opts.headers['x-goog-api-client'] = `gl-node/${nodeVersion}`;\n            }\n        }\n        return opts;\n    }\n    request(opts, callback) {\n        // ensure the user isn't passing in request-style options\n        opts = this.configure(opts);\n        try {\n            (0, options_1.validate)(opts);\n        }\n        catch (e) {\n            if (callback) {\n                return callback(e);\n            }\n            else {\n                throw e;\n            }\n        }\n        if (callback) {\n            (0, gaxios_1.request)(opts).then(r => {\n                callback(null, r);\n            }, e => {\n                callback(this.processError(e));\n            });\n        }\n        else {\n            return (0, gaxios_1.request)(opts).catch(e => {\n                throw this.processError(e);\n            });\n        }\n    }\n    /**\n     * Changes the error to include details from the body.\n     */\n    processError(e) {\n        const res = e.response;\n        const err = e;\n        const body = res ? res.data : null;\n        if (res && body && body.error && res.status !== 200) {\n            if (typeof body.error === 'string') {\n                err.message = body.error;\n                err.code = res.status.toString();\n            }\n            else if (Array.isArray(body.error.errors)) {\n                err.message = body.error.errors\n                    .map((err2) => err2.message)\n                    .join('\\n');\n                err.code = body.error.code;\n                err.errors = body.error.errors;\n            }\n            else {\n                err.message = body.error.message;\n                err.code = body.error.code || res.status;\n            }\n        }\n        else if (res && res.status >= 400) {\n            // Consider all 4xx and 5xx responses errors.\n            err.message = body;\n            err.code = res.status.toString();\n        }\n        return err;\n    }\n}\nexports.DefaultTransporter = DefaultTransporter;\n/**\n * Default user agent.\n */\nDefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;\n//# sourceMappingURL=transporters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL3RyYW5zcG9ydGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQywrREFBUTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBVztBQUNyQztBQUNBLFlBQVksbUJBQU8sQ0FBQyxrRkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCxnREFBZ0QsU0FBUyxFQUFFLDhCQUE4QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYSxHQUFHLFlBQVk7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5lLXVzZXItdG8tc2hlZXRzLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy90cmFuc3BvcnRlcnMuanM/ZjMwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0VHJhbnNwb3J0ZXIgPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBvcHRpb25zXzEgPSByZXF1aXJlKFwiLi9vcHRpb25zXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbmNvbnN0IHBrZyA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpO1xuY29uc3QgUFJPRFVDVF9OQU1FID0gJ2dvb2dsZS1hcGktbm9kZWpzLWNsaWVudCc7XG5jbGFzcyBEZWZhdWx0VHJhbnNwb3J0ZXIge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgcmVxdWVzdCBvcHRpb25zIGJlZm9yZSBtYWtpbmcgYSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzIEdheGlvc09wdGlvbnMgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIENvbmZpZ3VyZWQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25maWd1cmUob3B0cyA9IHt9KSB7XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBzZXQgdHJhbnNwb3J0ZXIgdXNlciBhZ2VudCBpZiBub3QgaW4gYnJvd3NlclxuICAgICAgICAgICAgY29uc3QgdWFWYWx1ZSA9IG9wdHMuaGVhZGVyc1snVXNlci1BZ2VudCddO1xuICAgICAgICAgICAgaWYgKCF1YVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWydVc2VyLUFnZW50J10gPSBEZWZhdWx0VHJhbnNwb3J0ZXIuVVNFUl9BR0VOVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF1YVZhbHVlLmluY2x1ZGVzKGAke1BST0RVQ1RfTkFNRX0vYCkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9IGAke3VhVmFsdWV9ICR7RGVmYXVsdFRyYW5zcG9ydGVyLlVTRVJfQUdFTlR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyYWNrIGdvb2dsZS1hdXRoLWxpYnJhcnktbm9kZWpzIHZlcnNpb246XG4gICAgICAgICAgICBpZiAoIW9wdHMuaGVhZGVyc1sneC1nb29nLWFwaS1jbGllbnQnXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uLnJlcGxhY2UoL152LywgJycpO1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1sneC1nb29nLWFwaS1jbGllbnQnXSA9IGBnbC1ub2RlLyR7bm9kZVZlcnNpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBlbnN1cmUgdGhlIHVzZXIgaXNuJ3QgcGFzc2luZyBpbiByZXF1ZXN0LXN0eWxlIG9wdGlvbnNcbiAgICAgICAgb3B0cyA9IHRoaXMuY29uZmlndXJlKG9wdHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKDAsIG9wdGlvbnNfMS52YWxpZGF0ZSkob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAoMCwgZ2F4aW9zXzEucmVxdWVzdCkob3B0cykudGhlbihyID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByKTtcbiAgICAgICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMucHJvY2Vzc0Vycm9yKGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBnYXhpb3NfMS5yZXF1ZXN0KShvcHRzKS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnByb2Nlc3NFcnJvcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGVycm9yIHRvIGluY2x1ZGUgZGV0YWlscyBmcm9tIHRoZSBib2R5LlxuICAgICAqL1xuICAgIHByb2Nlc3NFcnJvcihlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IGVyciA9IGU7XG4gICAgICAgIGNvbnN0IGJvZHkgPSByZXMgPyByZXMuZGF0YSA6IG51bGw7XG4gICAgICAgIGlmIChyZXMgJiYgYm9keSAmJiBib2R5LmVycm9yICYmIHJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5LmVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYm9keS5lcnJvcjtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IHJlcy5zdGF0dXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYm9keS5lcnJvci5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBib2R5LmVycm9yLmVycm9yc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChlcnIyKSA9PiBlcnIyLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IGJvZHkuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICBlcnIuZXJyb3JzID0gYm9keS5lcnJvci5lcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGJvZHkuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IGJvZHkuZXJyb3IuY29kZSB8fCByZXMuc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcyAmJiByZXMuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgYWxsIDR4eCBhbmQgNXh4IHJlc3BvbnNlcyBlcnJvcnMuXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGJvZHk7XG4gICAgICAgICAgICBlcnIuY29kZSA9IHJlcy5zdGF0dXMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVmYXVsdFRyYW5zcG9ydGVyID0gRGVmYXVsdFRyYW5zcG9ydGVyO1xuLyoqXG4gKiBEZWZhdWx0IHVzZXIgYWdlbnQuXG4gKi9cbkRlZmF1bHRUcmFuc3BvcnRlci5VU0VSX0FHRU5UID0gYCR7UFJPRFVDVF9OQU1FfS8ke3BrZy52ZXJzaW9ufWA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3BvcnRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../node_modules/google-auth-library/build/src/transporters.js\n");

/***/ }),

/***/ "(api)/../node_modules/google-auth-library/package.json":
/*!********************************************************!*\
  !*** ../node_modules/google-auth-library/package.json ***!
  \********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"google-auth-library","version":"8.9.0","author":"Google Inc.","description":"Google APIs Authentication Client Library for Node.js","engines":{"node":">=12"},"main":"./build/src/index.js","types":"./build/src/index.d.ts","repository":"googleapis/google-auth-library-nodejs.git","keywords":["google","api","google apis","client","client library"],"dependencies":{"arrify":"^2.0.0","base64-js":"^1.3.0","ecdsa-sig-formatter":"^1.0.11","fast-text-encoding":"^1.0.0","gaxios":"^5.0.0","gcp-metadata":"^5.3.0","gtoken":"^6.1.0","jws":"^4.0.0","lru-cache":"^6.0.0"},"devDependencies":{"@compodoc/compodoc":"^1.1.7","@types/base64-js":"^1.2.5","@types/chai":"^4.1.7","@types/jws":"^3.1.0","@types/lru-cache":"^5.0.0","@types/mocha":"^9.0.0","@types/mv":"^2.1.0","@types/ncp":"^2.0.1","@types/node":"^16.0.0","@types/sinon":"^10.0.0","assert-rejects":"^1.0.0","c8":"^8.0.0","chai":"^4.2.0","codecov":"^3.0.2","execa":"^5.0.0","gts":"^3.1.0","is-docker":"^2.0.0","karma":"^6.0.0","karma-chrome-launcher":"^3.0.0","karma-coverage":"^2.0.0","karma-firefox-launcher":"^2.0.0","karma-mocha":"^2.0.0","karma-sourcemap-loader":"^0.4.0","karma-webpack":"^5.0.0","keypair":"^1.0.4","linkinator":"^4.0.0","mocha":"^9.2.2","mv":"^2.1.1","ncp":"^2.0.0","nock":"^13.0.0","null-loader":"^4.0.0","puppeteer":"^20.0.0","sinon":"^15.0.0","ts-loader":"^8.0.0","typescript":"^4.6.3","webpack":"^5.21.2","webpack-cli":"^4.0.0"},"files":["build/src","!build/src/**/*.map"],"scripts":{"test":"c8 mocha build/test","clean":"gts clean","prepare":"npm run compile","lint":"gts check","compile":"tsc -p .","fix":"gts fix","pretest":"npm run compile","docs":"compodoc src/","samples-setup":"cd samples/ && npm link ../ && npm run setup && cd ../","samples-test":"cd samples/ && npm link ../ && npm test && cd ../","system-test":"mocha build/system-test --timeout 60000","presystem-test":"npm run compile","webpack":"webpack","browser-test":"karma start","docs-test":"linkinator docs","predocs-test":"npm run docs","prelint":"cd samples; npm link ../; npm install","precompile":"gts clean"},"license":"Apache-2.0"}');

/***/ })

};
;